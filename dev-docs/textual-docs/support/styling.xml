This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/color.py, src/textual/theme.py, src/textual/design.py, src/textual/style.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    color.py
    design.py
    style.py
    theme.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/color.py">
"""
This module contains a powerful [Color][textual.color.Color] class which Textual uses to manipulate colors.

## Named colors

The following named colors are used by the [parse][textual.color.Color.parse] method.


```{.rich columns="80" title="colors"}
from textual._color_constants import COLOR_NAME_TO_RGB
from textual.color import Color
from rich.table import Table
from rich.text import Text
table = Table("Name", "hex", "RGB", "Color", expand=True, highlight=True)

for name, triplet in sorted(COLOR_NAME_TO_RGB.items()):
    if len(triplet) != 3:
        continue
    color = Color(*triplet)
    r, g, b = triplet
    table.add_row(
        f'"{name}"',
        Text(f"{color.hex}", "bold green"),
        f"rgb({r}, {g}, {b})",
        Text("                    ", style=f"on rgb({r},{g},{b})")
    )
output = table
```
"""
⋮----
_TRUECOLOR = ColorType.TRUECOLOR
⋮----
class HSL(NamedTuple)
⋮----
"""A color in HSL (Hue, Saturation, Lightness) format."""
⋮----
h: float
"""Hue in range 0 to 1."""
s: float
"""Saturation in range 0 to 1."""
l: float
"""Lightness in range 0 to 1."""
⋮----
@property
    def css(self) -> str
⋮----
"""HSL in css format."""
⋮----
def as_str(number: float) -> str
⋮----
"""Format a float."""
⋮----
class HSV(NamedTuple)
⋮----
"""A color in HSV (Hue, Saturation, Value) format."""
⋮----
v: float
"""Value in range 0 to 1."""
⋮----
class Lab(NamedTuple)
⋮----
"""A color in CIE-L*ab format."""
⋮----
L: float
"""Lightness in range 0 to 100."""
a: float
"""A axis in range -127 to 128."""
b: float
"""B axis in range -127 to 128."""
⋮----
RE_COLOR = re.compile(
⋮----
# Fast way to split a string of 6 characters into 3 pairs of 2 characters
_split_pairs3: Callable[[str], tuple[str, str, str]] = itemgetter(
# Fast way to split a string of 8 characters into 4 pairs of 2 characters
_split_pairs4: Callable[[str], tuple[str, str, str, str]] = itemgetter(
⋮----
class ColorParseError(Exception)
⋮----
"""A color failed to parse.

    Args:
        message: The error message
        suggested_color: A close color we can suggest.
    """
⋮----
def __init__(self, message: str, suggested_color: str | None = None)
⋮----
@rich.repr.auto
class Color(NamedTuple)
⋮----
"""A class to represent a color.

    Colors are stored as three values representing the degree of red, green, and blue in a color, and a
    fourth "alpha" value which defines where the color lies on a gradient of opaque to transparent.

    Example:
        ```python
        >>> from textual.color import Color
        >>> color = Color.parse("red")
        >>> color
        Color(255, 0, 0)
        >>> color.darken(0.5)
        Color(98, 0, 0)
        >>> color + Color.parse("green")
        Color(0, 128, 0)
        >>> color_with_alpha = Color(100, 50, 25, 0.5)
        >>> color_with_alpha
        Color(100, 50, 25, a=0.5)
        >>> color + color_with_alpha
        Color(177, 25, 12)
        ```
    """
⋮----
r: int
"""Red component in range 0 to 255."""
g: int
"""Green component in range 0 to 255."""
b: int
"""Blue component in range 0 to 255."""
a: float = 1.0
"""Alpha (opacity) component in range 0 to 1."""
ansi: int | None = None
"""ANSI color index. `-1` means default color. `None` if not an ANSI color."""
auto: bool = False
"""Is the color automatic? (automatic colors may be white or black, to provide maximum contrast)"""
⋮----
@classmethod
    def automatic(cls, alpha_percentage: float = 100.0) -> Color
⋮----
"""Create an automatic color."""
⋮----
"""Create a new color from Rich's Color class.

        Args:
            rich_color: An instance of [Rich color][rich.color.Color].
            theme: Optional Rich [terminal theme][rich.terminal_theme.TerminalTheme].

        Returns:
            A new Color instance.
        """
⋮----
@classmethod
    def from_hsl(cls, h: float, s: float, l: float) -> Color
⋮----
"""Create a color from HSL components.

        Args:
            h: Hue.
            s: Saturation.
            l: Lightness.

        Returns:
            A new color.
        """
⋮----
@classmethod
    def from_hsv(cls, h: float, s: float, v: float) -> Color
⋮----
"""Create a color from HSV components.

        Args:
            h: Hue.
            s: Saturation.
            v: Value.

        Returns:
            A new color.
        """
⋮----
@property
    def inverse(self) -> Color
⋮----
"""The inverse of this color.

        Returns:
            Inverse color.
        """
⋮----
@property
    def is_transparent(self) -> bool
⋮----
"""Is the color transparent (i.e. has 0 alpha)?"""
⋮----
@property
    def clamped(self) -> Color
⋮----
"""A clamped color (this color with all values in expected range)."""
⋮----
_clamp = clamp
color = Color(
⋮----
@property
@lru_cache(1024)
    def rich_color(self) -> RichColor
⋮----
"""This color encoded in Rich's Color class.

        Returns:
            A color object as used by Rich.
        """
⋮----
@property
    def normalized(self) -> tuple[float, float, float]
⋮----
"""A tuple of the color components normalized to between 0 and 1.

        Returns:
            Normalized components.
        """
⋮----
@property
    def rgb(self) -> tuple[int, int, int]
⋮----
"""The red, green, and blue color components as a tuple of ints."""
⋮----
@property
    def hsl(self) -> HSL
⋮----
"""This color in HSL format.

        HSL color is an alternative way of representing a color, which can be used in certain color calculations.

        Returns:
            Color encoded in HSL format.
        """
⋮----
@property
    def hsv(self) -> HSV
⋮----
"""This color in HSV format.

        HSV color is an alternative way of representing a color, which can be used in certain color calculations.

        Returns:
            Color encoded in HSV format.
        """
⋮----
@property
    def brightness(self) -> float
⋮----
"""The human perceptual brightness.

        A value of 1 is returned for pure white, and 0 for pure black.
        Other colors lie on a gradient between the two extremes.
        """
⋮----
brightness = (299 * r + 587 * g + 114 * b) / 1000
⋮----
@property
    def hex(self) -> str
⋮----
"""The color in CSS hex form, with 6 digits for RGB, and 8 digits for RGBA.

        For example, `"#46B3DE"` for an RGB color, or `"#3342457F"` for a color with alpha.
        """
⋮----
@property
    def hex6(self) -> str
⋮----
"""The color in CSS hex form, with 6 digits for RGB. Alpha is ignored.

        For example, `"#46B3DE"`.
        """
⋮----
"""The color in CSS RGB or RGBA form.

        For example, `"rgb(10,20,30)"` for an RGB color, or `"rgb(50,70,80,0.5)"` for an RGBA color.
        """
⋮----
alpha_percentage = clamp(a, 0.0, 1.0) * 100.0
⋮----
@property
    def monochrome(self) -> Color
⋮----
"""A monochrome version of this color.

        Returns:
            The monochrome (black and white) version of this color.
        """
⋮----
gray = round(r * 0.2126 + g * 0.7152 + b * 0.0722)
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
def with_alpha(self, alpha: float) -> Color
⋮----
"""Create a new color with the given alpha.

        Args:
            alpha: New value for alpha.

        Returns:
            A new color.
        """
⋮----
def multiply_alpha(self, alpha: float) -> Color
⋮----
"""Create a new color, multiplying the alpha by a constant.

        Args:
            alpha: A value to multiple the alpha by (expected to be in the range 0 to 1).

        Returns:
            A new color.
        """
⋮----
"""Generate a new color between two colors.

        This method calculates a new color on a gradient.
        The position on the gradient is given by `factor`, which is a float between 0 and 1, where 0 is the original color, and 1 is the `destination` color.
        A value of `gradient` between the two extremes produces a color somewhere between the two end points.

        Args:
            destination: Another color.
            factor: A blend factor, 0 -> 1.
            alpha: New alpha for result.

        Returns:
            A new color.
        """
⋮----
destination = self.get_contrast_text(destination.a)
⋮----
new_alpha = a1 + (a2 - a1) * factor
⋮----
new_alpha = alpha
⋮----
@lru_cache(maxsize=1024)
    def tint(self, color: Color) -> Color
⋮----
"""Apply a tint to a color.

        Similar to blend, but combines color and alpha.

        Args:
            color: A color with alpha component.

        Returns:
            New color
        """
⋮----
def __add__(self, other: object) -> Color
⋮----
def __radd__(self, other: object) -> Color
⋮----
@classmethod
@lru_cache(maxsize=1024 * 4)
    def parse(cls, color_text: str | Color) -> Color
⋮----
"""Parse a string containing a named color or CSS-style color.

        Colors may be parsed from the following formats:

        - Text beginning with a `#` is parsed as a hexadecimal color code,
         where R, G, B, and A must be hexadecimal digits (0-9A-F):

            - `#RGB`
            - `#RGBA`
            - `#RRGGBB`
            - `#RRGGBBAA`

        - Alternatively, RGB colors can also be specified in the format
         that follows, where R, G, and B must be numbers between 0 and 255
         and A must be a value between 0 and 1:

            - `rgb(R,G,B)`
            - `rgb(R,G,B,A)`

        - The HSL model can also be used, with a syntax similar to the above,
         if H is a value between 0 and 360, S and L are percentages, and A
         is a value between 0 and 1:

            - `hsl(H,S,L)`
            - `hsla(H,S,L,A)`

        Any other formats will raise a `ColorParseError`.

        Args:
            color_text: Text with a valid color format. Color objects will
                be returned unmodified.

        Raises:
            ColorParseError: If the color is not encoded correctly.

        Returns:
            Instance encoding the color specified by the argument.
        """
⋮----
ansi = ANSI_COLORS.index(color_text[5:])
⋮----
color_from_name = COLOR_NAME_TO_RGB.get(color_text)
⋮----
color_match = RE_COLOR.match(color_text)
⋮----
error_message = f"failed to parse {color_text!r} as a color"
suggested_color = None
⋮----
# Seems like we tried to use a color name: let's try to find one that is close enough:
suggested_color = get_suggestion(
⋮----
r, g, b = rgb_hex_triple  # type: ignore[misc]
color = cls(int(f"{r}{r}", 16), int(f"{g}{g}", 16), int(f"{b}{b}", 16))
⋮----
r, g, b, a = rgb_hex_quad  # type: ignore[misc]
color = cls(
⋮----
color = cls(r, g, b, 1.0)
⋮----
color = cls(r, g, b, a / 255.0)
⋮----
h = float(h) % 360 / 360
s = percentage_string_to_float(s)
l = percentage_string_to_float(l)
color = Color.from_hsl(h, s, l)
⋮----
a = clamp(float(a), 0.0, 1.0)
color = Color.from_hsl(h, s, l).with_alpha(a)
else:  # pragma: no-cover
raise AssertionError(  # pragma: no-cover
⋮----
@lru_cache(maxsize=1024)
    def darken(self, amount: float, alpha: float | None = None) -> Color
⋮----
"""Darken the color by a given amount.

        Args:
            amount: Value between 0-1 to reduce luminance by.
            alpha: Alpha component for new color or None to copy alpha.

        Returns:
            New color.
        """
⋮----
def lighten(self, amount: float, alpha: float | None = None) -> Color
⋮----
"""Lighten the color by a given amount.

        Args:
            amount: Value between 0-1 to increase luminance by.
            alpha: Alpha component for new color or None to copy alpha.

        Returns:
            New color.
        """
⋮----
@lru_cache(maxsize=1024)
    def get_contrast_text(self, alpha: float = 0.95) -> Color
⋮----
"""Get a light or dark color that best contrasts this color, for use with text.

        Args:
            alpha: An alpha value to apply to the result.

        Returns:
            A new color, either an off-white or off-black.
        """
⋮----
class Gradient
⋮----
"""Defines a color gradient."""
⋮----
def __init__(self, *stops: tuple[float, Color | str], quality: int = 50) -> None
⋮----
"""Create a color gradient that blends colors to form a spectrum.

        A gradient is defined by a sequence of "stops" consisting of a tuple containing a float and a color.
        The stop indicates the color at that point on a spectrum between 0 and 1.
        Colors may be given as a [Color][textual.color.Color] instance, or a string that
        can be parsed into a Color (with [Color.parse][textual.color.Color.parse]).

        The `quality` argument defines the number of _steps_ in the gradient. Intermediate colors are
        interpolated from the two nearest colors. Increasing `quality` can generate a smoother looking gradient,
        at the expense of a little extra work to pre-calculate the colors.

        Args:
            stops: Color stops.
            quality: The number of steps in the gradient.

        Raises:
            ValueError: If any stops are missing (must be at least a stop for 0 and 1).
        """
parse = Color.parse
⋮----
@classmethod
    def from_colors(cls, *colors: Color | str, quality: int = 50) -> Gradient
⋮----
"""Construct a gradient form a sequence of colors, where the stops are evenly spaced.

        Args:
            *colors: Positional arguments may be Color instances or strings to parse into a color.
            quality: The number of steps in the gradient.

        Returns:
            A new Gradient instance.
        """
⋮----
stops = [(i / (len(colors) - 1), Color.parse(c)) for i, c in enumerate(colors)]
⋮----
@property
    def colors(self) -> list[Color]
⋮----
"""A list of colors in the gradient."""
position = 0
quality = self._quality
⋮----
colors: list[Color] = []
add_color = colors.append
⋮----
step = step_position / (quality - 1)
⋮----
def get_color(self, position: float) -> Color
⋮----
"""Get a color from the gradient at a position between 0 and 1.

        Positions that are between stops will return a blended color.

        Args:
            position: A number between 0 and 1, where 0 is the first stop, and 1 is the last.

        Returns:
            A Textual color.
        """
⋮----
color_position = position * (self._quality - 1)
color_index = int(color_position)
⋮----
def get_rich_color(self, position: float) -> RichColor
⋮----
"""Get a (Rich) color from the gradient at a position between 0 and 1.

        Positions that are between stops will return a blended color.

        Args:
            position: A number between 0 and 1, where 0 is the first stop, and 1 is the last.

        Returns:
            A (Rich) color.
        """
⋮----
# Color constants
WHITE: Final = Color(255, 255, 255)
"""A constant for pure white."""
BLACK: Final = Color(0, 0, 0)
"""A constant for pure black."""
TRANSPARENT: Final = Color.parse("transparent")
"""A constant for transparent."""
⋮----
def rgb_to_lab(rgb: Color) -> Lab
⋮----
"""Convert an RGB color to the CIE-L*ab format.

    Uses the standard RGB color space with a D65/2⁰ standard illuminant.
    Conversion passes through the XYZ color space.
    Cf. http://www.easyrgb.com/en/math.php.
    """
⋮----
r = pow((r + 0.055) / 1.055, 2.4) if r > 0.04045 else r / 12.92
g = pow((g + 0.055) / 1.055, 2.4) if g > 0.04045 else g / 12.92
b = pow((b + 0.055) / 1.055, 2.4) if b > 0.04045 else b / 12.92
⋮----
x = (r * 41.24 + g * 35.76 + b * 18.05) / 95.047
y = (r * 21.26 + g * 71.52 + b * 7.22) / 100
z = (r * 1.93 + g * 11.92 + b * 95.05) / 108.883
⋮----
off = 16 / 116
x = pow(x, 1 / 3) if x > 0.008856 else 7.787 * x + off
y = pow(y, 1 / 3) if y > 0.008856 else 7.787 * y + off
z = pow(z, 1 / 3) if z > 0.008856 else 7.787 * z + off
⋮----
def lab_to_rgb(lab: Lab, alpha: float = 1.0) -> Color
⋮----
"""Convert a CIE-L*ab color to RGB.

    Uses the standard RGB color space with a D65/2⁰ standard illuminant.
    Conversion passes through the XYZ color space.
    Cf. http://www.easyrgb.com/en/math.php.
    """
⋮----
y = (lab.L + 16) / 116
x = lab.a / 500 + y
z = y - lab.b / 200
⋮----
y = pow(y, 3) if y > 0.2068930344 else (y - off) / 7.787
x = 0.95047 * pow(x, 3) if x > 0.2068930344 else 0.122059 * (x - off)
z = 1.08883 * pow(z, 3) if z > 0.2068930344 else 0.139827 * (z - off)
⋮----
r = x * 3.2406 + y * -1.5372 + z * -0.4986
g = x * -0.9689 + y * 1.8758 + z * 0.0415
b = x * 0.0557 + y * -0.2040 + z * 1.0570
⋮----
r = 1.055 * pow(r, 1 / 2.4) - 0.055 if r > 0.0031308 else 12.92 * r
g = 1.055 * pow(g, 1 / 2.4) - 0.055 if g > 0.0031308 else 12.92 * g
b = 1.055 * pow(b, 1 / 2.4) - 0.055 if b > 0.0031308 else 12.92 * b
</file>

<file path="src/textual/design.py">
NUMBER_OF_SHADES = 3
⋮----
# Where no content exists
DEFAULT_DARK_BACKGROUND = "#121212"
# What text usually goes on top off
DEFAULT_DARK_SURFACE = "#1e1e1e"
⋮----
DEFAULT_LIGHT_SURFACE = "#f5f5f5"
DEFAULT_LIGHT_BACKGROUND = "#efefef"
⋮----
@rich.repr.auto
class ColorSystem
⋮----
"""Defines a standard set of colors and variations for building a UI.

    Primary is the main theme color
    Secondary is a second theme color
    """
⋮----
COLOR_NAMES = [
⋮----
def parse(color: str | None) -> Color | None
⋮----
"""Overrides for specific variables."""
⋮----
@property
    def shades(self) -> Iterable[str]
⋮----
"""The names of the colors and derived shades."""
⋮----
def get_or_default(self, name: str, default: str) -> str
⋮----
"""Get the value of a color variable, or the default value if not set."""
⋮----
def generate(self) -> dict[str, str]
⋮----
"""Generate a mapping of color name on to a CSS color.

        Returns:
            A mapping of color name on to a CSS-style encoded color
        """
⋮----
primary = self.primary
secondary = self.secondary or primary
warning = self.warning or primary
error = self.error or secondary
success = self.success or secondary
accent = self.accent or primary
⋮----
dark = self.dark
luminosity_spread = self.luminosity_spread
⋮----
colors: dict[str, str] = {}
⋮----
background = self.background or Color.parse(DEFAULT_DARK_BACKGROUND)
surface = self.surface or Color.parse(DEFAULT_DARK_SURFACE)
⋮----
background = self.background or Color.parse(DEFAULT_LIGHT_BACKGROUND)
surface = self.surface or Color.parse(DEFAULT_LIGHT_SURFACE)
⋮----
foreground = self.foreground or (background.inverse)
contrast_text = background.get_contrast_text(1.0)
boost = self.boost or contrast_text.with_alpha(0.04)
⋮----
# Colored text
⋮----
panel = surface.blend(primary, 0.1, alpha=1)
⋮----
panel = self.panel
⋮----
def luminosity_range(spread: float) -> Iterable[tuple[str, float]]
⋮----
"""Get the range of shades from darken2 to lighten2.

            Returns:
                Iterable of tuples (<SHADE SUFFIX, LUMINOSITY DELTA>)
            """
luminosity_step = spread / 2
⋮----
label = "-darken"
⋮----
label = "-lighten"
⋮----
label = ""
⋮----
# Color names and color
COLORS: list[tuple[str, Color]] = [
⋮----
# Colors names that have a dark variant
DARK_SHADES = {"primary-background", "secondary-background"}
⋮----
get = self.get_or_default
⋮----
is_dark_shade = dark and name in DARK_SHADES
spread = luminosity_spread
⋮----
key = f"{name}{shade_name}"
⋮----
dark_background = background.blend(color, 0.15, alpha=1.0)
⋮----
shade_color = dark_background.blend(
⋮----
# Muted variants of base colors
⋮----
# Foreground colors
⋮----
# The cursor color for widgets such as OptionList, DataTable, etc.
⋮----
# The border color for focused widgets which have a border.
⋮----
# The surface color for builtin focused widgets
⋮----
# The scrollbar colors
⋮----
# colors["scrollbar-active"] = get("scrollbar-active", colors["panel-lighten-2"])
⋮----
# Links
⋮----
# Markdown header styles
⋮----
def show_design(light: ColorSystem, dark: ColorSystem) -> Table
⋮----
"""Generate a renderable to show color systems.

    Args:
        light: Light ColorSystem.
        dark: Dark ColorSystem

    Returns:
        Table showing all colors.
    """
⋮----
@group()
    def make_shades(system: ColorSystem)
⋮----
colors = system.generate()
⋮----
background = Color.parse(colors[name]).with_alpha(1.0)
foreground = background + background.get_contrast_text(0.9)
⋮----
text = Text(f"${name}")
⋮----
table = Table(box=None, expand=True)
</file>

<file path="src/textual/style.py">
"""
The Style class contains all the information needed to generate styled terminal output.

You won't often need to create Style objects directly, if you are using [Content][textual.content.Content] for output.
But you might want to use styles for more customized widgets.
"""
⋮----
_get_hash_attributes = attrgetter(
⋮----
_get_simple_attributes = attrgetter(
⋮----
_get_simple_attributes_sans_color = attrgetter(
⋮----
_get_attributes = attrgetter(
⋮----
@rich.repr.auto()
@dataclass(frozen=True)
class Style
⋮----
"""Represents a style in the Visual interface (color and other attributes).

    Styles may be added together, which combines their style attributes.

    """
⋮----
background: Color | None = None
foreground: Color | None = None
bold: bool | None = None
dim: bool | None = None
italic: bool | None = None
underline: bool | None = None
underline2: bool | None = None
reverse: bool | None = None
strike: bool | None = None
blink: bool | None = None
link: str | None = None
_meta: bytes | None = None
auto_color: bool = False
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
@cached_property
    def _is_null(self) -> bool
⋮----
@cached_property
    def hash(self) -> int
⋮----
"""A hash of the style's attributes."""
⋮----
def __hash__(self) -> int
⋮----
def __eq__(self, other: Any) -> bool
⋮----
def __bool__(self) -> bool
⋮----
def __str__(self) -> str
⋮----
@cached_property
    def style_definition(self) -> str
⋮----
"""Style encoded in a string (may be parsed from `Style.parse`)."""
output: list[str] = []
output_append = output.append
⋮----
@cached_property
    def markup_tag(self) -> str
⋮----
"""Identifier used to close tags in markup."""
⋮----
@lru_cache(maxsize=1024 * 4)
    def __add__(self, other: object | None) -> Style
⋮----
new_style = Style(
⋮----
__radd__ = __add__
⋮----
@classmethod
    def null(cls) -> Style
⋮----
"""Get a null (no color or style) style."""
⋮----
@classmethod
    def parse(cls, text_style: str, variables: dict[str, str] | None = None) -> Style
⋮----
"""Parse a style from text.

        Args:
            text_style: A style encoded in a string.
            variables: Optional mapping of CSS variables. `None` to get variables from the app.

        Returns:
            New style.
        """
⋮----
app = active_app.get()
⋮----
@classmethod
    def _normalize_markup_tag(cls, text_style: str) -> str
⋮----
"""Produces a normalized from of a style, used to match closing tags with opening tags.

        Args:
            text_style: Style to normalize.

        Returns:
            Normalized markup tag.
        """
⋮----
style = cls.parse(text_style)
⋮----
"""Build a Style from a (Rich) Style.

        Args:
            rich_style: A Rich Style object.
            theme: Optional Rich [terminal theme][rich.terminal_theme.TerminalTheme].

        Returns:
            New Style.
        """
⋮----
@classmethod
    def from_styles(cls, styles: StylesBase) -> Style
⋮----
"""Create a Visual Style from a Textual styles object.

        Args:
            styles: A Styles object, such as `my_widget.styles`.

        """
text_style = styles.text_style
⋮----
@classmethod
    def from_meta(cls, meta: Mapping[str, Any]) -> Style
⋮----
"""Create a Visual Style containing meta information.

        Args:
            meta: A dictionary of meta information.

        Returns:
            A new Style.
        """
⋮----
@cached_property
    def rich_style(self) -> RichStyle
⋮----
"""Convert this Styles into a Rich style.

        Returns:
            A Rich style object.
        """
⋮----
color = None if foreground is None else background + foreground
⋮----
def rich_style_with_offset(self, x: int, y: int) -> RichStyle
⋮----
"""Get a Rich style with the given offset included in meta.

        This is used in text selection.

        Args:
            x: X coordinate.
            y: Y coordinate.

        Returns:
            A Rich Style object.
        """
⋮----
@cached_property
    def without_color(self) -> Style
⋮----
"""The style without any colors."""
⋮----
@cached_property
    def background_style(self) -> Style
⋮----
"""Just the background color, with no other attributes."""
⋮----
@property
    def has_transparent_foreground(self) -> bool
⋮----
"""Is the foreground transparent (or not set)?"""
⋮----
@classmethod
    def combine(cls, styles: Iterable[Style]) -> Style
⋮----
"""Add a number of styles and get the result."""
iter_styles = iter(styles)
⋮----
@cached_property
    def meta(self) -> Mapping[str, Any]
⋮----
"""Get meta information (can not be changed after construction)."""
⋮----
NULL_STYLE = Style()
</file>

<file path="src/textual/theme.py">
@dataclass
class Theme
⋮----
"""Defines a theme for the application."""
⋮----
name: str
"""The name of the theme.

    After registering a theme with `App.register_theme`, you can set the theme with
    `App.theme = theme_name`. This will immediately apply the theme's colors to your
    application.
    """
⋮----
primary: str
secondary: str | None = None
warning: str | None = None
error: str | None = None
success: str | None = None
accent: str | None = None
foreground: str | None = None
background: str | None = None
surface: str | None = None
panel: str | None = None
boost: str | None = None
dark: bool = True
luminosity_spread: float = 0.15
text_alpha: float = 0.95
variables: dict[str, str] = field(default_factory=dict)
⋮----
def to_color_system(self) -> ColorSystem
⋮----
"""
        Create a ColorSystem instance from this Theme.

        Returns:
            A ColorSystem instance with attributes copied from this Theme.
        """
⋮----
BUILTIN_THEMES: dict[str, Theme] = {
⋮----
warning="#E0AF68",  # Yellow
error="#F7768E",  # Red
success="#9ECE6A",  # Green
accent="#FF9E64",  # Orange
⋮----
background="#1A1B26",  # Background
surface="#24283B",  # Surface
panel="#414868",  # Panel
⋮----
primary="#205EA6",  # blue
secondary="#24837B",  # cyan
warning="#AD8301",  # yellow
error="#AF3029",  # red
success="#66800B",  # green
accent="#9B76C8",  # purple light
background="#100F0F",  # base.black
surface="#1C1B1A",  # base.950
panel="#282726",  # base.900
foreground="#FFFCF0",  # base.paper
⋮----
"input-selection-background": "#6F6E69 35%",  # base.600 with opacity
⋮----
"input-selection-background": "#073642",  # Base02
⋮----
class ThemeProvider(Provider)
⋮----
"""A provider for themes."""
⋮----
@property
    def commands(self) -> list[tuple[str, Callable[[], None]]]
⋮----
themes = self.app.available_themes
⋮----
def set_app_theme(name: str) -> None
⋮----
async def discover(self) -> Hits
⋮----
async def search(self, query: str) -> Hits
⋮----
matcher = self.matcher(query)
</file>

</files>
