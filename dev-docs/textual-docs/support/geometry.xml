This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/geometry.py, src/textual/coordinate.py, src/textual/strip.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    coordinate.py
    geometry.py
    strip.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/coordinate.py">
"""
A class to store a coordinate, used by the [DataTable][textual.widgets.DataTable].
"""
⋮----
class Coordinate(NamedTuple)
⋮----
"""An object representing a row/column coordinate within a grid."""
⋮----
row: int
"""The row of the coordinate within a grid."""
⋮----
column: int
"""The column of the coordinate within a grid."""
⋮----
def left(self) -> Coordinate
⋮----
"""Get the coordinate to the left.

        Returns:
            The coordinate to the left.
        """
⋮----
def right(self) -> Coordinate
⋮----
"""Get the coordinate to the right.

        Returns:
            The coordinate to the right.
        """
⋮----
def up(self) -> Coordinate
⋮----
"""Get the coordinate above.

        Returns:
            The coordinate above.
        """
⋮----
def down(self) -> Coordinate
⋮----
"""Get the coordinate below.

        Returns:
            The coordinate below.
        """
</file>

<file path="src/textual/geometry.py">
"""

Functions and classes to manage terminal geometry (anything involving coordinates or dimensions).
"""
⋮----
SpacingDimensions: TypeAlias = Union[
"""The valid ways in which you can specify spacing."""
⋮----
T = TypeVar("T", int, float)
⋮----
def clamp(value: T, minimum: T, maximum: T) -> T
⋮----
"""Restrict a value to a given range.

    If `value` is less than the minimum, return the minimum.
    If `value` is greater than the maximum, return the maximum.
    Otherwise, return `value`.

    The `minimum` and `maximum` arguments values may be given in reverse order.

    Args:
        value: A value.
        minimum: Minimum value.
        maximum: Maximum value.

    Returns:
        New value that is not less than the minimum or greater than the maximum.
    """
⋮----
# It is common for the min and max to be in non-intuitive order.
# Rather than force the caller to get it right, it is simpler to handle it here.
⋮----
class Offset(NamedTuple)
⋮----
"""A cell offset defined by x and y coordinates.

    Offsets are typically relative to the top left of the terminal or other container.

    Textual prefers the names `x` and `y`, but you could consider `x` to be the _column_ and `y` to be the _row_.

    Offsets support addition, subtraction, multiplication, and negation.

    Example:
        ```python
        >>> from textual.geometry import Offset
        >>> offset = Offset(3, 2)
        >>> offset
        Offset(x=3, y=2)
        >>> offset += Offset(10, 0)
        >>> offset
        Offset(x=13, y=2)
        >>> -offset
        Offset(x=-13, y=-2)
        ```
    """
⋮----
x: int = 0
"""Offset in the x-axis (horizontal)"""
y: int = 0
"""Offset in the y-axis (vertical)"""
⋮----
@property
    def is_origin(self) -> bool
⋮----
"""Is the offset at (0, 0)?"""
⋮----
@property
    def clamped(self) -> Offset
⋮----
"""This offset with `x` and `y` restricted to values above zero."""
⋮----
@property
    def transpose(self) -> tuple[int, int]
⋮----
"""A tuple of x and y, in reverse order, i.e. (y, x)."""
⋮----
def __bool__(self) -> bool
⋮----
def __add__(self, other: object) -> Offset
⋮----
def __sub__(self, other: object) -> Offset
⋮----
def __mul__(self, other: object) -> Offset
⋮----
def __neg__(self) -> Offset
⋮----
def blend(self, destination: Offset, factor: float) -> Offset
⋮----
"""Calculate a new offset on a line between this offset and a destination offset.

        Args:
            destination: Point where factor would be 1.0.
            factor: A value between 0 and 1.0.

        Returns:
            A new point on a line between self and destination.
        """
⋮----
def get_distance_to(self, other: Offset) -> float
⋮----
"""Get the distance to another offset.

        Args:
            other: An offset.

        Returns:
            Distance to other offset.
        """
⋮----
distance: float = ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) ** 0.5
⋮----
def clamp(self, width: int, height: int) -> Offset
⋮----
"""Clamp the offset to fit within a rectangle of width x height.

        Args:
            width: Width to clamp.
            height: Height to clamp.

        Returns:
            A new offset.
        """
⋮----
class Size(NamedTuple)
⋮----
"""The dimensions (width and height) of a rectangular region.

    Example:
        ```python
        >>> from textual.geometry import Size
        >>> size = Size(2, 3)
        >>> size
        Size(width=2, height=3)
        >>> size.area
        6
        >>> size + Size(10, 20)
        Size(width=12, height=23)
        ```
    """
⋮----
width: int = 0
"""The width in cells."""
⋮----
height: int = 0
"""The height in cells."""
⋮----
"""A Size is Falsy if it has area 0."""
⋮----
@property
    def area(self) -> int
⋮----
"""The area occupied by a region of this size."""
⋮----
@property
    def region(self) -> Region
⋮----
"""A region of the same size, at the origin."""
⋮----
@property
    def line_range(self) -> range
⋮----
"""A range object that covers values between 0 and `height`."""
⋮----
def with_width(self, width: int) -> Size
⋮----
"""Get a new Size with just the width changed.

        Args:
            width: New width.

        Returns:
            New Size instance.
        """
⋮----
def with_height(self, height: int) -> Size
⋮----
"""Get a new Size with just the height changed.

        Args:
            height: New height.

        Returns:
            New Size instance.
        """
⋮----
def __add__(self, other: object) -> Size
⋮----
def __sub__(self, other: object) -> Size
⋮----
def contains(self, x: int, y: int) -> bool
⋮----
"""Check if a point is in area defined by the size.

        Args:
            x: X coordinate.
            y: Y coordinate.

        Returns:
            True if the point is within the region.
        """
⋮----
def contains_point(self, point: tuple[int, int]) -> bool
⋮----
"""Check if a point is in the area defined by the size.

        Args:
            point: A tuple of x and y coordinates.

        Returns:
            True if the point is within the region.
        """
⋮----
def __contains__(self, other: Any) -> bool
⋮----
x: int
y: int
⋮----
def clamp_offset(self, offset: Offset) -> Offset
⋮----
"""Clamp an offset to fit within the width x height.

        Args:
            offset: An offset.

        Returns:
            A new offset that will fit inside the dimensions defined in the Size.
        """
⋮----
class Region(NamedTuple)
⋮----
"""Defines a rectangular region.

    A Region consists of a coordinate (x and y) and dimensions (width and height).

    ```
      (x, y)
        ┌────────────────────┐ ▲
        │                    │ │
        │                    │ │
        │                    │ height
        │                    │ │
        │                    │ │
        └────────────────────┘ ▼
        ◀─────── width ──────▶
    ```

    Example:
        ```python
        >>> from textual.geometry import Region
        >>> region = Region(4, 5, 20, 10)
        >>> region
        Region(x=4, y=5, width=20, height=10)
        >>> region.area
        200
        >>> region.size
        Size(width=20, height=10)
        >>> region.offset
        Offset(x=4, y=5)
        >>> region.contains(1, 2)
        False
        >>> region.contains(10, 8)
        True
        ```
    """
⋮----
"""Offset in the x-axis (horizontal)."""
⋮----
"""Offset in the y-axis (vertical)."""
⋮----
"""The width of the region."""
⋮----
"""The height of the region."""
⋮----
@classmethod
    def from_union(cls, regions: Collection[Region]) -> Region
⋮----
"""Create a Region from the union of other regions.

        Args:
            regions: One or more regions.

        Returns:
            A Region that encloses all other regions.
        """
⋮----
min_x = min(regions, key=itemgetter(0)).x
max_x = max(regions, key=attrgetter("right")).right
min_y = min(regions, key=itemgetter(1)).y
max_y = max(regions, key=attrgetter("bottom")).bottom
⋮----
@classmethod
    def from_corners(cls, x1: int, y1: int, x2: int, y2: int) -> Region
⋮----
"""Construct a Region form the top left and bottom right corners.

        Args:
            x1: Top left x.
            y1: Top left y.
            x2: Bottom right x.
            y2: Bottom right y.

        Returns:
            A new region.
        """
⋮----
@classmethod
    def from_offset(cls, offset: tuple[int, int], size: tuple[int, int]) -> Region
⋮----
"""Create a region from offset and size.

        Args:
            offset: Offset (top left point).
            size: Dimensions of region.

        Returns:
            A region instance.
        """
⋮----
"""Calculate the smallest offset required to translate a window so that it contains
        another region.

        This method is used to calculate the required offset to scroll something into view.

        Args:
            window_region: The window region.
            region: The region to move inside the window.
            top: Get offset to top of window.

        Returns:
            An offset required to add to region to move it inside window_region.
        """
⋮----
# Region is already inside the window, so no need to move it.
⋮----
region = region.crop_size(window_region.size)
⋮----
delta_x = delta_y = 0
⋮----
# The region does not fit
# The window needs to scroll on the X axis to bring region into view
delta_x = min(
⋮----
delta_y = top_ - window_top
⋮----
# The window needs to scroll on the Y axis to bring region into view
delta_y = min(
⋮----
"""A Region is considered False when it has no area."""
⋮----
@property
    def column_span(self) -> tuple[int, int]
⋮----
"""A pair of integers for the start and end columns (x coordinates) in this region.

        The end value is *exclusive*.
        """
⋮----
@property
    def line_span(self) -> tuple[int, int]
⋮----
"""A pair of integers for the start and end lines (y coordinates) in this region.

        The end value is *exclusive*.
        """
⋮----
@property
    def right(self) -> int
⋮----
"""Maximum X value (non inclusive)."""
⋮----
@property
    def bottom(self) -> int
⋮----
"""Maximum Y value (non inclusive)."""
⋮----
"""The area under the region."""
⋮----
@property
    def offset(self) -> Offset
⋮----
"""The top left corner of the region.

        Returns:
            An offset.
        """
⋮----
@property
    def center(self) -> tuple[float, float]
⋮----
"""The center of the region.

        Note, that this does *not* return an `Offset`, because the center may not be an integer coordinate.

        Returns:
            Tuple of floats.
        """
⋮----
@property
    def bottom_left(self) -> Offset
⋮----
"""Bottom left offset of the region.

        Returns:
            An offset.
        """
⋮----
@property
    def top_right(self) -> Offset
⋮----
"""Top right offset of the region.

        Returns:
            An offset.
        """
⋮----
@property
    def bottom_right(self) -> Offset
⋮----
"""Bottom right offset of the region.

        Returns:
            An offset.
        """
⋮----
@property
    def bottom_right_inclusive(self) -> Offset
⋮----
"""Bottom right corner of the region, within its boundaries."""
⋮----
@property
    def size(self) -> Size
⋮----
"""Get the size of the region."""
⋮----
@property
    def corners(self) -> tuple[int, int, int, int]
⋮----
"""The top left and bottom right coordinates as a tuple of four integers."""
⋮----
@property
    def column_range(self) -> range
⋮----
"""A range object for X coordinates."""
⋮----
"""A range object for Y coordinates."""
⋮----
@property
    def reset_offset(self) -> Region
⋮----
"""An region of the same size at (0, 0).

        Returns:
            A region at the origin.
        """
⋮----
def __add__(self, other: object) -> Region
⋮----
def __sub__(self, other: object) -> Region
⋮----
def get_spacing_between(self, region: Region) -> Spacing
⋮----
"""Get spacing between two regions.

        Args:
            region: Another region.

        Returns:
            Spacing that if subtracted from `self` produces `region`.
        """
⋮----
def at_offset(self, offset: tuple[int, int]) -> Region
⋮----
"""Get a new Region with the same size at a given offset.

        Args:
            offset: An offset.

        Returns:
            New Region with adjusted offset.
        """
⋮----
def crop_size(self, size: tuple[int, int]) -> Region
⋮----
"""Get a region with the same offset, with a size no larger than `size`.

        Args:
            size: Maximum width and height (WIDTH, HEIGHT).

        Returns:
            New region that could fit within `size`.
        """
⋮----
def expand(self, size: tuple[int, int]) -> Region
⋮----
"""Increase the size of the region by adding a border.

        Args:
            size: Additional width and height.

        Returns:
            A new region.
        """
⋮----
@lru_cache(maxsize=1024)
    def overlaps(self, other: Region) -> bool
⋮----
"""Check if another region overlaps this region.

        Args:
            other: A Region.

        Returns:
            True if other region shares any cells with this region.
        """
⋮----
"""Check if a point is in the region.

        Args:
            x: X coordinate.
            y: Y coordinate.

        Returns:
            True if the point is within the region.
        """
⋮----
"""Check if a point is in the region.

        Args:
            point: A tuple of x and y coordinates.

        Returns:
            True if the point is within the region.
        """
⋮----
@lru_cache(maxsize=1024)
    def contains_region(self, other: Region) -> bool
⋮----
"""Check if a region is entirely contained within this region.

        Args:
            other: A region.

        Returns:
            True if the other region fits perfectly within this region.
        """
⋮----
@lru_cache(maxsize=1024)
    def translate(self, offset: tuple[int, int]) -> Region
⋮----
"""Move the offset of the Region.

        Args:
            offset: Offset to add to region.

        Returns:
            A new region shifted by (x, y).
        """
⋮----
@lru_cache(maxsize=4096)
    def __contains__(self, other: Any) -> bool
⋮----
"""Check if a point is in this region."""
⋮----
def clip(self, width: int, height: int) -> Region
⋮----
"""Clip this region to fit within width, height.

        Args:
            width: Width of bounds.
            height: Height of bounds.

        Returns:
            Clipped region.
        """
⋮----
_clamp = clamp
new_region = Region.from_corners(
⋮----
@lru_cache(maxsize=4096)
    def grow(self, margin: tuple[int, int, int, int]) -> Region
⋮----
"""Grow a region by adding spacing.

        Args:
            margin: Grow space by `(<top>, <right>, <bottom>, <left>)`.

        Returns:
            New region.
        """
⋮----
@lru_cache(maxsize=4096)
    def shrink(self, margin: tuple[int, int, int, int]) -> Region
⋮----
"""Shrink a region by subtracting spacing.

        Args:
            margin: Shrink space by `(<top>, <right>, <bottom>, <left>)`.

        Returns:
            The new, smaller region.
        """
⋮----
@lru_cache(maxsize=4096)
    def intersection(self, region: Region) -> Region
⋮----
"""Get the overlapping portion of the two regions.

        Args:
            region: A region that overlaps this region.

        Returns:
            A new region that covers when the two regions overlap.
        """
# Unrolled because this method is used a lot
⋮----
x2 = x1 + w1
y2 = y1 + h1
cx2 = cx1 + w2
cy2 = cy1 + h2
⋮----
rx1 = cx2 if x1 > cx2 else (cx1 if x1 < cx1 else x1)
ry1 = cy2 if y1 > cy2 else (cy1 if y1 < cy1 else y1)
rx2 = cx2 if x2 > cx2 else (cx1 if x2 < cx1 else x2)
ry2 = cy2 if y2 > cy2 else (cy1 if y2 < cy1 else y2)
⋮----
@lru_cache(maxsize=4096)
    def union(self, region: Region) -> Region
⋮----
"""Get the smallest region that contains both regions.

        Args:
            region: Another region.

        Returns:
            An optimally sized region to cover both regions.
        """
⋮----
union_region = self.from_corners(
⋮----
@lru_cache(maxsize=1024)
    def split(self, cut_x: int, cut_y: int) -> tuple[Region, Region, Region, Region]
⋮----
"""Split a region into 4 from given x and y offsets (cuts).

        ```
                   cut_x ↓
                ┌────────┐ ┌───┐
                │        │ │   │
                │    0   │ │ 1 │
                │        │ │   │
        cut_y → └────────┘ └───┘
                ┌────────┐ ┌───┐
                │    2   │ │ 3 │
                └────────┘ └───┘
        ```

        Args:
            cut_x: Offset from self.x where the cut should be made. If negative, the cut
                is taken from the right edge.
            cut_y: Offset from self.y where the cut should be made. If negative, the cut
                is taken from the lower edge.

        Returns:
            Four new regions which add up to the original (self).
        """
⋮----
cut_x = width + cut_x
⋮----
cut_y = height + cut_y
⋮----
_Region = Region
⋮----
@lru_cache(maxsize=1024)
    def split_vertical(self, cut: int) -> tuple[Region, Region]
⋮----
"""Split a region into two, from a given x offset.

        ```
                 cut ↓
            ┌────────┐┌───┐
            │    0   ││ 1 │
            │        ││   │
            └────────┘└───┘
        ```

        Args:
            cut: An offset from self.x where the cut should be made. If cut is negative,
                it is taken from the right edge.

        Returns:
            Two regions, which add up to the original (self).
        """
⋮----
cut = width + cut
⋮----
@lru_cache(maxsize=1024)
    def split_horizontal(self, cut: int) -> tuple[Region, Region]
⋮----
"""Split a region into two, from a given y offset.

        ```
                    ┌─────────┐
                    │    0    │
                    │         │
            cut →   └─────────┘
                    ┌─────────┐
                    │    1    │
                    └─────────┘
        ```

        Args:
            cut: An offset from self.y where the cut should be made. May be negative,
                for the offset to start from the lower edge.

        Returns:
            Two regions, which add up to the original (self).
        """
⋮----
cut = height + cut
⋮----
"""Translate this region, so it fits within a container.

        This will ensure that there is as little overlap as possible.
        The top left of the returned region is guaranteed to be within the container.

        ```
        ┌──────────────────┐         ┌──────────────────┐
        │    container     │         │    container     │
        │                  │         │    ┌─────────────┤
        │                  │   ──▶   │    │    return   │
        │       ┌──────────┴──┐      │    │             │
        │       │    self     │      │    │             │
        └───────┤             │      └────┴─────────────┘
                │             │
                └─────────────┘
        ```


        Args:
            container: A container region.
            x_axis: Allow translation of X axis.
            y_axis: Allow translation of Y axis.

        Returns:
            A new region with same dimensions that fits with inside container.
        """
⋮----
"""Inflect a region around one or both axis.

        The `x_axis` and `y_axis` parameters define which direction to move the region.
        A positive value will move the region right or down, a negative value will move
        the region left or up. A value of `0` will leave that axis unmodified.

        If a margin is provided, it will add space between the resulting region.

        Note that if margin is specified it *overlaps*, so the space will be the maximum
        of two edges, and not the total.

        ```
        ╔══════════╗    │
        ║          ║
        ║   Self   ║    │
        ║          ║
        ╚══════════╝    │

        ─ ─ ─ ─ ─ ─ ─ ─ ┌──────────┐
                        │          │
                        │  Result  │
                        │          │
                        └──────────┘
        ```

        Args:
            x_axis: +1 to inflect in the positive direction, -1 to inflect in the negative direction.
            y_axis: +1 to inflect in the positive direction, -1 to inflect in the negative direction.
            margin: Additional margin.

        Returns:
            A new region.
        """
inflect_margin = NULL_SPACING if margin is None else margin
⋮----
"""Constrain a region to fit within a container, using different methods per axis.

        Args:
            constrain_x: Constrain method for the X-axis.
            constrain_y: Constrain method for the Y-axis.
            margin: Margin to maintain around region.
            container: Container to constrain to.

        Returns:
            New widget, that fits inside the container (if possible).
        """
margin_region = self.grow(margin)
region = self
⋮----
"""Compare a span with a container

            Args:
                span_start: Start of the span.
                span_end: end of the span.
                container_start: Start of the container.
                container_end: End of the container.

            Returns:
                0 if the span fits, -1 if it is less that the container, otherwise +1
            """
⋮----
# Apply any inflected constraints
⋮----
region = region.inflect(
⋮----
# Apply translate inside constrains
# Note this is also applied, if a previous inflect constrained has been applied
# This is so that the origin is always inside the container
region = region.translate_inside(
⋮----
class Spacing(NamedTuple)
⋮----
"""Stores spacing around a widget, such as padding and border.

    Spacing is defined by four integers for the space at the top, right, bottom, and left of a region.

    ```
    ┌ ─ ─ ─ ─ ─ ─ ─▲─ ─ ─ ─ ─ ─ ─ ─ ┐
                   │ top
    │        ┏━━━━━▼━━━━━━┓         │
     ◀──────▶┃            ┃◀───────▶
    │  left  ┃            ┃ right   │
             ┃            ┃
    │        ┗━━━━━▲━━━━━━┛         │
                   │ bottom
    └ ─ ─ ─ ─ ─ ─ ─▼─ ─ ─ ─ ─ ─ ─ ─ ┘
    ```

    Example:
        ```python
        >>> from textual.geometry import Region, Spacing
        >>> region = Region(2, 3, 20, 10)
        >>> spacing = Spacing(1, 2, 3, 4)
        >>> region.grow(spacing)
        Region(x=-2, y=2, width=26, height=14)
        >>> region.shrink(spacing)
        Region(x=6, y=4, width=14, height=6)
        >>> spacing.css
        '1 2 3 4'
        ```
    """
⋮----
top: int = 0
"""Space from the top of a region."""
right: int = 0
"""Space from the right of a region."""
bottom: int = 0
"""Space from the bottom of a region."""
left: int = 0
"""Space from the left of a region."""
⋮----
@property
    def width(self) -> int
⋮----
"""Total space in the x axis."""
⋮----
@property
    def height(self) -> int
⋮----
"""Total space in the y axis."""
⋮----
@property
    def max_width(self) -> int
⋮----
"""The space between regions in the X direction if margins overlap, i.e. `max(self.left, self.right)`."""
⋮----
@property
    def max_height(self) -> int
⋮----
"""The space between regions in the Y direction if margins overlap, i.e. `max(self.top, self.bottom)`."""
⋮----
@property
    def top_left(self) -> tuple[int, int]
⋮----
"""A pair of integers for the left, and top space."""
⋮----
@property
    def bottom_right(self) -> tuple[int, int]
⋮----
"""A pair of integers for the right, and bottom space."""
⋮----
@property
    def totals(self) -> tuple[int, int]
⋮----
"""A pair of integers for the total horizontal and vertical space."""
⋮----
@property
    def css(self) -> str
⋮----
"""A string containing the spacing in CSS format.

        For example: "1" or "2 4" or "4 2 8 2".
        """
⋮----
@classmethod
    def unpack(cls, pad: SpacingDimensions) -> Spacing
⋮----
"""Unpack padding specified in CSS style.

        Args:
            pad: An integer, or tuple of 1, 2, or 4 integers.

        Raises:
            ValueError: If `pad` is an invalid value.

        Returns:
            New Spacing object.
        """
⋮----
pad_len = len(pad)
⋮----
_pad = pad[0]
⋮----
@classmethod
    def vertical(cls, amount: int) -> Spacing
⋮----
"""Construct a Spacing with a given amount of spacing on vertical edges,
        and no horizontal spacing.

        Args:
            amount: The magnitude of spacing to apply to vertical edges.

        Returns:
            `Spacing(amount, 0, amount, 0)`
        """
⋮----
@classmethod
    def horizontal(cls, amount: int) -> Spacing
⋮----
"""Construct a Spacing with a given amount of spacing on horizontal edges,
        and no vertical spacing.

        Args:
            amount: The magnitude of spacing to apply to horizontal edges.

        Returns:
            `Spacing(0, amount, 0, amount)`
        """
⋮----
@classmethod
    def all(cls, amount: int) -> Spacing
⋮----
"""Construct a Spacing with a given amount of spacing on all edges.

        Args:
            amount: The magnitude of spacing to apply to all edges.

        Returns:
            `Spacing(amount, amount, amount, amount)`
        """
⋮----
def __add__(self, other: object) -> Spacing
⋮----
def __sub__(self, other: object) -> Spacing
⋮----
def grow_maximum(self, other: Spacing) -> Spacing
⋮----
"""Grow spacing with a maximum.

        Args:
            other: Spacing object.

        Returns:
            New spacing where the values are maximum of the two values.
        """
⋮----
NULL_OFFSET: Final = Offset(0, 0)
"""An [offset][textual.geometry.Offset] constant for (0, 0)."""
⋮----
NULL_REGION: Final = Region(0, 0, 0, 0)
"""A [Region][textual.geometry.Region] constant for a null region (at the origin, with both width and height set to zero)."""
⋮----
NULL_SIZE: Final = Size(0, 0)
"""A [Size][textual.geometry.Size] constant for a null size (with zero area)."""
⋮----
NULL_SPACING: Final = Spacing(0, 0, 0, 0)
"""A [Spacing][textual.geometry.Spacing] constant for no space."""
</file>

<file path="src/textual/strip.py">
"""
This module contains the `Strip` class and related objects.

A `Strip` contains the result of rendering a widget.
See [Line API](/guide/widgets#line-api) for how to use Strips.
"""
⋮----
SGR_STYLES = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "21", "51", "52", "53"]
⋮----
def get_line_length(segments: Iterable[Segment]) -> int
⋮----
"""Get the line length (total length of all segments).

    Args:
        segments: Iterable of segments.

    Returns:
        Length of line in cells.
    """
_cell_len = cell_len
⋮----
class StripRenderable
⋮----
"""A renderable which renders a list of strips into lines."""
⋮----
def __init__(self, strips: list[Strip], width: int | None = None) -> None
⋮----
new_line = Segment.line()
⋮----
width = max(strip.cell_length for strip in self._strips)
⋮----
width = self._width
⋮----
@rich.repr.auto
class Strip
⋮----
"""Represents a 'strip' (horizontal line) of a Textual Widget.

    A Strip is like an immutable list of Segments. The immutability allows for effective caching.

    Args:
        segments: An iterable of segments.
        cell_length: The cell length if known, or None to calculate on demand.
    """
⋮----
__slots__ = [
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
@property
    def text(self) -> str
⋮----
"""Segment text."""
⋮----
@property
    def link_ids(self) -> set[str]
⋮----
"""A set of the link ids in this Strip."""
⋮----
@classmethod
@lru_cache(maxsize=1024)
    def blank(cls, cell_length: int, style: StyleType | None = None) -> Strip
⋮----
"""Create a blank strip.

        Args:
            cell_length: Desired cell length.
            style: Style of blank.

        Returns:
            New strip.
        """
segment_style = Style.parse(style) if isinstance(style, str) else style
⋮----
"""Convert lines (lists of segments) to a list of Strips.

        Args:
            lines: List of lines, where a line is a list of segments.
            cell_length: Cell length of lines (must be same) or None if not known.

        Returns:
            List of strips.
        """
⋮----
"""Align a list of strips on both axis.

        Args:
            strips: A list of strips, such as from a render.
            style: The Rich style of additional space.
            width: Width of container.
            height: Height of container.
            horizontal: Horizontal alignment method.
            vertical: Vertical alignment method.

        Returns:
            An iterable of strips, with additional padding.

        """
⋮----
line_lengths = [strip.cell_length for strip in strips]
shape_width = max(line_lengths)
shape_height = len(line_lengths)
⋮----
def blank_lines(count: int) -> Iterable[Strip]
⋮----
"""Create blank lines.

            Args:
                count: Desired number of blank lines.

            Returns:
                An iterable of blank lines.
            """
blank = cls([Segment(" " * width, style)], width)
⋮----
top_blank_lines = bottom_blank_lines = 0
⋮----
vertical_excess_space = max(0, height - shape_height)
⋮----
bottom_blank_lines = vertical_excess_space
⋮----
top_blank_lines = vertical_excess_space // 2
bottom_blank_lines = vertical_excess_space - top_blank_lines
⋮----
top_blank_lines = vertical_excess_space
⋮----
left_space = max(0, width - shape_width) // 2
⋮----
def index_to_cell_position(self, index: int) -> int
⋮----
"""Given a character index, return the cell position of that character.
        This is the sum of the cell lengths of all the characters *before* the character
        at `index`.

        Args:
            index: The index to convert.

        Returns:
            The cell position of the character at `index`.
        """
⋮----
@property
    def cell_length(self) -> int
⋮----
"""Get the number of cells required to render this object."""
# Done on demand and cached, as this is an O(n) operation
⋮----
@classmethod
    def join(cls, strips: Iterable[Strip | None]) -> Strip
⋮----
"""Join a number of strips into one.

        Args:
            strips: An iterable of Strips.

        Returns:
            A new combined strip.
        """
join_strips = [
segments = [segment for strip in join_strips for segment in strip._segments]
cell_length: int | None = None
⋮----
cell_length = None
⋮----
cell_length = sum([strip._cell_length or 0 for strip in join_strips])
joined_strip = cls(segments, cell_length)
⋮----
def __add__(self, other: Strip) -> Strip
⋮----
def __bool__(self) -> bool
⋮----
return not not self._segments  # faster than bool(...)
⋮----
def __iter__(self) -> Iterator[Segment]
⋮----
def __reversed__(self) -> Iterator[Segment]
⋮----
def __len__(self) -> int
⋮----
def __eq__(self, strip: object) -> bool
⋮----
def __getitem__(self, index: int | slice) -> Strip
⋮----
index = slice(index, index + 1)
⋮----
@property
    def cell_count(self) -> int
⋮----
"""Number of cells in the strip"""
⋮----
def extend_cell_length(self, cell_length: int, style: Style | None = None) -> Strip
⋮----
"""Extend the cell length if it is less than the given value.

        Args:
            cell_length: Required minimum cell length.
            style: Style for padding if the cell length is extended.

        Returns:
            A new Strip.
        """
⋮----
missing_space = cell_length - self.cell_length
segments = self._segments + [Segment(" " * missing_space, style)]
⋮----
def adjust_cell_length(self, cell_length: int, style: Style | None = None) -> Strip
⋮----
"""Adjust the cell length, possibly truncating or extending.

        Args:
            cell_length: New desired cell length.
            style: Style when extending, or `None`.

        Returns:
            A new strip with the supplied cell length.
        """
⋮----
cache_key = (cell_length, style)
cached_strip = self._line_length_cache.get(cache_key)
⋮----
new_line: list[Segment]
line = self._segments
current_cell_length = self.cell_length
⋮----
_Segment = Segment
⋮----
# Cell length is larger, so pad with spaces.
new_line = line + [
strip = Strip(new_line, cell_length)
⋮----
# Cell length is shorter so we need to truncate.
new_line = []
append = new_line.append
line_length = 0
⋮----
segment_length = segment.cell_length
⋮----
text = set_cell_size(text, cell_length - line_length)
⋮----
# Strip is already the required cell length, so return self.
strip = self
⋮----
def simplify(self) -> Strip
⋮----
"""Simplify the segments (join segments with same style).

        Returns:
            New strip.
        """
line = Strip(
⋮----
def discard_meta(self) -> Strip
⋮----
"""Remove all meta from segments.

        Returns:
            New strip.
        """
⋮----
def remove_meta_from_segment(segment: Segment) -> Segment
⋮----
"""Build a Segment with no meta.

            Args:
                segment: Segment.

            Returns:
                Segment, sans meta.
            """
⋮----
style = style.copy()
⋮----
def apply_filter(self, filter: LineFilter, background: Color) -> Strip
⋮----
"""Apply a filter to all segments in the strip.

        Args:
            filter: A line filter object.

        Returns:
            A new Strip.
        """
cached_strip = self._filter_cache.get((filter, background))
⋮----
cached_strip = Strip(
⋮----
def style_links(self, link_id: str, link_style: Style) -> Strip
⋮----
"""Apply a style to Segments with the given link_id.

        Args:
            link_id: A link id.
            link_style: Style to apply.

        Returns:
            New strip (or same Strip if no changes).
        """
⋮----
segments = [
⋮----
def crop_extend(self, start: int, end: int, style: Style | None) -> Strip
⋮----
"""Crop between two points, extending the length if required.

        Args:
            start: Start offset of crop.
            end: End offset of crop.
            style: Style of additional padding.

        Returns:
            New cropped Strip.
        """
cache_key = (start, end, style)
cached_result = self._crop_extend_cache.get(cache_key)
⋮----
strip = self.extend_cell_length(end, style).crop(start, end)
⋮----
def crop(self, start: int, end: int | None = None) -> Strip
⋮----
"""Crop a strip between two cell positions.

        Args:
            start: The start cell position (inclusive).
            end: The end cell position (exclusive).

        Returns:
            A new Strip.
        """
⋮----
start = max(0, start)
end = self.cell_length if end is None else min(self.cell_length, end)
⋮----
cache_key = (start, end)
cached = self._crop_cache.get(cache_key)
⋮----
pos = 0
output_segments: list[Segment] = []
add_segment = output_segments.append
iter_segments = iter(self._segments)
segment: Segment | None = None
⋮----
strip = Strip([], 0)
⋮----
end_pos = pos + _cell_len(segment.text)
⋮----
segment = segment.split_cells(start - pos)[1]
⋮----
pos = end_pos
⋮----
# The end crop is the end of the segments, so we can collect all remaining segments
⋮----
strip = Strip(output_segments, self.cell_length - start)
⋮----
pos = start
⋮----
segment = next(iter_segments, None)
strip = Strip(output_segments, end - start)
⋮----
def divide(self, cuts: Iterable[int]) -> Sequence[Strip]
⋮----
"""Divide the strip into multiple smaller strips by cutting at given (cell) indices.

        Args:
            cuts: An iterable of cell positions as ints.

        Returns:
            A new list of strips.
        """
⋮----
cell_length = self.cell_length
cuts = [cut for cut in cuts if cut <= cell_length]
cache_key = tuple(cuts)
⋮----
strips: list[Strip]
⋮----
strips = [self]
⋮----
strips = []
add_strip = strips.append
⋮----
pos = cut
⋮----
def apply_style(self, style: Style) -> Strip
⋮----
"""Apply a style to the Strip.

        Args:
            style: A Rich style.

        Returns:
            A new strip.
        """
cached = self._style_cache.get(style)
⋮----
styled_strip = Strip(
⋮----
def apply_meta(self, meta: dict[str, Any]) -> Strip
⋮----
"""Apply meta to all segments.

        Args:
            meta: A dict of meta information.

        Returns:
            A new strip.

        """
meta_style = Style.from_meta(meta)
⋮----
def _apply_link_style(self, link_style: Style) -> Strip
⋮----
segments = self._segments
⋮----
@classmethod
@lru_cache(maxsize=16384)
    def render_ansi(cls, style: Style, color_system: ColorSystem) -> str
⋮----
"""Render ANSI codes for a give style.

        Args:
            style: A Rich style.
            color_system: Color system enumeration.

        Returns:
            A string of ANSI escape sequences to render the style.
        """
sgr: list[str]
⋮----
_style_map = SGR_STYLES
sgr = [
⋮----
sgr = []
⋮----
ansi = style._ansi = ";".join(sgr)
⋮----
@classmethod
    def render_style(cls, style: Style, text: str, color_system: ColorSystem) -> str
⋮----
"""Render a Rich style and text.

        Args:
            style: Style to render.
            text: Content string.
            color_system: Color system enumeration.

        Returns:
            Text with ANSI escape sequences.
        """
⋮----
ansi = cls.render_ansi(style, color_system)
output = f"\x1b[{ansi}m{text}\x1b[0m" if ansi else text
⋮----
output = (
⋮----
def render(self, console: Console) -> str
⋮----
"""Render the strip into terminal sequences.

        Args:
            console: Console instance.

        Returns:
            Rendered sequences.
        """
⋮----
color_system = console._color_system or ColorSystem.TRUECOLOR
render = self.render_style
⋮----
def crop_pad(self, cell_length: int, left: int, right: int, style: Style) -> Strip
⋮----
"""Crop the strip to `cell_length`, and add optional padding.

        Args:
            cell_length: Cell length of strip prior to padding.
            left: Additional padding on the left.
            right: Additional padding on the right.
            style: Style of any padding.

        Returns:
            Cropped and padded strip.
        """
⋮----
strip = self.adjust_cell_length(cell_length, style)
⋮----
segments = strip._segments.copy()
⋮----
def text_align(self, width: int, align: AlignHorizontal) -> Strip
⋮----
left_space = max(0, width - self.cell_length) // 2
⋮----
def apply_offsets(self, x: int, y: int) -> Strip
⋮----
"""Apply offsets used in text selection.

        Args:
            x: Offset on X axis (column).
            y: Offset on Y axis (row).

        Returns:
            New strip.
        """
cache_key = (x, y)
⋮----
strip_segments: list[Segment] = []
⋮----
offset_style = Style.from_meta({"offset": (x, y)})
⋮----
strip = Strip(strip_segments, self._cell_length)
</file>

</files>
