This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/dom.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    dom.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/dom.py">
"""
The module contains `DOMNode`, the base class for any object within the Textual Document Object Model,
which includes all Widgets, Screens, and Apps.

"""
⋮----
_re_identifier = re.compile(IDENTIFIER)
⋮----
WalkMethod: TypeAlias = Literal["depth", "breadth"]
"""Valid walking methods for the [`DOMNode.walk_children` method][textual.dom.DOMNode.walk_children]."""
⋮----
ReactiveType = TypeVar("ReactiveType")
⋮----
QueryOneCacheKey: TypeAlias = "tuple[int, str, Type[Widget] | None]"
"""The key used to cache query_one results."""
⋮----
class BadIdentifier(Exception)
⋮----
"""Exception raised if you supply a `id` attribute or class name in the wrong format."""
⋮----
def check_identifiers(description: str, *names: str) -> None
⋮----
"""Validate identifier and raise an error if it fails.

    Args:
        description: Description of where identifier is used for error message.
        *names: Identifiers to check.
    """
match = _re_identifier.fullmatch
⋮----
class DOMError(Exception)
⋮----
"""Base exception class for errors relating to the DOM."""
⋮----
class NoScreen(DOMError)
⋮----
"""Raised when the node has no associated screen."""
⋮----
class _ClassesDescriptor
⋮----
"""A descriptor to manage the `classes` property."""
⋮----
"""A frozenset of the current classes on the widget."""
⋮----
def __set__(self, obj: DOMNode, classes: str | Iterable[str]) -> None
⋮----
"""Replaces classes entirely."""
⋮----
class_names = set(classes.split())
⋮----
class_names = set(classes)
⋮----
@rich.repr.auto
class DOMNode(MessagePump)
⋮----
"""The base class for object that can be in the Textual DOM (App and Widget)"""
⋮----
DEFAULT_CSS: ClassVar[str] = ""
"""Default TCSS."""
⋮----
DEFAULT_CLASSES: ClassVar[str] = ""
"""Default classes argument if not supplied."""
⋮----
COMPONENT_CLASSES: ClassVar[set[str]] = set()
"""Virtual DOM nodes, used to expose styles to line API widgets."""
⋮----
BINDING_GROUP_TITLE: str | None = None
"""Title of widget used where bindings are displayed (such as in the key panel)."""
⋮----
BINDINGS: ClassVar[list[BindingType]] = []
"""A list of key bindings."""
⋮----
# Indicates if the CSS should be automatically scoped
SCOPED_CSS: ClassVar[bool] = True
"""Should default css be limited to the widget type?"""
⋮----
HELP: ClassVar[str | None] = None
"""Optional help text shown in help panel (Markdown format)."""
⋮----
# True if this node inherits the CSS from the base class.
_inherit_css: ClassVar[bool] = True
⋮----
# True if this node inherits the component classes from the base class.
_inherit_component_classes: ClassVar[bool] = True
⋮----
# True to inherit bindings from base class
_inherit_bindings: ClassVar[bool] = True
⋮----
# List of names of base classes that inherit CSS
_css_type_names: ClassVar[frozenset[str]] = frozenset()
⋮----
# Name of the widget in CSS
_css_type_name: str = ""
⋮----
# Generated list of bindings
_merged_bindings: ClassVar[BindingsMap | None] = None
⋮----
_reactives: ClassVar[dict[str, Reactive]]
⋮----
_decorated_handlers: dict[type[Message], list[tuple[Callable, str | None]]]
⋮----
# Names of potential computed reactives
_computes: ClassVar[frozenset[str]]
⋮----
_PSEUDO_CLASSES: ClassVar[dict[str, Callable[[App[Any]], bool]]] = {}
"""Pseudo class checks."""
⋮----
_classes = classes.split() if classes else []
⋮----
# A mapping of class names to Styles set in COMPONENT_CLASSES
⋮----
"""The node has an ordered dependent pseudo-style (`:odd`, `:even`, `:first-of-type`, `:last-of-type`, `:first-child`, `:last-child`)"""
⋮----
"""The node has the pseudo class `odd` or `even`."""
⋮----
def _get_dom_base(self) -> DOMNode
⋮----
"""Get the DOM base node (typically self).

        All DOM queries on this node will use the return value as the root node.
        This method allows the App to query the default screen, and not the active screen.

        Returns:
            DOMNode.
        """
⋮----
"""Sets a reactive value *without* invoking validators or watchers.

        Example:
            ```python
            self.set_reactive(App.theme, "textual-light")
            ```

        Args:
            reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
            value: New value of reactive.

        Raises:
            AttributeError: If the first argument is not a reactive.
        """
name = reactive.name
⋮----
def mutate_reactive(self, reactive: Reactive[ReactiveType]) -> None
⋮----
"""Force an update to a mutable reactive.

        Example:
            ```python
            self.reactive_name_list.append("Jessica")
            self.mutate_reactive(MyClass.reactive_name_list)
            ```

        Textual will automatically detect when a reactive is set to a new value, but it is unable
        to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
        If you do wish to use a collection or other mutable object in a reactive, then you can call
        this method after your reactive is updated. This will ensure that all the reactive _superpowers_
        work.

        !!! note

            This method will cause watchers to be called, even if the value hasn't changed.

        Args:
            reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
        """
⋮----
internal_name = f"_reactive_{reactive.name}"
value = getattr(self, internal_name)
⋮----
"""Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

        Reactives may be given as positional arguments or keyword arguments.
        See the [guide on data binding](/guide/reactivity#data-binding).

        Example:
            ```python
            def compose(self) -> ComposeResult:
                yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
                yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
                yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
            ```

        Raises:
            ReactiveError: If the data wasn't bound.

        Returns:
            Self.
        """
_rich_traceback_omit = True
⋮----
parent = active_message_pump.get()
⋮----
bind_vars = {**{reactive.name: reactive for reactive in reactives}, **bind_vars}
⋮----
def _initialize_data_bind(self) -> None
⋮----
"""initialize a data binding.

        Args:
            compose_parent: The node doing the binding.
        """
⋮----
def make_setter(variable_name: str) -> Callable[[object], None]
⋮----
"""Make a setter for the given variable name.

                Args:
                    variable_name: Name of variable being set.

                Returns:
                    A callable which takes the value to set.
                """
⋮----
def setter(value: object) -> None
⋮----
"""Set bound data."""
⋮----
# Wrap the value in `_Mutated` so the setter knows to invoke watchers etc.
⋮----
setter = make_setter(variable_name)
⋮----
def compose_add_child(self, widget: Widget) -> None
⋮----
"""Add a node to children.

        This is used by the compose process when it adds children.
        There is no need to use it directly, but you may want to override it in a subclass
        if you want children to be attached to a different node.

        Args:
            widget: A Widget to add.
        """
⋮----
@property
    def children(self) -> Sequence["Widget"]
⋮----
"""A view on to the children.

        Returns:
            The node's children.
        """
⋮----
@property
    def displayed_children(self) -> Sequence[Widget]
⋮----
"""The displayed children (where `node.display==True`).

        Returns:
            A sequence of widgets.
        """
⋮----
@property
    def displayed_and_visible_children(self) -> Sequence[Widget]
⋮----
"""The displayed children (where `node.display==True` and `node.visible==True`).

        Returns:
            A sequence of widgets.
        """
⋮----
@property
    def is_empty(self) -> bool
⋮----
"""Are there no displayed children?"""
⋮----
"""Sort child widgets with an optional key function.

        If `key` is not provided then widgets will be sorted in the order they are constructed.

        Example:
            ```python
            # Sort widgets by name
            screen.sort_children(key=lambda widget: widget.name or "")
            ```

        Args:
            key: A callable which accepts a widget and returns something that can be sorted,
                or `None` to sort without a key function.
            reverse: Sort in descending order.
        """
⋮----
@property
    def auto_refresh(self) -> float | None
⋮----
"""Number of seconds between automatic refresh, or `None` for no automatic refresh."""
⋮----
@auto_refresh.setter
    def auto_refresh(self, interval: float | None) -> None
⋮----
@property
    def workers(self) -> WorkerManager
⋮----
"""The app's worker manager. Shortcut for `self.app.workers`."""
⋮----
def trap_focus(self, trap_focus: bool = True) -> None
⋮----
"""Trap the focus.

        When applied to a container, this will limit tab-to-focus to the children of that
        container (once focus is within that container).

        This can be useful for widgets that act like modal dialogs, where you want to restrict
        the user to the controls within the dialog.

        Args:
            trap_focus: `True` to trap focus. `False` to restore default behavior.
        """
⋮----
"""Run work in a worker.

        A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

        Args:
            work: A function, async function, or an awaitable object to run in a worker.
            name: A short string to identify the worker (in logs and debugging).
            group: A short string to identify a group of workers.
            description: A longer string to store longer information on the worker.
            exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
            start: Start the worker immediately.
            exclusive: Cancel all workers in the same group.
            thread: Mark the worker as a thread worker.

        Returns:
            New Worker instance.
        """
⋮----
# If we're running a worker from inside a secondary thread,
# do so in a thread-safe way.
⋮----
creator = partial(self.app.call_from_thread, self.workers._new_worker)
⋮----
creator = self.workers._new_worker
worker: Worker[ResultType] = creator(
⋮----
@property
    def is_modal(self) -> bool
⋮----
"""Is the node a modal?"""
⋮----
@property
    def is_on_screen(self) -> bool
⋮----
"""Check if the node was displayed in the last screen update."""
⋮----
def automatic_refresh(self) -> None
⋮----
"""Perform an automatic refresh.

        This method is called when you set the `auto_refresh` attribute.
        You could implement this method if you want to perform additional work
        during an automatic refresh.

        """
⋮----
reactives = cls._reactives = {}
⋮----
css_type_names: set[str] = set()
bases = cls._css_bases(cls)
⋮----
def get_component_styles(self, *names: str) -> RenderStyles
⋮----
"""Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

        Args:
            names: Names of the components.

        Raises:
            KeyError: If the component class doesn't exist.

        Returns:
            A Styles object.
        """
⋮----
styles = RenderStyles(self, Styles(), Styles())
⋮----
component_styles = self._component_styles[name]
⋮----
def _post_mount(self)
⋮----
"""Called after the object has been mounted."""
⋮----
def notify_style_update(self) -> None
⋮----
"""Called after styles are updated.

        Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.
        """
⋮----
@property
    def _node_bases(self) -> Sequence[Type[DOMNode]]
⋮----
"""The DOMNode bases classes (including self.__class__)"""
# Node bases are in reversed order so that the base class is lower priority
⋮----
@classmethod
@lru_cache(maxsize=None)
    def _css_bases(cls, base: Type[DOMNode]) -> Sequence[Type[DOMNode]]
⋮----
"""Get the DOMNode base classes, which inherit CSS.

        Args:
            base: A DOMNode class

        Returns:
            An iterable of DOMNode classes.
        """
classes: list[type[DOMNode]] = []
_class = base
⋮----
_class = _base
⋮----
@classmethod
    def _merge_bindings(cls) -> BindingsMap
⋮----
"""Merge bindings from base classes.

        Returns:
            Merged bindings.
        """
bindings: list[BindingsMap] = []
⋮----
keys: dict[str, list[Binding]] = {}
⋮----
new_bindings = BindingsMap.from_keys(keys)
⋮----
def _post_register(self, app: App) -> None
⋮----
"""Called when the widget is registered

        Args:
            app: Parent application.
        """
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
# Being a bit defensive here to guard against errors when calling repr before initialization
⋮----
def _get_default_css(self) -> list[tuple[CSSLocation, str, int, str]]
⋮----
"""Gets the CSS for this class and inherited from bases.

        Default CSS is inherited from base classes, unless `inherit_css` is set to
        `False` when subclassing.

        Returns:
            A list of tuples containing (LOCATION, SOURCE, SPECIFICITY, SCOPE) for this
                class and inherited from base classes.
        """
⋮----
css_stack: list[tuple[CSSLocation, str, int, str]] = []
⋮----
def get_location(base: Type[DOMNode]) -> CSSLocation
⋮----
"""Get the original location of this DEFAULT_CSS.

            Args:
                base: The class from which the default css was extracted.

            Returns:
                The filename where the class was defined (if possible) and the class
                    variable the CSS was extracted from.
            """
⋮----
css: str = base.__dict__.get("DEFAULT_CSS", "")
⋮----
scoped: bool = base.__dict__.get("SCOPED_CSS", True)
⋮----
@classmethod
@lru_cache(maxsize=None)
    def _get_component_classes(cls) -> frozenset[str]
⋮----
"""Gets the component classes for this class and inherited from bases.

        Component classes are inherited from base classes, unless
        `inherit_component_classes` is set to `False` when subclassing.

        Returns:
            A set with all the component classes available.
        """
⋮----
component_classes: set[str] = set()
⋮----
@property
    def parent(self) -> DOMNode | None
⋮----
"""The parent node.

        All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.
        """
⋮----
@property
    def screen(self) -> "Screen[object]"
⋮----
"""The screen containing this node.

        Returns:
            A screen object.

        Raises:
            NoScreen: If this node isn't mounted (and has no screen).
        """
# Get the node by looking up a chain of parents
# Note that self.screen may not be the same as self.app.screen
⋮----
node: MessagePump | None = self
⋮----
node = node._parent
⋮----
@property
    def id(self) -> str | None
⋮----
"""The ID of this node, or None if the node has no ID."""
⋮----
@id.setter
    def id(self, new_id: str) -> str
⋮----
"""Sets the ID (may only be done once).

        Args:
            new_id: ID for this node.

        Raises:
            ValueError: If the ID has already been set.
        """
⋮----
@property
    def name(self) -> str | None
⋮----
"""The name of the node."""
⋮----
@property
    def css_identifier(self) -> str
⋮----
"""A CSS selector that identifies this DOM node."""
tokens = [self.__class__.__name__]
⋮----
@property
    def css_identifier_styled(self) -> Text
⋮----
"""A syntax highlighted CSS identifier.

        Returns:
            A Rich Text object.
        """
tokens = Text.styled(self.__class__.__name__)
⋮----
classes = _ClassesDescriptor()
"""CSS class names for this node."""
⋮----
@property
    def pseudo_classes(self) -> frozenset[str]
⋮----
"""A (frozen) set of all pseudo classes."""
⋮----
@property
    def css_path_nodes(self) -> list[DOMNode]
⋮----
"""A list of nodes from the App to this node, forming a "path".

        Returns:
            A list of nodes, where the first item is the App, and the last is this node.
        """
result: list[DOMNode] = [self]
append = result.append
⋮----
node: DOMNode = self
⋮----
@property
    def _selector_names(self) -> set[str]
⋮----
"""Get a set of selectors applicable to this widget.

        Returns:
            Set of selector names.
        """
selectors: set[str] = {
⋮----
@property
    def display(self) -> bool
⋮----
"""Should the DOM node be displayed?

        May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

        Example:
            ```python
            my_widget.display = False  # Hide my_widget
            ```
        """
⋮----
@display.setter
    def display(self, new_val: bool | str) -> None
⋮----
"""
        Args:
            new_val: Shortcut to set the ``display`` CSS property.
                ``False`` will set ``display: none``. ``True`` will set ``display: block``.
                A ``False`` value will prevent the DOMNode from consuming space in the layout.
        """
# TODO: This will forget what the original "display" value was, so if a user
#  toggles to False then True, we'll reset to the default "block", rather than
#  what the user initially specified.
⋮----
@property
    def visible(self) -> bool
⋮----
"""Is this widget visible in the DOM?

        If a widget hasn't had its visibility set explicitly, then it inherits it from its
        DOM ancestors.

        This may be set explicitly to override inherited values.
        The valid values include the valid values for the `visibility` rule and the booleans
        `True` or `False`, to set the widget to be visible or invisible, respectively.

        When a node is invisible, Textual will reserve space for it, but won't display anything.
        """
own_value = self.styles.get_rule("visibility")
⋮----
@visible.setter
    def visible(self, new_value: bool | str) -> None
⋮----
@property
    def tree(self) -> Tree
⋮----
"""A Rich tree to display the DOM.

        Log this to visualize your app in the textual console.

        Example:
            ```python
            self.log(self.tree)
            ```

        Returns:
            A Tree renderable.
        """
⋮----
def render_info(node: DOMNode) -> Pretty
⋮----
"""Render a node for the tree."""
⋮----
tree = Tree(render_info(self))
⋮----
def add_children(tree, node)
⋮----
info = render_info(child)
branch = tree.add(info)
⋮----
@property
    def css_tree(self) -> Tree
⋮----
"""A Rich tree to display the DOM, annotated with the node's CSS.

        Log this to visualize your app in the textual console.

        Example:
            ```python
            self.log(self.css_tree)
            ```

        Returns:
            A Tree renderable.
        """
⋮----
def render_info(node: DOMNode) -> Columns
⋮----
info = Columns(
⋮----
info = Columns([Pretty(node)])
⋮----
highlighter = ReprHighlighter()
⋮----
def add_children(tree: Tree, node: DOMNode) -> None
⋮----
"""Add children to the tree."""
⋮----
info: RenderableType = render_info(child)
css = child.styles.css
⋮----
info = Group(
⋮----
@property
    def text_style(self) -> Style
⋮----
"""Get the text style object.

        A widget's style is influenced by its parent. for instance if a parent is bold, then
        the child will also be bold.

        Returns:
            A Rich Style.
        """
⋮----
@property
    def selection_style(self) -> Style
⋮----
"""The style of selected text."""
style = self.screen.get_component_rich_style(
⋮----
@property
    def rich_style(self) -> Style
⋮----
"""Get a Rich Style object for this DOMNode.

        Returns:
            A Rich style.
        """
background = Color(0, 0, 0, 0)
color = Color(255, 255, 255, 0)
⋮----
style = Style()
opacity = 1.0
⋮----
styles = node.styles
has_rule = styles.has_rule
⋮----
text_background = background + styles.background.tint(
⋮----
text_background = background
⋮----
color = styles.color
⋮----
color = text_background.get_contrast_text(color.a)
⋮----
def check_consume_key(self, key: str, character: str | None) -> bool
⋮----
"""Check if the widget may consume the given key.

        This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
        stop propagation (such as Input and TextArea).

        Implementing this method will hide key bindings from the footer and key panel that would
        be *consumed* by the focused widget.

        Args:
            key: A key identifier.
            character: A character associated with the key, or `None` if there isn't one.

        Returns:
            `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.
        """
⋮----
"""Get a Visual Style object for titles.

        Args:
            background: The background color.

        Returns:
            A Rich style.
        """
⋮----
styles = self.styles
⋮----
color = background.get_contrast_text(styles.border_title_color.a)
⋮----
color = styles.border_title_color
⋮----
"""Get a Rich Style object for subtitles.

        Args:
            background: The background color.

        Returns:
            A Rich style.
        """
⋮----
color = background.get_contrast_text(styles.border_subtitle_color.a)
⋮----
color = styles.border_subtitle_color
⋮----
@property
    def background_colors(self) -> tuple[Color, Color]
⋮----
"""Background colors adjusted for opacity.

        Returns:
            `(<background color>, <color>)`
        """
base_background = background = Color(0, 0, 0, 0)
⋮----
base_background = background
⋮----
@property
    def colors(self) -> tuple[Color, Color, Color, Color]
⋮----
"""The widget's background and foreground colors, and the parent's background and foreground colors.

        Returns:
            `(<parent background>, <parent color>, <background>, <color>)`
        """
base_background = background = WHITE
base_color = color = BLACK
⋮----
base_color = color
⋮----
color = background.get_contrast_text(color.a)
⋮----
@property
    def ancestors_with_self(self) -> list[DOMNode]
⋮----
"""A list of ancestor nodes found by tracing a path all the way back to App.

        Note:
            This is inclusive of ``self``.

        Returns:
            A list of nodes.
        """
nodes: list[MessagePump | None] = [self]
add_node = nodes.append
⋮----
@property
    def ancestors(self) -> list[DOMNode]
⋮----
"""A list of ancestor nodes found by tracing a path all the way back to App.

        Returns:
            A list of nodes.
        """
nodes: list[MessagePump | None] = []
⋮----
"""Watches for modifications to reactive attributes on another object.

        Example:
            ```python
            def on_theme_change(old_value:str, new_value:str) -> None:
                # Called when app.theme changes.
                print(f"App.theme went from {old_value} to {new_value}")

            self.watch(self.app, "theme", self.on_theme_change, init=False)
            ```

        Args:
            obj: Object containing attribute to watch.
            attribute_name: Attribute to watch.
            callback: A callback to run when attribute changes.
            init: Check watchers on first call.
        """
⋮----
def get_pseudo_classes(self) -> set[str]
⋮----
"""Pseudo classes for a widget.

        Returns:
            Names of the pseudo classes.
        """
⋮----
def reset_styles(self) -> None
⋮----
"""Reset styles back to their initial state."""
⋮----
def _add_child(self, node: Widget) -> None
⋮----
"""Add a new child node.

        !!! note
            For tests only.

        Args:
            node: A DOM node.
        """
⋮----
def _add_children(self, *nodes: Widget) -> None
⋮----
"""Add multiple children to this node.

        !!! note
            For tests only.

        Args:
            *nodes: Positional args should be new DOM nodes.
        """
_append = self._nodes._append
⋮----
WalkType = TypeVar("WalkType", bound="DOMNode")
⋮----
"""Walk the subtree rooted at this node, and return every descendant encountered in a list.

        Args:
            filter_type: Filter only this type, or None for no filter.
            with_self: Also yield self in addition to descendants.
            method: One of "depth" or "breadth".
            reverse: Reverse the order (bottom up).

        Returns:
            A list of nodes.
        """
check_type = filter_type or DOMNode
⋮----
node_generator = (
⋮----
# We want a snapshot of the DOM at this point So that it doesn't
# change mid-walk
nodes = list(node_generator)
⋮----
@overload
        def query(self, selector: str | None = None) -> DOMQuery[Widget]: ...
⋮----
@overload
        def query(self, selector: type[QueryType]) -> DOMQuery[QueryType]: ...
⋮----
"""Query the DOM for children that match a selector or widget type.

        Args:
            selector: A CSS selector, widget type, or `None` for all nodes.

        Returns:
            A query object.
        """
⋮----
node = self._get_dom_base()
⋮----
@overload
        def query_children(self, selector: str | None = None) -> DOMQuery[Widget]: ...
⋮----
@overload
        def query_children(self, selector: type[QueryType]) -> DOMQuery[QueryType]: ...
⋮----
"""Query the DOM for the immediate children that match a selector or widget type.

        Note that this will not return child widgets more than a single level deep.
        If you want to a query to potentially match all children in the widget tree,
        see [query][textual.dom.DOMNode.query].

        Args:
            selector: A CSS selector, widget type, or `None` for all nodes.

        Returns:
            A query object.
        """
⋮----
@overload
        def query_one(self, selector: str) -> Widget: ...
⋮----
@overload
        def query_one(self, selector: type[QueryType]) -> QueryType: ...
⋮----
"""Get a widget from this widget's children that matches a selector or widget type.

        Args:
            selector: A selector or widget type.
            expect_type: Require the object be of the supplied type, or None for any type.

        Raises:
            WrongType: If the wrong type was found.
            NoMatches: If no node matches the query.

        Returns:
            A widget matching the selector.
        """
⋮----
base_node = self._get_dom_base()
⋮----
query_selector = selector
⋮----
query_selector = selector.__name__
⋮----
cache_key = (base_node._nodes._updates, query_selector, expect_type)
cached_result = base_node._query_one_cache.get(cache_key)
⋮----
selector_set = parse_selectors(query_selector)
⋮----
cache_key = None
⋮----
@overload
        def query_one_optional(self, selector: str) -> Widget | None: ...
⋮----
@overload
        def query_one_optional(self, selector: type[QueryType]) -> QueryType | None: ...
⋮----
"""Get a widget from this widget's children that matches a selector or widget type,
        or `None` if there is no match.

        Args:
            selector: A selector or widget type.
            expect_type: Require the object be of the supplied type, or None for any type.

        Raises:
            WrongType: If the wrong type was found.

        Returns:
            A widget matching the selector, or `None`.
        """
⋮----
widget = self.query_one(selector, expect_type)
⋮----
@overload
        def query_exactly_one(self, selector: str) -> Widget: ...
⋮----
@overload
        def query_exactly_one(self, selector: type[QueryType]) -> QueryType: ...
⋮----
"""Get a widget from this widget's children that matches a selector or widget type.

        !!! Note
            This method is similar to [query_one][textual.dom.DOMNode.query_one].
            The only difference is that it will raise `TooManyMatches` if there is more than a single match.

        Args:
            selector: A selector or widget type.
            expect_type: Require the object be of the supplied type, or None for any type.

        Raises:
            WrongType: If the wrong type was found.
            NoMatches: If no node matches the query.
            TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

        Returns:
            A widget matching the selector.
        """
⋮----
children = walk_breadth_first(base_node, with_root=False)
iter_children = iter(children)
⋮----
@overload
        def query_ancestor(self, selector: str) -> DOMNode: ...
⋮----
@overload
        def query_ancestor(self, selector: type[QueryType]) -> QueryType: ...
⋮----
"""Get an ancestor which matches a query.

        Args:
            selector: A TCSS selector.
            expect_type: Expected type, or `None` for any DOMNode.

        Raises:
            InvalidQueryFormat: If the selector is invalid.
            NoMatches: If there are no matching ancestors.

        Returns:
            A DOMNode or subclass if `expect_type` is provided.
        """
⋮----
def set_styles(self, css: str | None = None, **update_styles: Any) -> Self
⋮----
"""Set custom styles on this object.

        Args:
            css: Styles in CSS format.
            update_styles: Keyword arguments map style names onto style values.

        Returns:
            Self.
        """
⋮----
new_styles = parse_declarations(css, read_from=("set_styles", ""))
⋮----
def has_class(self, *class_names: str) -> bool
⋮----
"""Check if the Node has all the given class names.

        Args:
            *class_names: CSS class names to check.

        Returns:
            ``True`` if the node has all the given class names, otherwise ``False``.
        """
⋮----
def set_class(self, add: bool, *class_names: str, update: bool = True) -> Self
⋮----
"""Add or remove class(es) based on a condition.

        This can condense the four lines required to implement the equivalent branch into a single line.

        Example:
            ```python
            #if foo:
            #    self.add_class("-foo")
            #else:
            #    self.remove_class("-foo")
            self.set_class(foo, "-foo")
            ```

        Args:
            add: Add the classes if True, otherwise remove them.
            update: Also update styles.

        Returns:
            Self.
        """
⋮----
def set_classes(self, classes: str | Iterable[str]) -> Self
⋮----
"""Replace all classes.

        Args:
            classes: A string containing space separated classes, or an
                iterable of class names.

        Returns:
            Self.
        """
⋮----
def update_node_styles(self, animate: bool = True) -> None
⋮----
"""Request an update of this node's styles.

        Called by Textual whenever CSS classes / pseudo classes change.
        """
⋮----
def add_class(self, *class_names: str, update: bool = True) -> Self
⋮----
"""Add class names to this Node.

        Args:
            *class_names: CSS class names to add.
            update: Also update styles.

        Returns:
            Self.
        """
⋮----
old_classes = self._classes.copy()
⋮----
def remove_class(self, *class_names: str, update: bool = True) -> Self
⋮----
"""Remove class names from this Node.

        Args:
            *class_names: CSS class names to remove.
            update: Also update styles.

        Returns:
            Self.
        """
⋮----
def toggle_class(self, *class_names: str) -> Self
⋮----
"""Toggle class names on this Node.

        Args:
            *class_names: CSS class names to toggle.

        Returns:
            Self.
        """
⋮----
def has_pseudo_class(self, class_name: str) -> bool
⋮----
"""Check the node has the given pseudo class.

        Args:
            class_name: The pseudo class to check for.

        Returns:
            `True` if the DOM node has the pseudo class, `False` if not.
        """
⋮----
def has_pseudo_classes(self, class_names: set[str]) -> bool
⋮----
"""Check the node has all the given pseudo classes.

        Args:
            class_names: Set of class names to check for.

        Returns:
            `True` if all pseudo class names are present.
        """
PSEUDO_CLASSES = self._PSEUDO_CLASSES
⋮----
@property
    def _pseudo_classes_cache_key(self) -> tuple[int, ...]
⋮----
"""A cache key used when updating a number of nodes from the stylesheet."""
⋮----
def check_action(self, action: str, parameters: tuple[object, ...]) -> bool | None
⋮----
"""Check whether an action is enabled.

        Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

        Args:
            action: The name of an action.
            parameters: A tuple of any action parameters.

        Returns:
            `True` if the action is enabled+visible,
                `False` if the action is disabled+hidden,
                `None` if the action is disabled+visible (grayed out in footer)
        """
⋮----
def refresh_bindings(self) -> None
⋮----
"""Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
        the display of key bindings.

        See [actions](/guide/actions#dynamic-actions) for how to use this method.

        """
⋮----
async def action_toggle(self, attribute_name: str) -> None
⋮----
"""Toggle an attribute on the node.

        Assumes the attribute is a bool.

        Args:
            attribute_name: Name of the attribute.
        """
value = getattr(self, attribute_name)
</file>

</files>
