This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/pilot.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    pilot.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/pilot.py">
"""

This module contains the `Pilot` class used by [App.run_test][textual.app.App.run_test] to programmatically operate an app.

See the guide on how to [test Textual apps](/guide/testing).

"""
⋮----
"""Get the arguments to pass into mouse messages for the click and hover methods."""
⋮----
message_arguments = {
⋮----
class OutOfBounds(Exception)
⋮----
"""Raised when the pilot mouse target is outside of the (visible) screen."""
⋮----
class WaitForScreenTimeout(Exception)
⋮----
"""Exception raised if messages aren't being processed quickly enough.

    If this occurs, the most likely explanation is some kind of deadlock in the app code.
    """
⋮----
@rich.repr.auto(angular=True)
class Pilot(Generic[ReturnType])
⋮----
"""Pilot object to drive an app."""
⋮----
def __init__(self, app: App[ReturnType]) -> None
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
@property
    def app(self) -> App[ReturnType]
⋮----
"""App: A reference to the application."""
⋮----
async def press(self, *keys: str) -> None
⋮----
"""Simulate key-presses.

        Args:
            *keys: Keys to press.
        """
⋮----
async def resize_terminal(self, width: int, height: int) -> None
⋮----
"""Resize the terminal to the given dimensions.

        Args:
            width: The new width of the terminal.
            height: The new height of the terminal.
        """
size = Size(width, height)
# If we're running with the headless driver, update the inherent app size.
⋮----
"""Simulate a [`MouseDown`][textual.events.MouseDown] event at a specified position.

        The final position for the event is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        Args:
            widget: A widget or selector used as an origin
                for the event offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to target a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the event may not land on the widget you specified.
            offset: The offset for the event. The offset is relative to the selector / widget
                provided or to the screen, if no selector is provided.
            shift: Simulate the event with the shift key held down.
            meta: Simulate the event with the meta key held down.
            control: Simulate the event with the control key held down.

        Raises:
            OutOfBounds: If the position for the event is outside of the (visible) screen.

        Returns:
            True if no selector was specified or if the event landed on the selected
                widget, False otherwise.
        """
⋮----
"""Simulate a [`MouseUp`][textual.events.MouseUp] event at a specified position.

        The final position for the event is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        Args:
            widget: A widget or selector used as an origin
                for the event offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to target a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the event may not land on the widget you specified.
            offset: The offset for the event. The offset is relative to the widget / selector
                provided or to the screen, if no selector is provided.
            shift: Simulate the event with the shift key held down.
            meta: Simulate the event with the meta key held down.
            control: Simulate the event with the control key held down.

        Raises:
            OutOfBounds: If the position for the event is outside of the (visible) screen.

        Returns:
            True if no selector was specified or if the event landed on the selected
                widget, False otherwise.
        """
⋮----
"""Simulate clicking with the mouse at a specified position.

        The final position to be clicked is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        Implementation note: This method bypasses the normal event processing in `App.on_event`.

        Example:
            The code below runs an app and clicks its only button right in the middle:
            ```py
            async with SingleButtonApp().run_test() as pilot:
                await pilot.click(Button, offset=(8, 1))
            ```

        Args:
            widget: A widget or selector used as an origin
                for the click offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to click on a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the click may not land on the widget you specified.
            offset: The offset to click. The offset is relative to the widget / selector provided
                or to the screen, if no selector is provided.
            shift: Click with the shift key held down.
            meta: Click with the meta key held down.
            control: Click with the control key held down.
            times: The number of times to click. 2 will double-click, 3 will triple-click, etc.

        Raises:
            OutOfBounds: If the position to be clicked is outside of the (visible) screen.

        Returns:
            `True` if no selector was specified or if the selected widget was under the mouse
                when the click was initiated. `False` is the selected widget was not under the pointer.
        """
⋮----
"""Simulate double clicking with the mouse at a specified position.

        Alias for `pilot.click(..., times=2)`.

        The final position to be clicked is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        Implementation note: This method bypasses the normal event processing in `App.on_event`.

        Example:
            The code below runs an app and double-clicks its only button right in the middle:
            ```py
            async with SingleButtonApp().run_test() as pilot:
                await pilot.double_click(Button, offset=(8, 1))
            ```

        Args:
            widget: A widget or selector used as an origin
                for the click offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to click on a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the click may not land on the widget you specified.
            offset: The offset to click. The offset is relative to the widget / selector provided
                or to the screen, if no selector is provided.
            shift: Click with the shift key held down.
            meta: Click with the meta key held down.
            control: Click with the control key held down.

        Raises:
            OutOfBounds: If the position to be clicked is outside of the (visible) screen.

        Returns:
            `True` if no selector was specified or if the selected widget was under the mouse
                when the click was initiated. `False` is the selected widget was not under the pointer.
        """
⋮----
"""Simulate triple clicking with the mouse at a specified position.

        Alias for `pilot.click(..., times=3)`.

        The final position to be clicked is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        Implementation note: This method bypasses the normal event processing in `App.on_event`.

        Example:
            The code below runs an app and triple-clicks its only button right in the middle:
            ```py
            async with SingleButtonApp().run_test() as pilot:
                await pilot.triple_click(Button, offset=(8, 1))
            ```

        Args:
            widget: A widget or selector used as an origin
                for the click offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to click on a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the click may not land on the widget you specified.
            offset: The offset to click. The offset is relative to the widget / selector provided
                or to the screen, if no selector is provided.
            shift: Click with the shift key held down.
            meta: Click with the meta key held down.
            control: Click with the control key held down.

        Raises:
            OutOfBounds: If the position to be clicked is outside of the (visible) screen.

        Returns:
            `True` if no selector was specified or if the selected widget was under the mouse
                when the click was initiated. `False` is the selected widget was not under the pointer.
        """
⋮----
"""Simulate hovering with the mouse cursor at a specified position.

        The final position to be hovered is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        Args:
            widget: A widget or selector used as an origin
                for the hover offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to hover a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the hover may not land on the widget you specified.
            offset: The offset to hover. The offset is relative to the widget / selector provided
                or to the screen, if no selector is provided.

        Raises:
            OutOfBounds: If the position to be hovered is outside of the (visible) screen.

        Returns:
            True if no selector was specified or if the hover landed on the selected
                widget, False otherwise.
        """
# This is usually what the user wants because it gives time for the mouse to
# "settle" before moving it to the new hover position.
⋮----
"""Simulate a series of mouse events to be fired at a given position.

        The final position for the events is computed based on the selector provided and
        the offset specified and it must be within the visible area of the screen.

        This function abstracts away the commonalities of the other mouse event-related
        functions that the pilot exposes.

        Args:
            widget: A widget or selector used as the origin
                for the event's offset. If this is not specified, the offset is interpreted
                relative to the screen. You can use this parameter to try to target a
                specific widget. However, if the widget is currently hidden or obscured by
                another widget, the events may not land on the widget you specified.
            offset: The offset for the events. The offset is relative to the widget / selector
                provided or to the screen, if no selector is provided.
            shift: Simulate the events with the shift key held down.
            meta: Simulate the events with the meta key held down.
            control: Simulate the events with the control key held down.
            times: The number of times to click. 2 will double-click, 3 will triple-click, etc.
        Raises:
            OutOfBounds: If the position for the events is outside of the (visible) screen.

        Returns:
            True if no selector was specified or if the *final* event landed on the
                selected widget, False otherwise.
        """
app = self.app
screen = app.screen
target_widget: Widget
⋮----
target_widget = screen
⋮----
target_widget = widget
⋮----
target_widget = screen.query_one(widget)
⋮----
message_arguments = _get_mouse_message_arguments(
⋮----
offset = Offset(message_arguments["x"], message_arguments["y"])
⋮----
widget_at = None
⋮----
# Get the widget under the mouse before the event because the app might
# react to the event and move things around. We override on each iteration
# because we assume the final event in `events` is the actual event we care
# about and that all the preceding events are just setup.
# E.g., the click event is preceded by MouseDown/MouseUp to emulate how
# the driver works and emits a click event.
kwargs = message_arguments
⋮----
kwargs = {**kwargs, "chain": chain}
⋮----
event = mouse_event_cls(**kwargs)
# Bypass event processing in App.on_event. Because App.on_event
# is responsible for updating App.mouse_position, and because
# that's useful to other things (tooltip handling, for example),
# we patch the offset in there as well.
⋮----
async def _wait_for_screen(self, timeout: float = 30.0) -> bool
⋮----
"""Wait for the current screen and its children to have processed all pending events.

        Args:
            timeout: A timeout in seconds to wait.

        Returns:
            `True` if all events were processed. `False` if an exception occurred,
            meaning that not all events could be processed.

        Raises:
            WaitForScreenTimeout: If the screen and its children didn't finish processing within the timeout.
        """
⋮----
screen = self.app.screen
⋮----
children = [self.app, *screen.walk_children(with_self=True)]
count = 0
count_zero_event = asyncio.Event()
⋮----
def decrement_counter() -> None
⋮----
"""Decrement internal counter, and set an event if it reaches zero."""
⋮----
# When count is zero, all messages queued at the start of the method have been processed
⋮----
# Increase the count for every successful call_later
⋮----
# Wait for the count to return to zero, or a timeout, or an exception
wait_for = [
⋮----
timed_out = len(wait_for) == len(pending)
⋮----
# We've either timed out, encountered an exception, or we've finished
# decrementing all the counters (all events processed in children).
⋮----
async def pause(self, delay: float | None = None) -> None
⋮----
"""Insert a pause.

        Args:
            delay: Seconds to pause, or None to wait for cpu idle.
        """
# These sleep zeros, are to force asyncio to give up a time-slice.
⋮----
async def wait_for_animation(self) -> None
⋮----
"""Wait for any current animation to complete."""
⋮----
async def wait_for_scheduled_animations(self) -> None
⋮----
"""Wait for any current and scheduled animations to complete."""
⋮----
async def exit(self, result: ReturnType) -> None
⋮----
"""Exit the app with the given result.

        Args:
            result: The app result returned by `run` or `run_async`.
        """
</file>

</files>
