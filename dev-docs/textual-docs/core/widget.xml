This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/widget.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    widget.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/widget.py">
"""
This module contains the `Widget` class, the base class for all widgets.

"""
⋮----
_JUSTIFY_MAP: dict[str, JustifyMethod] = {
⋮----
_MOUSE_EVENTS_DISALLOW_IF_DISABLED = (events.MouseEvent, events.Enter, events.Leave)
_MOUSE_EVENTS_ALLOW_IF_DISABLED = (
⋮----
@rich.repr.auto
class AwaitMount
⋮----
"""An *optional* awaitable returned by [mount][textual.widget.Widget.mount] and [mount_all][textual.widget.Widget.mount_all].

    Example:
        ```python
        await self.mount(Static("foo"))
        ```
    """
⋮----
def __init__(self, parent: Widget, widgets: Sequence[Widget]) -> None
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
async def __call__(self) -> None
⋮----
"""Allows awaiting via a call operation."""
⋮----
def __await__(self) -> Generator[None, None, None]
⋮----
async def await_mount() -> None
⋮----
aws = [
⋮----
class _Styled
⋮----
"""Apply a style to a renderable.

    Args:
        renderable: Any renderable.
        style: A style to apply across the entire renderable.
    """
⋮----
style = console.get_style(self.style)
result_segments = console.render(self.renderable, options)
⋮----
_Segment = Segment
⋮----
apply = style.__add__
result_segments = (
link_style = self.link_style
⋮----
class _RenderCache(NamedTuple)
⋮----
"""Stores results of a previous render."""
⋮----
size: Size
"""The size of the render."""
lines: list[Strip]
"""Contents of the render."""
⋮----
class WidgetError(Exception)
⋮----
"""Base widget error."""
⋮----
class MountError(WidgetError)
⋮----
"""Error raised when there was a problem with the mount request."""
⋮----
class PseudoClasses(NamedTuple)
⋮----
"""Used for render/render_line based widgets that use caching. This structure can be used as a
    cache-key."""
⋮----
enabled: bool
"""Is 'enabled' applied?"""
focus: bool
"""Is 'focus' applied?"""
hover: bool
"""Is 'hover' applied?"""
⋮----
class _BorderTitle
⋮----
"""Descriptor to set border titles."""
⋮----
def __set_name__(self, owner: Widget, name: str) -> None
⋮----
# The private name where we store the real data.
⋮----
def __set__(self, obj: Widget, title: Text | ContentType | None) -> None
⋮----
"""Setting a title accepts a str, Text, or None."""
⋮----
title = Content.from_rich_text(title)
⋮----
# We store the title as Text
new_title = obj.render_str(title).expand_tabs(4)
new_title = new_title.split()[0]
⋮----
def __get__(self, obj: Widget, objtype: type[Widget] | None = None) -> str | None
⋮----
"""Getting a title will return None or a str as console markup."""
title: Text | None = getattr(obj, self._internal_name, None)
⋮----
# If we have a title, convert from Text to console markup
⋮----
class BadWidgetName(Exception)
⋮----
"""Raised when widget class names do not satisfy the required restrictions."""
⋮----
@rich.repr.auto
class Widget(DOMNode)
⋮----
"""
    A Widget is the base class for Textual widgets.

    See also [static][textual.widgets._static.Static] for starting point for your own widgets.
    """
⋮----
DEFAULT_CSS = """
COMPONENT_CLASSES: ClassVar[set[str]] = set()
"""A set of component classes."""
⋮----
BORDER_TITLE: ClassVar[str] = ""
"""Initial value for border_title attribute."""
⋮----
BORDER_SUBTITLE: ClassVar[str] = ""
"""Initial value for border_subtitle attribute."""
⋮----
ALLOW_MAXIMIZE: ClassVar[bool | None] = None
"""Defines default logic to allow the widget to be maximized.
    
    - `None` Use default behavior (Focusable widgets may be maximized)
    - `False` Do not allow widget to be maximized
    - `True` Allow widget to be maximized
    
    """
⋮----
ALLOW_SELECT: ClassVar[bool] = True
"""Does this widget support automatic text selection? May be further refined with [Widget.allow_select][textual.widget.Widget.allow_select]."""
⋮----
FOCUS_ON_CLICK: ClassVar[bool] = True
"""Should focusable widgets be automatically focused on click? Default return value of [Widget.focus_on_click][textual.widget.Widget.focus_on_click]."""
⋮----
BLANK: ClassVar[bool] = False
"""Is this widget blank (no border, no content)? Enable for very large scrolling containers."""
⋮----
can_focus: bool = False
"""Widget may receive focus."""
can_focus_children: bool = True
"""Widget's children may receive focus."""
expand: Reactive[bool] = Reactive(False)
"""Rich renderable may expand beyond optimal size."""
shrink: Reactive[bool] = Reactive(True)
"""Rich renderable may shrink below optimal size."""
auto_links: Reactive[bool] = Reactive(True)
"""Widget will highlight links automatically."""
disabled: Reactive[bool] = Reactive(False)
"""Is the widget disabled? Disabled widgets can not be interacted with, and are typically styled to look dimmer."""
⋮----
hover_style: Reactive[Style] = Reactive(Style, repaint=False)
"""The current hover style (style under the mouse cursor). Read only."""
highlight_link_id: Reactive[str] = Reactive("")
"""The currently highlighted link id. Read only."""
loading: Reactive[bool] = Reactive(False)
"""If set to `True` this widget will temporarily be replaced with a loading indicator."""
⋮----
virtual_size = Reactive(Size(0, 0), layout=True)
"""The virtual (scrollable) [size][textual.geometry.Size] of the widget."""
⋮----
has_focus: Reactive[bool] = Reactive(False, repaint=False)
"""Does this widget have focus? Read only."""
⋮----
mouse_hover: Reactive[bool] = Reactive(False, repaint=False)
"""Is the mouse over this widget? Read only."""
⋮----
scroll_x: Reactive[float] = Reactive(0.0, repaint=False, layout=False)
"""The scroll position on the X axis."""
⋮----
scroll_y: Reactive[float] = Reactive(0.0, repaint=False, layout=False)
"""The scroll position on the Y axis."""
⋮----
scroll_target_x = Reactive(0.0, repaint=False)
"""Scroll target destination, X coord."""
⋮----
scroll_target_y = Reactive(0.0, repaint=False)
"""Scroll target destination, Y coord."""
⋮----
show_vertical_scrollbar: Reactive[bool] = Reactive(False, layout=True)
"""Show a vertical scrollbar?"""
⋮----
show_horizontal_scrollbar: Reactive[bool] = Reactive(False, layout=True)
"""Show a horizontal scrollbar?"""
⋮----
border_title = _BorderTitle()  # type: ignore
"""A title to show in the top border (if there is one)."""
border_subtitle = _BorderTitle()
"""A title to show in the bottom border (if there is one)."""
⋮----
# Default sort order, incremented by constructor
_sort_order: ClassVar[int] = 0
⋮----
_PSEUDO_CLASSES: ClassVar[dict[str, Callable[[Widget], bool]]] = {
⋮----
}  # type: ignore[assignment]
⋮----
"""Initialize a Widget.

        Args:
            *children: Child widgets.
            name: The name of the widget.
            id: The ID of the widget in the DOM.
            classes: The CSS classes for the widget.
            disabled: Whether the widget is disabled or not.
            markup: Enable content markup?
        """
⋮----
_null_size = NULL_SIZE
⋮----
"""A dict that is refreshed when the widget is resized / refreshed."""
⋮----
# Regions which need to be updated (in Widget)
⋮----
# Regions which need to be transferred from cache to screen
⋮----
# Cache the auto content dimensions
⋮----
"""The tooltip content."""
⋮----
"""Force an absolute offset for the widget (used by tooltips)."""
⋮----
"""Used to stabilize scrollbars."""
⋮----
"""`asyncio` lock to be used to synchronize the state of the widget.

        Two different tasks might call methods on a widget at the same time, which
        might result in a race condition.
        This can be fixed by adding `async with widget.lock:` around the method calls.
        """
⋮----
"""Has this widget been anchored?"""
⋮----
"""Has the anchor been released?"""
⋮----
"""Flag to enable animation when scrolling anchored widgets."""
⋮----
"""Widget to render over this widget (used by loading indicator)."""
⋮----
"""Used to cache :first-of-type pseudoclass state."""
⋮----
"""Used to cache :last-of-type pseudoclass state."""
⋮----
"""Used to cache :first-child pseudoclass state."""
⋮----
"""Used to cache :last-child pseudoclass state."""
⋮----
"""Used to cache :odd pseudoclass state."""
⋮----
"""Time of last scroll."""
⋮----
"""Optional minimum and maximum values for width and height."""
⋮----
@property
    def is_mounted(self) -> bool
⋮----
"""Check if this widget is mounted."""
⋮----
@property
    def siblings(self) -> list[Widget]
⋮----
"""Get the widget's siblings (self is removed from the return list).

        Returns:
            A list of siblings.
        """
parent = self.parent
⋮----
siblings = list(parent._nodes)
⋮----
@property
    def visible_siblings(self) -> list[Widget]
⋮----
"""A list of siblings which will be shown.

        Returns:
            List of siblings.
        """
siblings = [
⋮----
@property
    def allow_vertical_scroll(self) -> bool
⋮----
"""Check if vertical scroll is permitted.

        May be overridden if you want different logic regarding allowing scrolling.
        """
⋮----
@property
    def allow_horizontal_scroll(self) -> bool
⋮----
"""Check if horizontal scroll is permitted.

        May be overridden if you want different logic regarding allowing scrolling.
        """
⋮----
@property
    def _allow_scroll(self) -> bool
⋮----
"""Check if both axis may be scrolled.

        Returns:
            True if horizontal and vertical scrolling is enabled.
        """
⋮----
@property
    def allow_maximize(self) -> bool
⋮----
"""Check if the widget may be maximized.

        Returns:
            `True` if the widget may be maximized, or `False` if it should not be maximized.
        """
⋮----
@property
    def offset(self) -> Offset
⋮----
"""Widget offset from origin.

        Returns:
            Relative offset.
        """
⋮----
@offset.setter
    def offset(self, offset: tuple[int, int]) -> None
⋮----
@property
    def opacity(self) -> float
⋮----
"""Total opacity of widget."""
opacity = 1.0
⋮----
@property
    def is_anchored(self) -> bool
⋮----
"""Is this widget anchored?

        See [anchor()][textual.widget.Widget.anchor] for an explanation of anchoring.

        """
⋮----
@property
    def is_mouse_over(self) -> bool
⋮----
"""Is the mouse currently over this widget?

        Note this will be `True` if the mouse pointer is within the widget's region, even if
        the mouse pointer is not directly over the widget (there could be another widget between
        the mouse pointer and self).

        """
⋮----
@property
    def is_maximized(self) -> bool
⋮----
"""Is this widget maximized?"""
⋮----
@property
    def is_in_maximized_view(self) -> bool
⋮----
"""Is this widget, or a parent maximized?"""
maximized = self.screen.maximized
⋮----
@property
    def _render_widget(self) -> Widget
⋮----
"""The widget the compositor should render."""
# Will return the "cover widget" if one is set, otherwise self.
⋮----
@property
    def text_selection(self) -> Selection | None
⋮----
"""Text selection information, or `None` if no text is selected in this widget."""
⋮----
def focus_on_click(self) -> bool
⋮----
"""Automatically focus the widget on click?

        Implement this if you want to change the default click to focus behavior.
        The default will return the classvar `FOCUS_ON_CLICK`.

        Returns:
            `True` if Textual should set focus automatically on a click, or `False` if it shouldn't.
        """
⋮----
def get_line_filters(self) -> Sequence[LineFilter]
⋮----
"""Get the line filters enabled for this widget.

        Returns:
            A sequence of [LineFilter][textual.filters.LineFilter] instances.
        """
⋮----
def preflight_checks(self) -> None
⋮----
"""Called in debug mode to do preflight checks.

        This is used by Textual to log some common errors, but you could implement this
        in custom widgets to perform additional checks.

        """
⋮----
def pre_render(self) -> None
⋮----
"""Called prior to rendering.

        If you implement this in a subclass, be sure to call the base class method via super.

        """
⋮----
def _cover(self, widget: Widget) -> None
⋮----
"""Set a widget used to replace the visuals of this widget (used for loading indicator).

        Args:
            widget: A newly constructed, but unmounted widget.
        """
⋮----
"""A hook to allow for the manipulation of widget placements before rendering.

        You could use this as a way to modify the positions / margins of widgets if your requirement is
        not supported in TCSS. In practice, this method is rarely needed!

        Args:
            placements: A list of [`WidgetPlacement`][textual.layout.WidgetPlacement] objects.

        Returns:
            A new list of placements.
        """
⋮----
def _uncover(self) -> None
⋮----
"""Remove any widget, previously set via [`_cover`][textual.widget.Widget._cover]."""
⋮----
def anchor(self, anchor: bool = True) -> None
⋮----
"""Anchor a scrollable widget.

        An anchored widget will stay scrolled the bottom when new content is added, until
        the user moves the scroll position.

        Args:
            anchor: Anchor the widget if `True`, clear the anchor if `False`.

        """
⋮----
def release_anchor(self) -> None
⋮----
"""Release the [anchor][textual.widget.Widget].

        If a widget is anchored, releasing the anchor will allow the user to scroll as normal.

        """
⋮----
def _check_anchor(self) -> None
⋮----
"""Check if the scroll position is near enough to the bottom to restore anchor."""
⋮----
def _check_disabled(self) -> bool
⋮----
"""Check if the widget is disabled either explicitly by setting `disabled`,
        or implicitly by setting `loading`.

        Returns:
            True if the widget should be disabled.
        """
⋮----
@property
    def tooltip(self) -> VisualType | None
⋮----
"""Tooltip for the widget, or `None` for no tooltip."""
⋮----
@tooltip.setter
    def tooltip(self, tooltip: VisualType | None)
⋮----
def with_tooltip(self, tooltip: Visual | RenderableType | None) -> Self
⋮----
"""Chainable method to set a tooltip.

        Example:
            ```python
            def compose(self) -> ComposeResult:
                yield Label("Hello").with_tooltip("A greeting")
            ```

        Args:
            tooltip: New tooltip, or `None` to clear the tooltip.

        Returns:
            Self.
        """
⋮----
def allow_focus(self) -> bool
⋮----
"""Check if the widget is permitted to focus.

        The base class returns [`can_focus`][textual.widget.Widget.can_focus].
        This method may be overridden if additional logic is required.

        Returns:
            `True` if the widget may be focused, or `False` if it may not be focused.
        """
⋮----
def allow_focus_children(self) -> bool
⋮----
"""Check if a widget's children may be focused.

        The base class returns [`can_focus_children`][textual.widget.Widget.can_focus_children].
        This method may be overridden if additional logic is required.

        Returns:
            `True` if the widget's children may be focused, or `False` if the widget's children may not be focused.
        """
⋮----
def compose_add_child(self, widget: Widget) -> None
⋮----
"""Add a node to children.

        This is used by the compose process when it adds children.
        There is no need to use it directly, but you may want to override it in a subclass
        if you want children to be attached to a different node.

        Args:
            widget: A Widget to add.
        """
_rich_traceback_omit = True
⋮----
@property
    def is_disabled(self) -> bool
⋮----
"""Is the widget disabled either because `disabled=True` or an ancestor has `disabled=True`."""
node: MessagePump | None = self
⋮----
node = node._parent
⋮----
@property
    def has_focus_within(self) -> bool
⋮----
"""Are any descendants focused?"""
⋮----
focused = self.screen.focused
⋮----
node = focused
⋮----
@property
    def first_of_type(self) -> bool
⋮----
"""Is this the first widget of its type in its siblings?"""
⋮----
# This pseudo classes only changes when the parent's nodes._updates changes
⋮----
widget_type = type(self)
⋮----
@property
    def last_of_type(self) -> bool
⋮----
"""Is this the last widget of its type in its siblings?"""
⋮----
@property
    def first_child(self) -> bool
⋮----
"""Is this the first widget in its siblings?"""
⋮----
# This pseudo class only changes when the parent's nodes._updates changes
⋮----
@property
    def last_child(self) -> bool
⋮----
"""Is this the last widget in its siblings?"""
⋮----
@property
    def is_odd(self) -> bool
⋮----
"""Is this widget at an oddly numbered position within its siblings?"""
⋮----
is_odd = parent._nodes.displayed_and_visible.index(self) % 2 == 0
⋮----
@property
    def is_even(self) -> bool
⋮----
"""Is this widget at an evenly numbered position within its siblings?"""
⋮----
def __enter__(self) -> Self
⋮----
"""Use as context manager when composing."""
⋮----
"""Exit compose context manager."""
compose_stack = self.app._compose_stacks[-1]
composed = compose_stack.pop()
⋮----
def clear_cached_dimensions(self) -> None
⋮----
"""Clear cached results of `get_content_width` and `get_content_height`.

        Call if the widget's renderable changes size after the widget has been created.

        !!! note

            This is not required if you are extending [`Static`][textual.widgets.Static].

        """
⋮----
def get_loading_widget(self) -> Widget
⋮----
"""Get a widget to display a loading indicator.

        The default implementation will defer to App.get_loading_widget.

        Returns:
            A widget in place of this widget to indicate a loading.
        """
loading_widget = self.screen.get_loading_widget()
⋮----
def set_loading(self, loading: bool) -> None
⋮----
"""Set or reset the loading state of this widget.

        A widget in a loading state will display a `LoadingIndicator` or a custom widget
        set through overriding the `get_loading_widget` method.

        Args:
            loading: `True` to put the widget into a loading state, or `False` to reset the loading state.
        """
⋮----
loading_indicator = self.get_loading_widget()
⋮----
def _watch_loading(self, loading: bool) -> None
⋮----
"""Called when the 'loading' reactive is changed."""
⋮----
ExpectType = TypeVar("ExpectType", bound="Widget")
⋮----
@overload
        def get_child_by_id(self, id: str) -> Widget: ...
⋮----
"""Return the first child (immediate descendent) of this node with the given ID.

        Args:
            id: The ID of the child.
            expect_type: Require the object be of the supplied type, or None for any type.

        Returns:
            The first child of this node with the ID.

        Raises:
            NoMatches: if no children could be found for this ID
            WrongType: if the wrong type was found.
        """
child = self._get_dom_base()._nodes._get_by_id(id)
⋮----
@overload
        def get_widget_by_id(self, id: str) -> Widget: ...
⋮----
"""Return the first descendant widget with the given ID.

        Performs a depth-first search rooted at this widget.

        Args:
            id: The ID to search for in the subtree.
            expect_type: Require the object be of the supplied type, or None for any type.

        Returns:
            The first descendant encountered with this ID.

        Raises:
            NoMatches: if no children could be found for this ID.
            WrongType: if the wrong type was found.
        """
⋮----
widget = self.query_one(f"#{id}")
⋮----
def get_child_by_type(self, expect_type: type[ExpectType]) -> ExpectType
⋮----
"""Get the first immediate child of a given type.

        Only returns exact matches, and so will not match subclasses of the given type.

        Args:
            expect_type: The type of the child to search for.

        Raises:
            NoMatches: If no matching child is found.

        Returns:
            The first immediate child widget with the expected type.
        """
⋮----
# We want the child with the exact type (not subclasses)
⋮----
"""Get a *Rich* style for a component.

        Args:
            names: Names of components.
            partial: Return a partial style (not combined with parent).
            default: A Style to return if any component style doesn't exist.

        Raises:
            KeyError: If a component style doesn't exist, and no `default` is provided.

        Returns:
            A Rich style object.
        """
⋮----
component_styles = self.get_component_styles(*names)
⋮----
style = component_styles.rich_style
text_opacity = component_styles.text_opacity
⋮----
partial_style = component_styles.partial_rich_style
⋮----
"""Get the visual style for the widget, including any component styles.

        Args:
            component_classes: Optional component styles.
            partial: Return a partial style (not combined with parent).

        Returns:
            A Visual style instance.

        """
cache_key = (self._pseudo_classes_cache_key, component_classes, partial)
⋮----
background = Color(0, 0, 0, 0)
color = Color(255, 255, 255, 0)
⋮----
style = Style()
⋮----
def iter_styles() -> Iterable[StylesBase]
⋮----
"""Iterate over the styles from the DOM and additional components styles."""
⋮----
node = self
⋮----
has_rule = styles.has_rule
⋮----
text_background = background + styles.background.tint(
⋮----
background_tint = styles.background.tint(styles.background_tint)
background = background.blend(
⋮----
text_background = background
⋮----
color = styles.color.multiply_alpha(styles.text_opacity)
⋮----
color = text_background.get_contrast_text(color.a)
⋮----
visual_style = VisualStyle(
⋮----
def _get_style(self, style: VisualStyle | str) -> VisualStyle
⋮----
"""A get_style method for use in Content.

        Args:
            style: A style prefixed with a dot.

        Returns:
            A visual style if one is fund, otherwise `None`.
        """
⋮----
visual_style = VisualStyle.null()
⋮----
visual_style = node.get_visual_style(style[1:], partial=True)
⋮----
visual_style = VisualStyle.parse(style)
⋮----
@overload
    def render_str(self, text_content: str) -> Content: ...
⋮----
@overload
    def render_str(self, text_content: Content) -> Content: ...
⋮----
def render_str(self, text_content: str | Content) -> Content
⋮----
"""Convert str into a [Content][textual.content.Content] instance.

        If you pass in an existing Content instance it will be returned unaltered.

        Args:
            text_content: Content or str.

        Returns:
            Content object.
        """
⋮----
def arrange(self, size: Size, optimal: bool = False) -> DockArrangeResult
⋮----
"""Arrange child widgets.

        This method is best left alone, unless you have a deep understanding of what it does.

        Args:
            size: Size of container.
            optimal: Whether fr units should expand the widget (`False`) or avoid expanding the widget (`True`).

        Returns:
            Widget locations.
        """
cache_key = (size, self._nodes._updates, optimal)
cached_result = self._arrangement_cache.get(cache_key)
⋮----
arrangement = self._arrangement_cache[cache_key] = arrange(
⋮----
def _clear_arrangement_cache(self) -> None
⋮----
"""Clear arrangement cache, forcing a new arrange operation."""
⋮----
def _get_virtual_dom(self) -> Iterable[Widget]
⋮----
"""Get widgets not part of the DOM.

        Returns:
            An iterable of Widgets.
        """
⋮----
def _find_mount_point(self, spot: int | str | "Widget") -> tuple["Widget", int]
⋮----
"""Attempt to locate the point where the caller wants to mount something.

        Args:
            spot: The spot to find.

        Returns:
            The parent and the location in its child list.

        Raises:
            MountError: If there was an error finding where to mount a widget.

        The rules of this method are:

        - Given an ``int``, parent is ``self`` and location is the integer value.
        - Given a ``Widget``, parent is the widget's parent and location is
          where the widget is found in the parent's ``children``. If it
          can't be found a ``MountError`` will be raised.
        - Given a string, it is used to perform a ``query_one`` and then the
          result is used as if a ``Widget`` had been given.
        """
⋮----
# A numeric location means at that point in our child list.
⋮----
# If we've got a string, that should be treated like a query that
# can be passed to query_one. So let's use that to get a widget to
# work on.
⋮----
spot = self.query_exactly_one(spot, Widget)
⋮----
# At this point we should have a widget, either because we got given
# one, or because we pulled one out of the query. First off, does it
# have a parent? There's no way we can use it as a sibling to make
# mounting decisions if it doesn't have a parent.
⋮----
# We've got a widget. It has a parent. It has (zero or more)
# children. We should be able to go looking for the widget's
# location amongst its parent's children.
⋮----
"""Mount widgets below this widget (making this widget a container).

        Args:
            *widgets: The widget(s) to mount.
            before: Optional location to mount before. An `int` is the index
                of the child to mount before, a `str` is a `query_one` query to
                find the widget to mount before.
            after: Optional location to mount after. An `int` is the index
                of the child to mount after, a `str` is a `query_one` query to
                find the widget to mount after.

        Returns:
            An awaitable object that waits for widgets to be mounted.

        Raises:
            MountError: If there is a problem with the mount request.

        Note:
            Only one of ``before`` or ``after`` can be provided. If both are
            provided a ``MountError`` will be raised.
        """
⋮----
# Check for duplicate IDs in the incoming widgets
ids_to_mount = [
⋮----
counter = Counter(ids_to_mount)
⋮----
# Saying you want to mount before *and* after something is an error.
⋮----
# Decide the final resting place depending on what we've been asked
# to do.
insert_before: int | None = None
insert_after: int | None = None
⋮----
parent = self
⋮----
mounted = self.app._register(
⋮----
def update_styles(children: list[DOMNode]) -> None
⋮----
"""Update order related CSS"""
⋮----
# If the new children aren't at the end.
# we need to update both odd/even, first-of-type/last-of-type and first-child/last-child
⋮----
await_mount = AwaitMount(self, mounted)
⋮----
def _refresh_styles(self) -> None
⋮----
"""Request refresh of styles on idle."""
⋮----
"""Mount widgets from an iterable.

        Args:
            widgets: An iterable of widgets.
            before: Optional location to mount before. An `int` is the index
                of the child to mount before, a `str` is a `query_one` query to
                find the widget to mount before.
            after: Optional location to mount after. An `int` is the index
                of the child to mount after, a `str` is a `query_one` query to
                find the widget to mount after.

        Returns:
            An awaitable object that waits for widgets to be mounted.

        Raises:
            MountError: If there is a problem with the mount request.

        Note:
            Only one of `before` or `after` can be provided. If both are
            provided a `MountError` will be raised.
        """
⋮----
await_mount = self.mount(*widgets, before=before, after=after)
⋮----
"""Mount widgets from the result of a compose method.

        Example:
        ```python
            def on_key(self, event:events.Key) -> None:

                def add_key(key:str) -> ComposeResult:
                    '''Compose key information widgets'''
                    with containers.HorizontalGroup():
                        yield Label("You pressed:")
                        yield Label(key)

                self.mount_compose(add_key(event.key))

        ```

        Args:
            compose_result: The result of a compose method.
            before: Optional location to mount before. An `int` is the index
                of the child to mount before, a `str` is a `query_one` query to
                find the widget to mount before.
            after: Optional location to mount after. An `int` is the index
                of the child to mount after, a `str` is a `query_one` query to
                find the widget to mount after.

        Returns:
            An awaitable object that waits for widgets to be mounted.

        Raises:
            MountError: If there is a problem with the mount request.

        Note:
            Only one of `before` or `after` can be provided. If both are
            provided a `MountError` will be raised.
        """
⋮----
"""Move a child widget within its parent's list of children.

        Args:
            child: The child widget to move.
            before: Child widget or location index to move before.
            after: Child widget or location index to move after.

        Raises:
            WidgetError: If there is a problem with the child or target.

        Note:
            Only one of `before` or `after` can be provided. If neither
            or both are provided a `WidgetError` will be raised.
        """
⋮----
# One or the other of before or after are required. Can't do
# neither, can't do both.
⋮----
def _to_widget(child: int | Widget, called: str) -> Widget
⋮----
"""Ensure a given child reference is a Widget."""
⋮----
child = self._nodes[child]
⋮----
# We got an actual widget, so let's be sure it really is one of
# our children.
⋮----
_ = self._nodes.index(child)
⋮----
# Ensure the child and target are widgets.
child = _to_widget(child, "move")
target = _to_widget(
⋮----
return  # Nothing to be done.
⋮----
# At this point we should know what we're moving, and it should be a
# child; where we're moving it to, which should be within the child
# list; and how we're supposed to move it. All that's left is doing
# the right thing.
⋮----
# Request a refresh.
⋮----
def compose(self) -> ComposeResult
⋮----
"""Called by Textual to create child widgets.

        This method is called when a widget is mounted or by setting `recompose=True` when
        calling [`refresh()`][textual.widget.Widget.refresh].

        Note that you don't typically need to explicitly call this method.

        Example:
            ```python
            def compose(self) -> ComposeResult:
                yield Header()
                yield Label("Press the button below:")
                yield Button()
                yield Footer()
            ```
        """
⋮----
async def _check_recompose(self) -> None
⋮----
"""Check if a recompose is required."""
⋮----
async def recompose(self) -> None
⋮----
"""Recompose the widget.

        Recomposing will remove children and call `self.compose` again to remount.
        """
⋮----
compose_nodes = compose(self)
⋮----
def _post_register(self, app: App) -> None
⋮----
"""Called when the instance is registered.

        Args:
            app: App instance.
        """
# Parse the Widget's CSS
⋮----
"""Process the box model for this widget.

        Args:
            container: The size of the container widget (with a layout).
            viewport: The viewport size.
            width_fraction: A fraction used for 1 `fr` unit on the width dimension.
            height_fraction: A fraction used for 1 `fr` unit on the height dimension.
            constrain_width: Restrict the width to the container width.

        Returns:
            The size and margin for this widget.
        """
cache_key = (
⋮----
styles = self.styles
is_border_box = styles.box_sizing == "border-box"
gutter = styles.gutter  # Padding plus border
margin = styles.margin
⋮----
styles_width = styles.width
⋮----
styles_width = Scalar.parse("auto")
is_auto_width = styles_width and styles_width.is_auto
is_auto_height = styles.height and styles.height.is_auto
⋮----
# Container minus padding and border
content_container = container - gutter.totals
⋮----
extrema = self._extrema = self._resolve_extrema(
⋮----
# No width specified, fill available space
content_width = Fraction(content_container.width - margin.width)
⋮----
# When width is auto, we want enough space to always fit the content
content_width = Fraction(
⋮----
content_width = Fraction(content_container.width)
⋮----
# An explicit width
content_width = styles_width.resolve(
⋮----
# Restrict to minimum width, if set
content_width = max(content_width, min_width, Fraction(0))
⋮----
# Restrict to maximum width, if set
content_width = min(content_width, max_width)
⋮----
content_width = max(Fraction(0), content_width)
⋮----
content_width = min(Fraction(container.width - gutter.width), content_width)
⋮----
# No height specified, fill the available space
content_height = Fraction(content_container.height - margin.height)
⋮----
# Calculate dimensions based on content
content_height = Fraction(
⋮----
content_height = Fraction(content_container.height)
⋮----
styles_height = styles.height
# Explicit height set
content_height = styles_height.resolve(
⋮----
# Restrict to minimum height, if set
content_height = max(content_height, min_height, Fraction(0))
⋮----
content_height = min(content_height, max_height)
⋮----
content_height = max(Fraction(0), content_height)
model = BoxModel(
⋮----
def get_content_width(self, container: Size, viewport: Size) -> int
⋮----
"""Called by textual to get the width of the content area. May be overridden in a subclass.

        Args:
            container: Size of the container (immediate parent) widget.
            viewport: Size of the viewport.

        Returns:
            The optimal width of the content.
        """
⋮----
width = self.layout.get_content_width(self, container, viewport)
⋮----
cache_key = container.width
⋮----
visual = self._render()
width = visual.get_optimal_width(self.styles, container.width)
⋮----
width = max(container.width, width)
⋮----
width = min(width, container.width)
⋮----
def get_content_height(self, container: Size, viewport: Size, width: int) -> int
⋮----
"""Called by Textual to get the height of the content area. May be overridden in a subclass.

        Args:
            container: Size of the container (immediate parent) widget.
            viewport: Size of the viewport.
            width: Width of renderable.

        Returns:
            The height of the content.
        """
⋮----
height = self.layout.get_content_height(
⋮----
cache_key = width
⋮----
height = visual.get_height(self.styles, width)
⋮----
# TODO: This will cause the widget to refresh, even when there are no links
# Can we avoid this?
⋮----
def watch_scroll_x(self, old_value: float, new_value: float) -> None
⋮----
def watch_scroll_y(self, old_value: float, new_value: float) -> None
⋮----
def validate_scroll_x(self, value: float) -> float
⋮----
def validate_scroll_target_x(self, value: float) -> float
⋮----
def validate_scroll_y(self, value: float) -> float
⋮----
def validate_scroll_target_y(self, value: float) -> float
⋮----
@property
    def max_scroll_x(self) -> int
⋮----
"""The maximum value of `scroll_x`."""
⋮----
@property
    def max_scroll_y(self) -> int
⋮----
"""The maximum value of `scroll_y`."""
⋮----
@property
    def is_vertical_scroll_end(self) -> bool
⋮----
"""Is the vertical scroll position at the maximum?"""
⋮----
@property
    def is_horizontal_scroll_end(self) -> bool
⋮----
"""Is the horizontal scroll position at the maximum?"""
⋮----
@property
    def is_vertical_scrollbar_grabbed(self) -> bool
⋮----
"""Is the user dragging the vertical scrollbar?"""
⋮----
@property
    def is_horizontal_scrollbar_grabbed(self) -> bool
⋮----
@property
    def scrollbar_corner(self) -> ScrollBarCorner
⋮----
"""The scrollbar corner.

        Note:
            This will *create* a scrollbar corner if one doesn't exist.

        Returns:
            ScrollBarCorner Widget.
        """
⋮----
@property
    def vertical_scrollbar(self) -> ScrollBar
⋮----
"""The vertical scrollbar (create if necessary).

        Note:
            This will *create* a scrollbar if one doesn't exist.

        Returns:
            ScrollBar Widget.
        """
⋮----
self._vertical_scrollbar = scroll_bar = ScrollBar(
⋮----
@property
    def horizontal_scrollbar(self) -> ScrollBar
⋮----
"""The horizontal scrollbar.

        Note:
            This will *create* a scrollbar if one doesn't exist.

        Returns:
            ScrollBar Widget.
        """
⋮----
self._horizontal_scrollbar = scroll_bar = ScrollBar(
⋮----
def _refresh_scrollbars(self) -> None
⋮----
"""Refresh scrollbar visibility."""
⋮----
overflow_x = styles.overflow_x
overflow_y = styles.overflow_y
⋮----
show_horizontal = False
⋮----
show_horizontal = True
⋮----
show_horizontal = self.virtual_size.width > width
⋮----
show_vertical = False
⋮----
show_vertical = True
⋮----
show_vertical = self.virtual_size.height > height
⋮----
_show_horizontal = show_horizontal
_show_vertical = show_vertical
⋮----
# When a single scrollbar is shown, the other dimension changes, so we need to recalculate.
⋮----
show_horizontal = self.virtual_size.width > (
⋮----
show_vertical = self.virtual_size.height > (
⋮----
@property
    def scrollbars_enabled(self) -> tuple[bool, bool]
⋮----
"""A tuple of booleans that indicate if scrollbars are enabled.

        Returns:
            A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)
        """
⋮----
@property
    def scrollbars_space(self) -> tuple[int, int]
⋮----
"""The number of cells occupied by scrollbars for width and height"""
⋮----
@property
    def scrollbar_size_vertical(self) -> int
⋮----
"""Get the width used by the *vertical* scrollbar.

        Returns:
            Number of columns in the vertical scrollbar.
        """
⋮----
@property
    def scrollbar_size_horizontal(self) -> int
⋮----
"""Get the height used by the *horizontal* scrollbar.

        Returns:
            Number of rows in the horizontal scrollbar.
        """
⋮----
@property
    def scrollbar_gutter(self) -> Spacing
⋮----
"""Spacing required to fit scrollbar(s).

        Returns:
            Scrollbar gutter spacing.
        """
⋮----
@property
    def gutter(self) -> Spacing
⋮----
"""Spacing for padding / border / scrollbars.

        Returns:
            Additional spacing around content area.
        """
⋮----
@property
    def size(self) -> Size
⋮----
"""The size of the content area.

        Returns:
            Content area size.
        """
⋮----
@property
    def scrollable_size(self) -> Size
⋮----
"""The size of the scrollable content.

        Returns:
            Scrollable content size.
        """
⋮----
@property
    def outer_size(self) -> Size
⋮----
"""The size of the widget (including padding and border).

        Returns:
            Outer size.
        """
⋮----
@property
    def container_size(self) -> Size
⋮----
"""The size of the container (parent widget).

        Returns:
            Container size.
        """
⋮----
@property
    def content_region(self) -> Region
⋮----
"""Gets an absolute region containing the content (minus padding and border).

        Returns:
            Screen region that contains a widget's content.
        """
content_region = self.region.shrink(self.styles.gutter)
⋮----
@property
    def scrollable_content_region(self) -> Region
⋮----
"""Gets an absolute region containing the scrollable content (minus padding, border, and scrollbars).

        Returns:
            Screen region that contains a widget's content.
        """
content_region = self.region.shrink(self.styles.gutter).shrink(
⋮----
@property
    def content_offset(self) -> Offset
⋮----
"""An offset from the Widget origin where the content begins.

        Returns:
            Offset from widget's origin.
        """
⋮----
@property
    def content_size(self) -> Size
⋮----
@property
    def region(self) -> Region
⋮----
"""The region occupied by this widget, relative to the Screen.

        Raises:
            NoScreen: If there is no screen.
            errors.NoWidget: If the widget is not on the screen.

        Returns:
            Region within screen occupied by widget.
        """
⋮----
@property
    def dock_gutter(self) -> Spacing
⋮----
"""Space allocated to docks in the parent.

        Returns:
            Space to be subtracted from scrollable area.
        """
⋮----
@property
    def container_viewport(self) -> Region
⋮----
"""The viewport region (parent window).

        Returns:
            The region that contains this widget.
        """
⋮----
@property
    def virtual_region(self) -> Region
⋮----
"""The widget region relative to its container (which may not be visible,
        depending on scroll offset).


        Returns:
            The virtual region.
        """
⋮----
@property
    def window_region(self) -> Region
⋮----
"""The region within the scrollable area that is currently visible.

        Returns:
            New region.
        """
window_region = self.region.at_offset(self.scroll_offset)
⋮----
@property
    def virtual_region_with_margin(self) -> Region
⋮----
"""The widget region relative to its container (*including margin*), which may not be visible,
        depending on the scroll offset.

        Returns:
            The virtual region of the Widget, inclusive of its margin.
        """
⋮----
@property
    def _self_or_ancestors_disabled(self) -> bool
⋮----
"""Is this widget or any of its ancestors disabled?"""
⋮----
node: Widget | None = self
⋮----
node = node._parent  # type:ignore[assignment]
⋮----
@property
    def focusable(self) -> bool
⋮----
"""Can this widget currently be focused?"""
⋮----
@property
    def _focus_sort_key(self) -> tuple[int, int]
⋮----
"""Key function to sort widgets into focus order."""
⋮----
@property
    def scroll_offset(self) -> Offset
⋮----
"""Get the current scroll offset.

        Returns:
            Offset a container has been scrolled by.
        """
⋮----
@property
    def container_scroll_offset(self) -> Offset
⋮----
"""The scroll offset the nearest container ancestor."""
⋮----
@property
    def _console(self) -> Console
⋮----
"""Get the current console.

        Returns:
            A Rich console object.
        """
⋮----
@property
    def _has_relative_children_width(self) -> bool
⋮----
"""Do any children (or progeny) have a relative width?"""
⋮----
styles = child.styles
⋮----
width = styles.width
⋮----
@property
    def _has_relative_children_height(self) -> bool
⋮----
"""Do any children (or progeny) have a relative height?"""
⋮----
height = styles.height
⋮----
@property
    def is_on_screen(self) -> bool
⋮----
"""Check if the node was displayed in the last screen update."""
⋮----
"""Resolve minimum and maximum values for width and height.

        Args:
            container: Size of outer widget.
            viewport: Viewport size.
            width_fraction: Size of 1fr width.
            height_fraction: Size of 1fr height.

        Returns:
            Extrema object.
        """
⋮----
min_width: Fraction | None = None
max_width: Fraction | None = None
min_height: Fraction | None = None
max_height: Fraction | None = None
⋮----
gutter_width = gutter_height = 0
⋮----
min_width = (
⋮----
max_width = (
⋮----
min_height = (
⋮----
max_height = (
⋮----
extrema = Extrema(min_width, max_width, min_height, max_height)
⋮----
"""Animate an attribute.

        Args:
            attribute: Name of the attribute to animate.
            value: The value to animate to.
            final_value: The final value of the animation. Defaults to `value` if not set.
            duration: The duration (in seconds) of the animation.
            speed: The speed of the animation.
            delay: A delay (in seconds) before the animation starts.
            easing: An easing method.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
        """
⋮----
async def stop_animation(self, attribute: str, complete: bool = True) -> None
⋮----
"""Stop an animation on an attribute.

        Args:
            attribute: Name of the attribute whose animation should be stopped.
            complete: Should the animation be set to its final value?

        Note:
            If there is no animation scheduled or running, this is a no-op.
        """
⋮----
@property
    def layout(self) -> Layout
⋮----
"""Get the layout object if set in styles, or a default layout.

        Returns:
            A layout object.
        """
⋮----
@property
    def is_container(self) -> bool
⋮----
"""Is this widget a container (contains other widgets)?"""
⋮----
@property
    def is_scrollable(self) -> bool
⋮----
"""Can this widget be scrolled?"""
⋮----
@property
    def is_scrolling(self) -> bool
⋮----
"""Is this widget currently scrolling?"""
current_time = monotonic()
⋮----
# Scroll ended very recently
⋮----
@property
    def layer(self) -> str
⋮----
"""Get the name of this widgets layer.

        Returns:
            Name of layer.
        """
⋮----
@property
    def layers(self) -> tuple[str, ...]
⋮----
"""Layers of from parent.

        Returns:
            Tuple of layer names.
        """
layers: tuple[str, ...] = ("default",)
⋮----
layers = node.styles.layers
⋮----
@property
    def link_style(self) -> Style
⋮----
"""Style of links.

        Returns:
            Rich style.
        """
⋮----
link_background = background + styles.link_background
link_color = link_background + (
style = styles.link_style + Style.from_color(
⋮----
@property
    def link_style_hover(self) -> Style
⋮----
"""Style of links underneath the mouse cursor.

        Returns:
            Rich Style.
        """
⋮----
hover_background = background + styles.link_background_hover
hover_color = hover_background + (
style = styles.link_style_hover + Style.from_color(
⋮----
@property
    def select_container(self) -> Widget
⋮----
"""The widget's container used when selecting text..

        Returns:
            A widget which contains this widget.
        """
container: Widget = self
⋮----
def _set_dirty(self, *regions: Region) -> None
⋮----
"""Set the Widget as 'dirty' (requiring re-paint).

        Regions should be specified as positional args. If no regions are added, then
        the entire widget will be considered dirty.

        Args:
            *regions: Regions which require a repaint.
        """
⋮----
content_offset = self.content_offset
widget_regions = [region.translate(content_offset) for region in regions]
⋮----
outer_size = self.outer_size
⋮----
def _exchange_repaint_regions(self) -> Collection[Region]
⋮----
"""Get a copy of the regions which need a repaint, and clear internal cache.

        Returns:
            Regions to repaint.
        """
regions = self._repaint_regions.copy()
⋮----
"""Scroll to a given (absolute) coordinate, optionally animating.

        Args:
            x: X coordinate (column) to scroll to, or `None` for no change.
            y: Y coordinate (row) to scroll to, or `None` for no change.
            animate: Animate to new scroll position.
            speed: Speed of scroll if `animate` is `True`. Or `None` to use duration.
            duration: Duration of animation, if `animate` is `True` and speed is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            release_anchor: If `True` call `release_anchor`.

        Returns:
            `True` if the scroll position changed, otherwise `False`.
        """
⋮----
maybe_scroll_x = x is not None and (self.allow_horizontal_scroll or force)
maybe_scroll_y = y is not None and (self.allow_vertical_scroll or force)
scrolled_x = scrolled_y = False
⋮----
animator = self.app.animator
⋮----
def _animate_on_complete() -> None
⋮----
"""set last scroll time, and invoke callback."""
⋮----
# TODO: configure animation speed
⋮----
speed = 50
⋮----
easing = DEFAULT_SCROLL_EASING
⋮----
scrolled_x = True
⋮----
scrolled_y = True
⋮----
scroll_x = self.scroll_x
⋮----
scrolled_x = scroll_x != self.scroll_x
⋮----
scroll_y = self.scroll_y
⋮----
scrolled_y = scroll_y != self.scroll_y
⋮----
@property
    def allow_select(self) -> bool
⋮----
"""Check if this widget permits text selection.

        Returns:
            `True` if the widget supports text selection, otherwise `False`.
        """
⋮----
def pre_layout(self, layout: Layout) -> None
⋮----
"""This method id called prior to a layout operation.

        Implement this method if you want to make updates that should impact
        the layout.

        Args:
            layout: The [Layout][textual.layout.Layout] instance that will be used to arrange this widget's children.

        """
⋮----
def set_scroll(self, x: float | None, y: float | None) -> None
⋮----
"""Set the scroll position without any validation.

        This is a low-level method for when you want to see the scroll position in the next frame.
        For a more fully featured method, see [`scroll_to`][textual.widget.Widget.scroll_to].

        Args:
            x: Desired `X` coordinate.
            y: Desired `Y` coordinate.
        """
⋮----
"""Scroll to a given (absolute) coordinate, optionally animating.

        Args:
            x: X coordinate (column) to scroll to, or `None` for no change.
            y: Y coordinate (row) to scroll to, or `None` for no change.
            animate: Animate to new scroll position.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
            release_anchor: If `True` call `release_anchor`.

        Note:
            The call to scroll is made after the next refresh.
        """
⋮----
"""Scroll relative to current position.

        Args:
            x: X distance (columns) to scroll, or ``None`` for no change.
            y: Y distance (rows) to scroll, or ``None`` for no change.
            animate: Animate to new scroll position.
            speed: Speed of scroll if `animate` is `True`. Or `None` to use `duration`.
            duration: Duration of animation, if animate is `True` and speed is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
"""Scroll to home position.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use duration.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
            x_axis: Allow scrolling on X axis?
            y_axis: Allow scrolling on Y axis?
        """
⋮----
duration = 1.0
⋮----
"""Scroll to the end of the container.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
            x_axis: Allow scrolling on X axis?
            y_axis: Allow scrolling on Y axis?

        """
⋮----
async def scroll_end_on_complete() -> None
⋮----
"""It's possible new content was added before we reached the end."""
⋮----
# In most cases we'd call self.scroll_to and let it handle the call
# to do things after a refresh, but here we need the refresh to
# happen first so that we can get the new self.max_scroll_y (that
# is, we need the layout to work out and then figure out how big
# things are). Because of this we'll create a closure over the call
# here and make our own call to call_after_refresh.
def _lazily_scroll_end() -> None
⋮----
"""Scroll to the end of the widget."""
⋮----
"""Scroll one cell left.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
"""Scroll left one position, taking scroll sensitivity into account.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).

        Returns:
            `True` if any scrolling was done.

        Note:
            How much is scrolled is controlled by
            [App.scroll_sensitivity_x][textual.app.App.scroll_sensitivity_x].
        """
⋮----
"""Scroll one cell right.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
"""Scroll right one position, taking scroll sensitivity into account.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).

        Returns:
            `True` if any scrolling was done.

        Note:
            How much is scrolled is controlled by
            [App.scroll_sensitivity_x][textual.app.App.scroll_sensitivity_x].
        """
⋮----
"""Scroll one line down.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
"""Scroll down one position, taking scroll sensitivity into account.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).

        Returns:
            `True` if any scrolling was done.

        Note:
            How much is scrolled is controlled by
            [App.scroll_sensitivity_y][textual.app.App.scroll_sensitivity_y].
        """
⋮----
"""Scroll one line up.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and speed is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
"""Scroll up one position, taking scroll sensitivity into account.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and speed is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).

        Returns:
            `True` if any scrolling was done.

        Note:
            How much is scrolled is controlled by
            [App.scroll_sensitivity_y][textual.app.App.scroll_sensitivity_y].
        """
⋮----
"""Scroll one page up.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
        """
⋮----
"""Scroll one page down.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
        """
⋮----
"""Scroll one page left.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
        """
⋮----
duration = 0.3
⋮----
"""Scroll one page right.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
        """
⋮----
"""Scroll scrolling to bring a widget into view.

        Args:
            widget: A descendant widget.
            animate: `True` to animate, or `False` to jump.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            top: Scroll widget to top of container.
            origin_visible: Ensure that the top left of the widget is within the window.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.

        Returns:
            `True` if any scrolling has occurred in any descendant, otherwise `False`.
        """
# Grow the region by the margin so to keep the margin in view.
region = widget.virtual_region_with_margin
scrolled = False
⋮----
container = widget.parent
⋮----
scroll_offset = Offset(0, 0)
⋮----
scroll_offset = container.scroll_to_region(
⋮----
scrolled = True
⋮----
# Adjust the region by the amount we just scrolled it, and convert to
# its parent's virtual coordinate system.
region = (
⋮----
widget = container
⋮----
"""Scrolls a given region into view, if required.

        This method will scroll the least distance required to move `region` fully within
        the scrollable area.

        Args:
            region: A region that should be visible.
            spacing: Optional spacing around the region.
            animate: `True` to animate, or `False` to jump.
            speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            top: Scroll `region` to top of container.
            origin_visible: Ensure that the top left of the widget is within the window.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            x_axis: Allow scrolling on X axis?
            y_axis: Allow scrolling on Y axis?
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.

        Returns:
            The distance that was scrolled.
        """
window = self.scrollable_content_region.at_offset(self.scroll_offset)
⋮----
window = window.shrink(spacing)
⋮----
def clamp_delta(delta: Offset) -> Offset
⋮----
"""Clamp the delta to avoid scrolling out of range."""
⋮----
delta = Offset(
⋮----
delta = clamp_delta(
⋮----
delta = Offset(0, delta.y)
⋮----
delta = Offset(delta.x, 0)
⋮----
delta_x = delta.x if x_axis else 0
delta_y = delta.y if y_axis else 0
⋮----
duration = 0.2
⋮----
"""Scroll the container to make this widget visible.

        Args:
            animate: Animate scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            top: Scroll to top of container.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
# self.region is falsy which may indicate the widget hasn't been through a layout operation
# We can potentially make it do the right thing by postponing the scroll to after a refresh
⋮----
"""Scroll this widget to the center of self.

        The center of the widget will be scrolled to the center of the container.

        Args:
            widget: The widget to scroll to the center of self.
            animate: Whether to animate the scroll.
            speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
            duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
            easing: An easing method for the scrolling animation.
            force: Force scrolling even when prohibited by overflow styling.
            origin_visible: Ensure that the top left corner of the widget remains visible after the scroll.
            on_complete: A callable to invoke when the animation is finished.
            level: Minimum level required for the animation to take place (inclusive).
            immediate: If `False` the scroll will be deferred until after a screen refresh,
                set to `True` to scroll immediately.
        """
⋮----
def can_view_entire(self, widget: Widget) -> bool
⋮----
"""Check if a given widget is *fully* within the current view (scrollable area).

        Note: This doesn't necessarily equate to a widget being visible.
        There are other reasons why a widget may not be visible.

        Args:
            widget: A widget that is a descendant of self.

        Returns:
            `True` if the entire widget is in view, `False` if it is partially visible or not in view.
        """
⋮----
region = widget.region
node: Widget = widget
⋮----
node = node.parent
⋮----
def can_view_partial(self, widget: Widget) -> bool
⋮----
"""Check if a given widget at least partially visible within the current view (scrollable area).

        Args:
            widget: A widget that is a descendant of self.

        Returns:
            `True` if any part of the widget is visible, `False` if it is outside of the viewable area.
        """
⋮----
name = cls.__name__
⋮----
base = cls.__mro__[0]
⋮----
def _get_scrollable_region(self, region: Region) -> Region
⋮----
"""Adjusts the Widget region to accommodate scrollbars.

        Args:
            region: A region for the widget.

        Returns:
            The widget region minus scrollbars.
        """
⋮----
scrollbar_size_horizontal = styles.scrollbar_size_horizontal
scrollbar_size_vertical = styles.scrollbar_size_vertical
⋮----
show_vertical_scrollbar = bool(
show_horizontal_scrollbar = bool(
⋮----
# Let's _always_ reserve some space, whether the scrollbar is actually displayed or not:
show_vertical_scrollbar = True
⋮----
def _arrange_scrollbars(self, region: Region) -> Iterable[tuple[Widget, Region]]
⋮----
"""Arrange the 'chrome' widgets (typically scrollbars) for a layout element.

        Args:
            region: The containing region.

        Returns:
            Tuples of scrollbar Widget and region.
        """
⋮----
scrollbar_size_horizontal = self.scrollbar_size_horizontal
scrollbar_size_vertical = self.scrollbar_size_vertical
⋮----
scrollbar = self.vertical_scrollbar
⋮----
scrollbar = self.horizontal_scrollbar
⋮----
def get_pseudo_class_state(self) -> PseudoClasses
⋮----
"""Get an object describing whether each pseudo class is present on this object or not.

        Returns:
            A PseudoClasses object describing the pseudo classes that are present.
        """
⋮----
disabled = False
⋮----
disabled = True
⋮----
pseudo_classes = PseudoClasses(
⋮----
@property
    def _pseudo_classes_cache_key(self) -> tuple[int, ...]
⋮----
"""A cache key that changes when the pseudo-classes change."""
⋮----
def _get_justify_method(self) -> JustifyMethod | None
⋮----
"""Get the justify method that may be passed to a Rich renderable."""
text_justify: JustifyMethod | None = None
⋮----
text_align: JustifyMethod = cast(JustifyMethod, self.styles.text_align)
text_justify = _JUSTIFY_MAP.get(text_align, text_align)
⋮----
"""Applies style attributes to the default renderable.

        This method is called by Textual itself.
        It is unlikely you will need to call or implement this method.

        Returns:
            A new renderable.
        """
⋮----
text_justify = self._get_justify_method()
⋮----
renderable = Text.from_markup(renderable, justify=text_justify)
⋮----
renderable = renderable.copy()
⋮----
renderable = _Styled(
⋮----
def watch_has_focus(self, _has_focus: bool) -> None
⋮----
"""Update from CSS if has focus state changes."""
⋮----
def watch_disabled(self, disabled: bool) -> None
⋮----
"""Update the styles of the widget and its children when disabled is toggled."""
⋮----
# Ensure widget gets a Leave if it is disabled while hovered
⋮----
screen = self.screen
⋮----
"""Called when the widget's size is updated.

        Args:
            size: Screen size.
            virtual_size: Virtual (scrollable) size.
            container_size: Container size (size of parent).
            layout: Perform layout if required.

        Returns:
            True if a resize event should be sent, otherwise False.
        """
⋮----
def _scroll_update(self, virtual_size: Size) -> None
⋮----
"""Update scrollbars visibility and dimensions.

        Args:
            virtual_size: Virtual size.
        """
⋮----
@property
    def visual_style(self) -> VisualStyle
⋮----
styles = node.styles
⋮----
color = styles.color
⋮----
def get_selection(self, selection: Selection) -> tuple[str, str] | None
⋮----
"""Get the text under the selection.

        Args:
            selection: Selection information.

        Returns:
            Tuple of extracted text and ending (typically "\n" or " "), or `None` if no text could be extracted.
        """
⋮----
text = str(visual)
⋮----
def selection_updated(self, selection: Selection | None) -> None
⋮----
"""Called when the selection is updated.

        Args:
            selection: Selection information or `None` if no selection.
        """
⋮----
def _render_content(self) -> None
⋮----
"""Render all lines."""
⋮----
strips = Visual.to_strips(self, visual, width, height, self.visual_style)
⋮----
def render_line(self, y: int) -> Strip
⋮----
"""Render a line of content.

        Args:
            y: Y Coordinate of line.

        Returns:
            A rendered line.
        """
⋮----
line = self._render_cache.lines[y]
⋮----
line = Strip.blank(self.size.width, self.visual_style.rich_style)
⋮----
def render_lines(self, crop: Region) -> list[Strip]
⋮----
"""Render the widget into lines.

        Args:
            crop: Region within visible area to render.

        Returns:
            A list of list of segments.
        """
⋮----
strips = [
⋮----
strips = self._styles_cache.render_widget(self, crop)
⋮----
def get_style_at(self, x: int, y: int) -> Style
⋮----
"""Get the Rich style in a widget at a given relative offset.

        Args:
            x: X coordinate relative to the widget.
            y: Y coordinate relative to the widget.

        Returns:
            A rich Style object.
        """
offset = Offset(x, y)
screen_offset = offset + self.region.offset
⋮----
def suppress_click(self) -> None
⋮----
"""Suppress a click event.

        This will prevent a [Click][textual.events.Click] event being sent,
        if called after a mouse down event and before the click itself.

        """
⋮----
def _forward_event(self, event: events.Event) -> None
⋮----
def _refresh_scroll(self) -> None
⋮----
"""Refreshes the scroll position."""
⋮----
"""Initiate a refresh of the widget.

        This method sets an internal flag to perform a refresh, which will be done on the
        next idle event. Only one refresh will be done even if this method is called multiple times.

        By default this method will cause the content of the widget to refresh, but not change its size. You can also
        set `layout=True` to perform a layout.

        !!! warning

            It is rarely necessary to call this method explicitly. Updating styles or reactive attributes will
            do this automatically.

        Args:
            *regions: Additional screen regions to mark as dirty.
            repaint: Repaint the widget (will call render() again).
            layout: Also layout widgets in the view.
            recompose: Re-compose the widget (will remove and re-mount children).

        Returns:
            The `Widget` instance.
        """
⋮----
def remove(self) -> AwaitRemove
⋮----
"""Remove the Widget from the DOM (effectively deleting it).

        Returns:
            An awaitable object that waits for the widget to be removed.
        """
await_remove = self.app._prune(self, parent=self._parent)
⋮----
"""Remove the immediate children of this Widget from the DOM.

        Args:
            selector: A CSS selector or iterable of widgets to remove.

        Returns:
            An awaitable object that waits for the direct children to be removed.
        """
⋮----
selector = selector.__name__
⋮----
children_to_remove: Iterable[Widget]
⋮----
parsed_selectors = parse_selectors(selector)
children_to_remove = [
⋮----
children_to_remove = selector
await_remove = self.app._prune(*children_to_remove, parent=self)
⋮----
@asynccontextmanager
    async def batch(self) -> AsyncGenerator[None, None]
⋮----
"""Async context manager that combines widget locking and update batching.

        Use this async context manager whenever you want to acquire the widget lock and
        batch app updates at the same time.

        Example:
            ```py
            async with container.batch():
                await container.remove_children(Button)
                await container.mount(Label("All buttons are gone."))
            ```
        """
⋮----
def render(self) -> RenderResult
⋮----
"""Get [content](/guide/content) for the widget.

        Implement this method in a subclass for custom widgets.

        This method should return [markup](/guide/content#markup), a [Content][textual.content.Content] object, or a [Rich](https://github.com/Textualize/rich) renderable.

        Example:
            ```python
            from textual.app import RenderResult
            from textual.widget import Widget

            class CustomWidget(Widget):
                def render(self) -> RenderResult:
                    return "Welcome to [bold red]Textual[/]!"
            ```

        Returns:
            A string or object to render as the widget's content.
        """
⋮----
def _render(self) -> Visual
⋮----
"""Get renderable, promoting str to text as required.

        Returns:
            A Visual.
        """
cache_key = "_render.visual"
cached_visual = self._layout_cache.get(cache_key, None)
⋮----
visual = visualize(self, self.render(), markup=self._render_markup)
⋮----
"""Perform a given action, with this widget as the default namespace.

        Args:
            action: Action encoded as a string.
            namespaces: Mapping of namespaces.
        """
⋮----
def post_message(self, message: Message) -> bool
⋮----
"""Post a message to this widget.

        Args:
            message: Message to post.

        Returns:
            True if the message was posted, False if this widget was closed / closing.
        """
⋮----
# Catch a common error.
# This will error anyway, but at least we can offer a helpful message here.
⋮----
async def on_prune(self, event: messages.Prune) -> None
⋮----
"""Close message loop when asked to prune."""
⋮----
async def _message_loop_exit(self) -> None
⋮----
"""Clean up DOM tree."""
parent = self._parent
# Post messages to children, asking them to prune
children = [*self.children, *self._get_virtual_dom()]
⋮----
# Wait for child nodes to exit
⋮----
# Send unmount event
⋮----
# Finalize removal from DOM
⋮----
async def _on_idle(self, event: events.Idle) -> None
⋮----
"""Called when there are no more events on the queue.

        Args:
            event: Idle event.
        """
⋮----
def _check_refresh(self) -> None
⋮----
"""Check if a refresh was requested."""
⋮----
# TODO: Feels like a hack
# Perhaps there should be an explicit mechanism for backgrounds to refresh when scrolled?
⋮----
def focus(self, scroll_visible: bool = True) -> Self
⋮----
"""Give focus to this widget.

        Args:
            scroll_visible: Scroll parent to make this widget visible.

        Returns:
            The `Widget` instance.
        """
⋮----
def set_focus(widget: Widget) -> None
⋮----
"""Callback to set the focus."""
⋮----
def blur(self) -> Self
⋮----
"""Blur (un-focus) the widget.

        Focus will be moved to the next available widget in the focus chain.

        Returns:
            The `Widget` instance.
        """
⋮----
def capture_mouse(self, capture: bool = True) -> None
⋮----
"""Capture (or release) the mouse.

        When captured, mouse events will go to this widget even when the pointer is not directly over the widget.

        Args:
            capture: True to capture or False to release.
        """
⋮----
def release_mouse(self) -> None
⋮----
"""Release the mouse.

        Mouse events will only be sent when the mouse is over the widget.
        """
⋮----
def text_select_all(self) -> None
⋮----
"""Select the entire widget."""
⋮----
def begin_capture_print(self, stdout: bool = True, stderr: bool = True) -> None
⋮----
"""Capture text from print statements (or writes to stdout / stderr).

        If printing is captured, the widget will be sent an [`events.Print`][textual.events.Print] message.

        Call [`end_capture_print`][textual.widget.Widget.end_capture_print] to disable print capture.

        Args:
            stdout: Whether to capture stdout.
            stderr: Whether to capture stderr.
        """
⋮----
def end_capture_print(self) -> None
⋮----
"""End print capture (set with [`begin_capture_print`][textual.widget.Widget.begin_capture_print])."""
⋮----
def check_message_enabled(self, message: Message) -> bool
⋮----
"""Check if a given message is enabled (allowed to be sent).

        Args:
            message: A message object

        Returns:
            `True` if the message will be sent, or `False` if it is disabled.
        """
# Do the normal checking and get out if that fails.
⋮----
# Mouse scroll events should always go through, this allows mouse
# wheel scrolling to pass through disabled widgets.
⋮----
# Otherwise, if this is any other mouse event, the widget receiving
# the event must not be disabled at this moment.
⋮----
async def broker_event(self, event_name: str, event: events.Event) -> bool
⋮----
def notify_style_update(self) -> None
⋮----
async def _on_mouse_down(self, event: events.MouseDown) -> None
⋮----
async def _on_mouse_up(self, event: events.MouseUp) -> None
⋮----
async def _on_click(self, event: events.Click) -> None
⋮----
async def _on_key(self, event: events.Key) -> None
⋮----
async def handle_key(self, event: events.Key) -> bool
⋮----
async def _on_compose(self, event: events.Compose) -> None
⋮----
async def _compose(self) -> None
⋮----
widgets = [*self._pending_children, *compose(self)]
⋮----
async def mount_composed_widgets(self, widgets: list[Widget]) -> None
⋮----
"""Called by Textual to mount widgets after compose.

        There is generally no need to implement this method in your application.
        See [Lazy][textual.lazy.Lazy] for a class which uses this method to implement
        *lazy* mounting.

        Args:
            widgets: A list of child widgets.
        """
⋮----
def _extend_compose(self, widgets: list[Widget]) -> None
⋮----
"""Hook to extend composed widgets.

        Args:
            widgets: Widgets to be mounted.
        """
⋮----
def _on_mount(self, event: events.Mount) -> None
⋮----
def _on_leave(self, event: events.Leave) -> None
⋮----
def _on_enter(self, event: events.Enter) -> None
⋮----
def _on_focus(self, event: events.Focus) -> None
⋮----
def _on_blur(self, event: events.Blur) -> None
⋮----
def _on_mouse_scroll_down(self, event: events.MouseScrollDown) -> None
⋮----
def _on_mouse_scroll_up(self, event: events.MouseScrollUp) -> None
⋮----
def _on_mouse_scroll_right(self, event: events.MouseScrollRight) -> None
⋮----
def _on_mouse_scroll_left(self, event: events.MouseScrollLeft) -> None
⋮----
def _on_scroll_to(self, message: ScrollTo) -> None
⋮----
def _on_scroll_up(self, event: ScrollUp) -> None
⋮----
def _on_scroll_down(self, event: ScrollDown) -> None
⋮----
def _on_scroll_left(self, event: ScrollLeft) -> None
⋮----
def _on_scroll_right(self, event: ScrollRight) -> None
⋮----
def _on_show(self, event: events.Show) -> None
⋮----
def _on_hide(self, event: events.Hide) -> None
⋮----
def _on_scroll_to_region(self, message: messages.ScrollToRegion) -> None
⋮----
def _on_unmount(self) -> None
⋮----
def action_scroll_home(self) -> None
⋮----
def action_scroll_end(self) -> None
⋮----
def action_scroll_left(self) -> None
⋮----
def action_scroll_right(self) -> None
⋮----
def action_scroll_up(self) -> None
⋮----
def action_scroll_down(self) -> None
⋮----
def action_page_down(self) -> None
⋮----
def action_page_up(self) -> None
⋮----
def action_page_left(self) -> None
⋮----
def action_page_right(self) -> None
⋮----
"""Create a notification.

        !!! tip

            This method is thread-safe.

        Args:
            message: The message for the notification.
            title: The title for the notification.
            severity: The severity of the notification.
            timeout: The timeout (in seconds) for the notification, or `None` for default.
            markup: Render the message as content markup?

        See [`App.notify`][textual.app.App.notify] for the full
        documentation for this method.
        """
</file>

</files>
