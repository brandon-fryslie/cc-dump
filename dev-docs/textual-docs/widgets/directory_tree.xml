This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by â‹®---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/widgets/_directory_tree.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by â‹®---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    widgets/
      _directory_tree.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/widgets/_directory_tree.py">
@dataclass
class DirEntry
â‹®----
"""Attaches directory information to a [`DirectoryTree`][textual.widgets.DirectoryTree] node."""
â‹®----
path: Path
"""The path of the directory entry."""
loaded: bool = False
"""Has this been loaded?"""
â‹®----
class DirectoryTree(Tree[DirEntry])
â‹®----
"""A Tree widget that presents files and directories."""
â‹®----
ICON_NODE_EXPANDED = "ðŸ“‚ "
ICON_NODE = "ðŸ“ "
ICON_FILE = "ðŸ“„ "
"""Unicode 'icon' to represent a file."""
â‹®----
COMPONENT_CLASSES: ClassVar[set[str]] = {
"""
    | Class | Description |
    | :- | :- |
    | `directory-tree--extension` | Target the extension of a file name. |
    | `directory-tree--file` | Target files in the directory structure. |
    | `directory-tree--folder` | Target folders in the directory structure. |
    | `directory-tree--hidden` | Target hidden items in the directory structure. |

    See also the [component classes for `Tree`][textual.widgets.Tree.COMPONENT_CLASSES].
    """
â‹®----
DEFAULT_CSS = """
â‹®----
PATH: Callable[[str | Path], Path] = Path
"""Callable that returns a fresh path object."""
â‹®----
class FileSelected(Message)
â‹®----
"""Posted when a file is selected.

        Can be handled using `on_directory_tree_file_selected` in a subclass of
        `DirectoryTree` or in a parent widget in the DOM.
        """
â‹®----
def __init__(self, node: TreeNode[DirEntry], path: Path) -> None
â‹®----
"""Initialise the FileSelected object.

            Args:
                node: The tree node for the file that was selected.
                path: The path of the file that was selected.
            """
â‹®----
"""The tree node of the file that was selected."""
â‹®----
"""The path of the file that was selected."""
â‹®----
@property
        def control(self) -> Tree[DirEntry]
â‹®----
"""The `Tree` that had a file selected."""
â‹®----
class DirectorySelected(Message)
â‹®----
"""Posted when a directory is selected.

        Can be handled using `on_directory_tree_directory_selected` in a
        subclass of `DirectoryTree` or in a parent widget in the DOM.
        """
â‹®----
"""Initialise the DirectorySelected object.

            Args:
                node: The tree node for the directory that was selected.
                path: The path of the directory that was selected.
            """
â‹®----
"""The tree node of the directory that was selected."""
â‹®----
"""The path of the directory that was selected."""
â‹®----
"""The `Tree` that had a directory selected."""
â‹®----
path: var[str | Path] = var["str | Path"](PATH("."), init=False, always_update=True)
"""The path that is the root of the directory tree.

    Note:
        This can be set to either a `str` or a `pathlib.Path` object, but
        the value will always be a `pathlib.Path` object.
    """
â‹®----
"""Initialise the directory tree.

        Args:
            path: Path to directory.
            name: The name of the widget, or None for no name.
            id: The ID of the widget in the DOM, or None for no ID.
            classes: A space-separated list of classes, or None for no classes.
            disabled: Whether the directory tree is disabled or not.
        """
â‹®----
def _add_to_load_queue(self, node: TreeNode[DirEntry]) -> AwaitComplete
â‹®----
"""Add the given node to the load queue.

        The return value can optionally be awaited until the queue is empty.

        Args:
            node: The node to add to the load queue.

        Returns:
            An optionally awaitable object that can be awaited until the
                load queue has finished processing.
        """
â‹®----
def reload(self) -> AwaitComplete
â‹®----
"""Reload the `DirectoryTree` contents.

        Returns:
            An optionally awaitable that ensures the tree has finished reloading.
        """
# Orphan the old queue...
â‹®----
# ... reset the root node ...
processed = self.reload_node(self.root)
# ...and replace the old load with a new one.
â‹®----
def clear_node(self, node: TreeNode[DirEntry]) -> Self
â‹®----
"""Clear all nodes under the given node.

        Returns:
            The `Tree` instance.
        """
â‹®----
"""Clear the subtree and reset the given node.

        Args:
            node: The node to reset.
            label: The label for the node.
            data: Optional data for the node.

        Returns:
            The `Tree` instance.
        """
â‹®----
async def _reload(self, node: TreeNode[DirEntry]) -> None
â‹®----
"""Reloads the subtree rooted at the given node while preserving state.

        After reloading the subtree, nodes that were expanded and still exist
        will remain expanded and the highlighted node will be preserved, if it
        still exists. If it doesn't, highlighting goes up to the first parent
        directory that still exists.

        Args:
            node: The root of the subtree to reload.
        """
â‹®----
# Track nodes that were expanded before reloading.
currently_open: set[Path] = set()
to_check: list[TreeNode[DirEntry]] = [node]
â‹®----
checking = to_check.pop()
â‹®----
# Track node that was highlighted before reloading.
highlighted_path: None | Path = None
â‹®----
highlighted_node = self.get_node_at_line(self.cursor_line)
â‹®----
highlighted_path = highlighted_node.data.path
â‹®----
# Reopen nodes that were expanded and still exist.
to_reopen = [node]
â‹®----
reopening = to_reopen.pop()
â‹®----
content = await self._load_directory(reopening).wait()
â‹®----
# Restore the highlighted path and consider the parents as fallbacks.
looking = [node]
highlight_candidates = set(highlighted_path.parents)
â‹®----
best_found: None | TreeNode[DirEntry] = None
â‹®----
checking = looking.pop()
checking_path = (
â‹®----
best_found = checking
â‹®----
# We need valid lines. Make sure the tree lines have been computed:
_ = self._tree_lines
â‹®----
def reload_node(self, node: TreeNode[DirEntry]) -> AwaitComplete
â‹®----
"""Reload the given node's contents.

        The return value may be awaited to ensure the DirectoryTree has reached
        a stable state and is no longer performing any node reloading (of this node
        or any other nodes).

        Args:
            node: The root of the subtree to reload.

        Returns:
            An optionally awaitable that ensures the subtree has finished reloading.
        """
â‹®----
def validate_path(self, path: str | Path) -> Path
â‹®----
"""Ensure that the path is of the `Path` type.

        Args:
            path: The path to validate.

        Returns:
            The validated Path value.

        Note:
            The result will always be a Python `Path` object, regardless of
            the value given.
        """
â‹®----
async def watch_path(self) -> None
â‹®----
"""Watch for changes to the `path` of the directory tree.

        If the path is changed the directory tree will be repopulated using
        the new value as the root.
        """
has_cursor = self.cursor_node is not None
â‹®----
def process_label(self, label: TextType) -> Text
â‹®----
"""Process a str or Text into a label. May be overridden in a subclass to modify how labels are rendered.

        Args:
            label: Label.

        Returns:
            A Rich Text object.
        """
â‹®----
text_label = Text(label)
â‹®----
text_label = label
first_line = text_label.split()[0]
â‹®----
"""Render a label for the given node.

        Args:
            node: A tree node.
            base_style: The base style of the widget.
            style: The additional style for the label.

        Returns:
            A Rich Text object containing the label.
        """
node_label = node._label.copy()
â‹®----
# If the tree isn't mounted yet we can't use component classes to stylize
# the label fully, so we return early.
â‹®----
prefix = (
â‹®----
text = Text.assemble(prefix, node_label)
â‹®----
def filter_paths(self, paths: Iterable[Path]) -> Iterable[Path]
â‹®----
"""Filter the paths before adding them to the tree.

        Args:
            paths: The paths to be filtered.

        Returns:
            The filtered paths.

        By default this method returns all of the paths provided. To create
        a filtered `DirectoryTree` inherit from it and implement your own
        version of this method.
        """
â‹®----
@staticmethod
    def _safe_is_dir(path: Path) -> bool
â‹®----
"""Safely check if a path is a directory.

        Args:
            path: The path to check.

        Returns:
            `True` if the path is for a directory, `False` if not.
        """
â‹®----
# We may or may not have been looking at a directory, but we
# don't have the rights or permissions to even know that. Best
# we can do, short of letting the error blow up, is assume it's
# not a directory. A possible improvement in here could be to
# have a third state which is "unknown", and reflect that in the
# tree.
â‹®----
def _populate_node(self, node: TreeNode[DirEntry], content: Iterable[Path]) -> None
â‹®----
"""Populate the given tree node with the given directory content.

        Args:
            node: The Tree node to populate.
            content: The collection of `Path` objects to populate the node with.
        """
â‹®----
def _directory_content(self, location: Path, worker: Worker) -> Iterator[Path]
â‹®----
"""Load the content of a given directory.

        Args:
            location: The location to load from.
            worker: The worker that the loading is taking place in.

        Yields:
            Path: An entry within the location.
        """
â‹®----
@work(thread=True, exit_on_error=False)
    def _load_directory(self, node: TreeNode[DirEntry]) -> list[Path]
â‹®----
"""Load the directory contents for a given node.

        Args:
            node: The node to load the directory contents for.

        Returns:
            The list of entries within the directory associated with the node.
        """
â‹®----
path = node.data.path
path = path.expanduser().resolve()
â‹®----
@work()
    async def _loader(self) -> None
â‹®----
"""Background loading queue processor."""
worker = get_current_worker()
â‹®----
# Get the next node that needs loading off the queue. Note that
# this blocks if the queue is empty.
node = await self._load_queue.get()
content: list[Path] = []
â‹®----
cursor_node = self.cursor_node
â‹®----
# Spin up a short-lived thread that will load the content of
# the directory associated with that node.
content = await self._load_directory(node).wait()
â‹®----
# The worker was cancelled, that would suggest we're all
# done here and we should get out of the loader in general.
â‹®----
# This particular worker failed to start. We don't know the
# reason so let's no-op that (for now anyway).
â‹®----
# We're still here and we have directory content, get it into
# the tree.
â‹®----
# Mark this iteration as done.
â‹®----
async def _on_tree_node_expanded(self, event: Tree.NodeExpanded[DirEntry]) -> None
â‹®----
dir_entry = event.node.data
â‹®----
def _on_tree_node_selected(self, event: Tree.NodeSelected[DirEntry]) -> None
</file>

</files>
