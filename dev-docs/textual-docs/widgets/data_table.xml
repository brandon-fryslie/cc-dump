This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/widgets/_data_table.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    widgets/
      _data_table.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/widgets/_data_table.py">
CellCacheKey: TypeAlias = (
LineCacheKey: TypeAlias = (
RowCacheKey: TypeAlias = (
CursorType = Literal["cell", "row", "column", "none"]
"""The valid types of cursors for [`DataTable.cursor_type`][textual.widgets.DataTable.cursor_type]."""
CellType = TypeVar("CellType")
"""Type used for cells in the DataTable."""
⋮----
_EMPTY_TEXT = Text(no_wrap=True, end="")
⋮----
class CellDoesNotExist(Exception)
⋮----
"""The cell key/index was invalid.

    Raised when the coordinates or cell key provided does not exist
    in the DataTable (e.g. out of bounds index, invalid key)"""
⋮----
class RowDoesNotExist(Exception)
⋮----
"""Raised when the row index or row key provided does not exist
    in the DataTable (e.g. out of bounds index, invalid key)"""
⋮----
class ColumnDoesNotExist(Exception)
⋮----
"""Raised when the column index or column key provided does not exist
    in the DataTable (e.g. out of bounds index, invalid key)"""
⋮----
class DuplicateKey(Exception)
⋮----
"""The key supplied already exists.

    Raised when the RowKey or ColumnKey provided already refers to
    an existing row or column in the DataTable. Keys must be unique."""
⋮----
@functools.total_ordering
class StringKey
⋮----
"""An object used as a key in a mapping.

    It can optionally wrap a string,
    and lookups into a map using the object behave the same as lookups using
    the string itself."""
⋮----
value: str | None
⋮----
def __init__(self, value: str | None = None)
⋮----
def __hash__(self)
⋮----
# If a string is supplied, we use the hash of the string. If no string was
# supplied, we use the default hash to ensure uniqueness amongst instances.
⋮----
def __eq__(self, other: object) -> bool
⋮----
# Strings will match Keys containing the same string value.
# Otherwise, you'll need to supply the exact same key object.
⋮----
def __lt__(self, other)
⋮----
def __rich_repr__(self)
⋮----
class RowKey(StringKey)
⋮----
"""Uniquely identifies a row in the DataTable.

    Even if the visual location
    of the row changes due to sorting or other modifications, a key will always
    refer to the same row."""
⋮----
class ColumnKey(StringKey)
⋮----
"""Uniquely identifies a column in the DataTable.

    Even if the visual location
    of the column changes due to sorting or other modifications, a key will always
    refer to the same column."""
⋮----
class CellKey(NamedTuple)
⋮----
"""A unique identifier for a cell in the DataTable.

    A cell key is a `(row_key, column_key)` tuple.

    Even if the cell changes
    visual location (i.e. moves to a different coordinate in the table), this key
    can still be used to retrieve it, regardless of where it currently is."""
⋮----
row_key: RowKey
"""The key of this cell's row."""
column_key: ColumnKey
"""The key of this cell's column."""
⋮----
def _find_newline(string: str, number: int) -> int
⋮----
"""Find newline number n (the nth newline) in a string.

    Args:
        string: The string to search.
        number: The nth newline character to find.

    Returns:
        The index of the nth newline character, or -1 if not found.
    """
⋮----
pos = -1
⋮----
pos = string.find("\n", pos + 1)
⋮----
"""Convert a cell into a Rich renderable for display.

    Args:
        obj: Data for a cell.
        wrap: Enable or disable wrapping inside the cell.
        height: The height of the cell, or `None` to render the entire cell.
            This can be used to short-circuit rendering. e.g. If we know the cell
            has a height of 1, we can render the cell as a single line of text
            without any wrapping.

    Returns:
        A renderable to be displayed which represents the data.
    """
# Get the string which will be displayed in the cell.
possible_markup = False
⋮----
possible_markup = True
content = obj
⋮----
content = f"{obj:.2f}"
⋮----
content = str(obj)
⋮----
# Let's throw away lines which definitely won't appear in the cell
# after wrapping using the height constraint. A cell can only grow
# vertically after wrapping occurs, so this is a safe operation.
trim_position = _find_newline(content, height)
⋮----
content = content[:trim_position]
⋮----
text = Text.from_markup(content, end="")
⋮----
@dataclass
class Column
⋮----
"""Metadata for a column in the DataTable."""
⋮----
key: ColumnKey
label: Text
width: int = 0
content_width: int = 0
auto_width: bool = False
⋮----
def get_render_width(self, data_table: DataTable[Any]) -> int
⋮----
"""Width, in cells, required to render the column with padding included.

        Args:
            data_table: The data table where the column will be rendered.

        Returns:
            The width, in cells, required to render the column with padding included.
        """
⋮----
@dataclass
class Row
⋮----
"""Metadata for a row in the DataTable."""
⋮----
key: RowKey
height: int
label: Text | None = None
auto_height: bool = False
⋮----
class RowRenderables(NamedTuple)
⋮----
"""Container for a row, which contains an optional label and some data cells."""
⋮----
label: RenderableType | None
cells: list[RenderableType]
⋮----
class DataTable(ScrollView, Generic[CellType], can_focus=True)
⋮----
"""A tabular widget that contains data."""
⋮----
ALLOW_SELECT = False
⋮----
BINDINGS: ClassVar[list[BindingType]] = [
"""
    | Key(s) | Description |
    | :- | :- |
    | enter | Select cells under the cursor. |
    | up | Move the cursor up. |
    | down | Move the cursor down. |
    | right | Move the cursor right. |
    | left | Move the cursor left. |
    | pageup | Move one page up. |
    | pagedown | Move one page down. |
    | ctrl+home | Move to the top. |
    | ctrl+end | Move to the bottom. |
    | home | Move to the home position (leftmost column). |
    | end | Move to the end position (rightmost column). |
    """
⋮----
COMPONENT_CLASSES: ClassVar[set[str]] = {
"""
    | Class | Description |
    | :- | :- |
    | `datatable--cursor` | Target the cursor. |
    | `datatable--hover` | Target the cells under the hover cursor. |
    | `datatable--fixed` | Target fixed columns and fixed rows. |
    | `datatable--fixed-cursor` | Target highlighted and fixed columns or header. |
    | `datatable--header` | Target the header of the data table. |
    | `datatable--header-cursor` | Target cells highlighted by the cursor. |
    | `datatable--header-hover` | Target hovered header or row label cells. |
    | `datatable--even-row` | Target even rows (row indices start at 0) if zebra_stripes. |
    | `datatable--odd-row` | Target odd rows (row indices start at 0) if zebra_stripes. |
    """
⋮----
DEFAULT_CSS = """
⋮----
show_header = Reactive(True)
show_row_labels = Reactive(True)
fixed_rows = Reactive(0)
fixed_columns = Reactive(0)
zebra_stripes = Reactive(False)
header_height = Reactive(1)
show_cursor = Reactive(True)
cursor_type: Reactive[CursorType] = Reactive[CursorType]("cell")
"""The type of the cursor of the `DataTable`."""
cell_padding = Reactive(1)
"""Horizontal padding between cells, applied on each side of each cell."""
⋮----
cursor_coordinate: Reactive[Coordinate] = Reactive(
"""Current cursor [`Coordinate`][textual.coordinate.Coordinate].

    This can be set programmatically or changed via the method
    [`move_cursor`][textual.widgets.DataTable.move_cursor].
    """
hover_coordinate: Reactive[Coordinate] = Reactive(
"""The coordinate of the `DataTable` that is being hovered."""
⋮----
class CellHighlighted(Message)
⋮----
"""Posted when the cursor moves to highlight a new cell.

        This is only relevant when the `cursor_type` is `"cell"`.
        It's also posted when the cell cursor is
        re-enabled (by setting `show_cursor=True`), and when the cursor type is
        changed to `"cell"`. Can be handled using `on_data_table_cell_highlighted` in
        a subclass of `DataTable` or in a parent widget in the DOM.
        """
⋮----
"""The data table."""
⋮----
"""The value in the highlighted cell."""
⋮----
"""The coordinate of the highlighted cell."""
⋮----
"""The key for the highlighted cell."""
⋮----
def __rich_repr__(self) -> rich.repr.Result
⋮----
@property
        def control(self) -> DataTable
⋮----
"""Alias for the data table."""
⋮----
class CellSelected(Message)
⋮----
"""Posted by the `DataTable` widget when a cell is selected.

        This is only relevant when the `cursor_type` is `"cell"`. Can be handled using
        `on_data_table_cell_selected` in a subclass of `DataTable` or in a parent
        widget in the DOM.
        """
⋮----
"""The value in the cell that was selected."""
⋮----
"""The coordinate of the cell that was selected."""
⋮----
"""The key for the selected cell."""
⋮----
class RowHighlighted(Message)
⋮----
"""Posted when a row is highlighted.

        This message is only posted when the
        `cursor_type` is set to `"row"`. Can be handled using
        `on_data_table_row_highlighted` in a subclass of `DataTable` or in a parent
        widget in the DOM.
        """
⋮----
"""The y-coordinate of the cursor that highlighted the row."""
⋮----
"""The key of the row that was highlighted."""
⋮----
class RowSelected(Message)
⋮----
"""Posted when a row is selected.

        This message is only posted when the
        `cursor_type` is set to `"row"`. Can be handled using
        `on_data_table_row_selected` in a subclass of `DataTable` or in a parent
        widget in the DOM.
        """
⋮----
"""The y-coordinate of the cursor that made the selection."""
⋮----
"""The key of the row that was selected."""
⋮----
class ColumnHighlighted(Message)
⋮----
"""Posted when a column is highlighted.

        This message is only posted when the
        `cursor_type` is set to `"column"`. Can be handled using
        `on_data_table_column_highlighted` in a subclass of `DataTable` or in a parent
        widget in the DOM.
        """
⋮----
"""The x-coordinate of the column that was highlighted."""
⋮----
"""The key of the column that was highlighted."""
⋮----
class ColumnSelected(Message)
⋮----
"""Posted when a column is selected.

        This message is only posted when the
        `cursor_type` is set to `"column"`. Can be handled using
        `on_data_table_column_selected` in a subclass of `DataTable` or in a parent
        widget in the DOM.
        """
⋮----
"""The x-coordinate of the column that was selected."""
⋮----
"""The key of the column that was selected."""
⋮----
class HeaderSelected(Message)
⋮----
"""Posted when a column header/label is clicked."""
⋮----
"""The key for the column."""
⋮----
"""The index for the column."""
⋮----
"""The text of the label."""
⋮----
class RowLabelSelected(Message)
⋮----
"""Posted when a row label is clicked."""
⋮----
"""Initializes a widget to display tabular data.

        Args:
            show_header: Whether the table header should be visible or not.
            show_row_labels: Whether the row labels should be shown or not.
            fixed_rows: The number of rows, counting from the top, that should be fixed
                and still visible when the user scrolls down.
            fixed_columns: The number of columns, counting from the left, that should be
                fixed and still visible when the user scrolls right.
            zebra_stripes: Enables or disables a zebra effect applied to the background
                color of the rows of the table, where alternate colors are styled
                differently to improve the readability of the table.
            header_height: The height, in number of cells, of the data table header.
            show_cursor: Whether the cursor should be visible when navigating the data
                table or not.
            cursor_foreground_priority: If the data associated with a cell is an
                arbitrary renderable with a set foreground color, this determines whether
                that color is prioritized over the cursor component class or not.
            cursor_background_priority: If the data associated with a cell is an
                arbitrary renderable with a set background color, this determines whether
                that color is prioritized over the cursor component class or not.
            cursor_type: The type of cursor to be used when navigating the data table
                with the keyboard.
            cell_padding: The number of cells added on each side of each column. Setting
                this value to zero will likely make your table very hard to read.
            name: The name of the widget.
            id: The ID of the widget in the DOM.
            classes: The CSS classes for the widget.
            disabled: Whether the widget is disabled or not.
        """
⋮----
"""Contains the cells of the table, indexed by row key and column key.
        The final positioning of a cell on screen cannot be determined solely by this
        structure. Instead, we must check _row_locations and _column_locations to find
        where each cell currently resides in space."""
⋮----
"""Metadata about the columns of the table, indexed by their key."""
⋮----
"""Metadata about the rows of the table, indexed by their key."""
⋮----
# Keep tracking of key -> index for rows/cols. These allow us to retrieve,
# given a row or column key, the index that row or column is currently
# present at, and mean that rows and columns are location independent - they
# can move around without requiring us to modify the underlying data.
⋮----
"""Maps row keys to row indices which represent row order."""
⋮----
"""Maps column keys to column indices which represent column order."""
⋮----
"""For each row (a row can have a height of multiple lines), we maintain a
        cache of the fixed and scrollable lines within that row to minimize how often
        we need to re-render it. """
⋮----
"""Cache for individual cells."""
⋮----
"""Caches row renderables - key is (update_count, row_index)"""
⋮----
"""Cache for lines within rows."""
⋮----
"""Cached y_offset - key is update_count - see y_offsets property for more
        information """
⋮----
"""Caches row ordering - key is (num_rows, update_count)."""
⋮----
"""The pseudo-class state is used as part of cache keys to ensure that, for example,
        when we lose focus on the DataTable, rules which apply to :focus are invalidated
        and we prevent lingering styles."""
⋮----
"""Set to re-calculate dimensions on idle."""
⋮----
"""Tracking newly added rows to be used in calculation of dimensions on idle."""
⋮----
"""Track which cells were updated, so that we can refresh them once on idle."""
⋮----
"""Used to hide the mouse hover cursor when the user uses the keyboard."""
⋮----
"""Number of update (INCLUDING SORT) operations so far. Used for cache invalidation."""
⋮----
"""The header is a special row - not part of the data. Retrieve via this key."""
⋮----
"""The column containing row labels is not part of the data. This key identifies it."""
⋮----
"""Whether or not the user has supplied any rows with labels."""
⋮----
"""The largest content width out of all row labels in the table."""
⋮----
"""Show/hide the header row (the row of column labels)."""
⋮----
"""Show/hide the column containing the labels of rows."""
⋮----
"""The height of the header row (the row of column labels)."""
⋮----
"""The number of rows to fix (prevented from scrolling)."""
⋮----
"""The number of columns to fix (prevented from scrolling)."""
⋮----
"""Apply alternating styles, datatable--even-row and datatable-odd-row, to create a zebra effect, e.g., 
        alternating light and dark backgrounds."""
⋮----
"""Show/hide both the keyboard and hover cursor."""
⋮----
"""Should we prioritize the cursor component class CSS foreground or the renderable foreground
         in the event where a cell contains a renderable with a foreground color."""
⋮----
"""Should we prioritize the cursor component class CSS background or the renderable background
         in the event where a cell contains a renderable with a background color."""
⋮----
"""The type of cursor of the `DataTable`."""
⋮----
@property
    def hover_row(self) -> int
⋮----
"""The index of the row that the mouse cursor is currently hovering above."""
⋮----
@property
    def hover_column(self) -> int
⋮----
"""The index of the column that the mouse cursor is currently hovering above."""
⋮----
@property
    def cursor_row(self) -> int
⋮----
"""The index of the row that the DataTable cursor is currently on."""
⋮----
@property
    def cursor_column(self) -> int
⋮----
"""The index of the column that the DataTable cursor is currently on."""
⋮----
@property
    def row_count(self) -> int
⋮----
"""The number of rows currently present in the DataTable."""
⋮----
@property
    def _y_offsets(self) -> list[tuple[RowKey, int]]
⋮----
"""Contains a 2-tuple for each line (not row!) of the DataTable. Given a
        y-coordinate, we can index into this list to find which row that y-coordinate
        lands on, and the y-offset *within* that row. The length of the returned list
        is therefore the total height of all rows within the DataTable."""
y_offsets: list[tuple[RowKey, int]] = []
⋮----
y_offsets = self._offset_cache[self._update_count]
⋮----
@property
    def _total_row_height(self) -> int
⋮----
"""The total height of all rows within the DataTable"""
⋮----
"""Update the cell identified by the specified row key and column key.

        Args:
            row_key: The key identifying the row.
            column_key: The key identifying the column.
            value: The new value to put inside the cell.
            update_width: Whether to resize the column width to accommodate
                for the new cell content.

        Raises:
            CellDoesNotExist: When the supplied `row_key` and `column_key`
                cannot be found in the table.
        """
⋮----
row_key = RowKey(row_key)
⋮----
column_key = ColumnKey(column_key)
⋮----
# Recalculate widths if necessary
⋮----
"""Update the content inside the cell currently occupying the given coordinate.

        Args:
            coordinate: The coordinate to update the cell at.
            value: The new value to place inside the cell.
            update_width: Whether to resize the column width to accommodate
                for the new cell content.
        """
⋮----
def get_cell(self, row_key: RowKey | str, column_key: ColumnKey | str) -> CellType
⋮----
"""Given a row key and column key, return the value of the corresponding cell.

        Args:
            row_key: The row key of the cell.
            column_key: The column key of the cell.

        Returns:
            The value of the cell identified by the row and column keys.
        """
⋮----
cell_value = self._data[row_key][column_key]
⋮----
def get_cell_at(self, coordinate: Coordinate) -> CellType
⋮----
"""Get the value from the cell occupying the given coordinate.

        Args:
            coordinate: The coordinate to retrieve the value from.

        Returns:
            The value of the cell at the coordinate.

        Raises:
            CellDoesNotExist: If there is no cell with the given coordinate.
        """
⋮----
"""Given a row key and column key, return the corresponding cell coordinate.

        Args:
            row_key: The row key of the cell.
            column_key: The column key of the cell.

        Returns:
            The current coordinate of the cell identified by the row and column keys.

        Raises:
            CellDoesNotExist: If the specified cell does not exist.
        """
⋮----
row_index = self._row_locations.get(row_key)
column_index = self._column_locations.get(column_key)
⋮----
def get_row(self, row_key: RowKey | str) -> list[CellType]
⋮----
"""Get the values from the row identified by the given row key.

        Args:
            row_key: The key of the row.

        Returns:
            A list of the values contained within the row.

        Raises:
            RowDoesNotExist: When there is no row corresponding to the key.
        """
⋮----
cell_mapping: dict[ColumnKey, CellType] = self._data.get(row_key, {})
ordered_row: list[CellType] = [
⋮----
def get_row_at(self, row_index: int) -> list[CellType]
⋮----
"""Get the values from the cells in a row at a given index. This will
        return the values from a row based on the rows _current position_ in
        the table.

        Args:
            row_index: The index of the row.

        Returns:
            A list of the values contained in the row.

        Raises:
            RowDoesNotExist: If there is no row with the given index.
        """
⋮----
row_key = self._row_locations.get_key(row_index)
⋮----
def get_row_index(self, row_key: RowKey | str) -> int
⋮----
"""Return the current index for the row identified by row_key.

        Args:
            row_key: The row key to find the current index of.

        Returns:
            The current index of the specified row key.

        Raises:
            RowDoesNotExist: If the row key does not exist.
        """
⋮----
def get_column(self, column_key: ColumnKey | str) -> Iterable[CellType]
⋮----
"""Get the values from the column identified by the given column key.

        Args:
            column_key: The key of the column.

        Returns:
            A generator which yields the cells in the column.

        Raises:
            ColumnDoesNotExist: If there is no column corresponding to the key.
        """
⋮----
data = self._data
⋮----
row_key = row_metadata.key
⋮----
def get_column_at(self, column_index: int) -> Iterable[CellType]
⋮----
"""Get the values from the column at a given index.

        Args:
            column_index: The index of the column.

        Returns:
            A generator which yields the cells in the column.

        Raises:
            ColumnDoesNotExist: If there is no column with the given index.
        """
⋮----
column_key = self._column_locations.get_key(column_index)
⋮----
def get_column_index(self, column_key: ColumnKey | str) -> int
⋮----
"""Return the current index for the column identified by column_key.

        Args:
            column_key: The column key to find the current index of.

        Returns:
            The current index of the specified column key.

        Raises:
            ColumnDoesNotExist: If the column key does not exist.
        """
⋮----
def _clear_caches(self) -> None
⋮----
def get_row_height(self, row_key: RowKey) -> int
⋮----
"""Given a row key, return the height of that row in terminal cells.

        Args:
            row_key: The key of the row.

        Returns:
            The height of the row, measured in terminal character cells.
        """
⋮----
def notify_style_update(self) -> None
⋮----
def _on_resize(self, _: events.Resize) -> None
⋮----
def watch_show_cursor(self, show_cursor: bool) -> None
⋮----
# When we re-enable the cursor, apply highlighting and
# post the appropriate [Row|Column|Cell]Highlighted event.
⋮----
def watch_show_header(self, show: bool) -> None
⋮----
height_change = self.header_height if show else -self.header_height
⋮----
def watch_show_row_labels(self, show: bool) -> None
⋮----
column_width = self._label_column.get_render_width(self)
width_change = column_width if show else -column_width
⋮----
def watch_fixed_rows(self) -> None
⋮----
def watch_fixed_columns(self) -> None
⋮----
def watch_zebra_stripes(self) -> None
⋮----
def watch_header_height(self) -> None
⋮----
def validate_cell_padding(self, cell_padding: int) -> int
⋮----
def watch_cell_padding(self, old_padding: int, new_padding: int) -> None
⋮----
# A single side of a single cell will have its width changed by (new - old),
# so the total width change is double that per column, times the number of
# columns for the whole data table.
width_change = 2 * (new_padding - old_padding) * len(self.columns)
⋮----
def watch_hover_coordinate(self, old: Coordinate, value: Coordinate) -> None
⋮----
# Refresh the old and the new cell, and post the appropriate
# message to tell users of the newly highlighted row/cell/column.
⋮----
"""Move the cursor to the given position.

        Example:
            ```py
            datatable = app.query_one(DataTable)
            datatable.move_cursor(row=4, column=6)
            # datatable.cursor_coordinate == Coordinate(4, 6)
            datatable.move_cursor(row=3)
            # datatable.cursor_coordinate == Coordinate(3, 6)
            ```

        Args:
            row: The new row to move the cursor to.
            column: The new column to move the cursor to.
            animate: Whether to animate the change of coordinates.
            scroll: Scroll the cursor into view after moving.
        """
⋮----
cursor_row = row
⋮----
cursor_column = column
destination = Coordinate(cursor_row, cursor_column)
⋮----
# Scroll the cursor after refresh to ensure the virtual height
# (calculated in on_idle) has settled. If we tried to scroll before
# the virtual size has been set, then it might fail if we added a bunch
# of rows then tried to immediately move the cursor.
# We do this before setting `cursor_coordinate` because its watcher will also
# schedule a call to `_scroll_cursor_into_view` without optionally animating.
⋮----
def _highlight_coordinate(self, coordinate: Coordinate) -> None
⋮----
"""Apply highlighting to the cell at the coordinate, and post event."""
⋮----
cell_value = self.get_cell_at(coordinate)
⋮----
# The cell may not exist e.g. when the table is cleared.
# In that case, there's nothing for us to do here.
⋮----
cell_key = self.coordinate_to_cell_key(coordinate)
⋮----
def coordinate_to_cell_key(self, coordinate: Coordinate) -> CellKey
⋮----
"""Return the key for the cell currently occupying this coordinate.

        Args:
            coordinate: The coordinate to exam the current cell key of.

        Returns:
            The key of the cell currently occupying this coordinate.

        Raises:
            CellDoesNotExist: If the coordinate is not valid.
        """
⋮----
def _highlight_row(self, row_index: int) -> None
⋮----
"""Apply highlighting to the row at the given index, and post event."""
⋮----
is_valid_row = row_index < len(self._data)
⋮----
def _highlight_column(self, column_index: int) -> None
⋮----
"""Apply highlighting to the column at the given index, and post event."""
⋮----
def validate_cursor_coordinate(self, value: Coordinate) -> Coordinate
⋮----
def _clamp_cursor_coordinate(self, coordinate: Coordinate) -> Coordinate
⋮----
"""Clamp a coordinate such that it falls within the boundaries of the table."""
⋮----
row = clamp(row, 0, self.row_count - 1)
column = clamp(column, 0, len(self.columns) - 1)
⋮----
def watch_cursor_type(self, old: str, new: str) -> None
⋮----
# Refresh cells that were previously impacted by the cursor
# but may no longer be.
⋮----
def _highlight_cursor(self) -> None
⋮----
"""Applies the appropriate highlighting and raises the appropriate
        [Row|Column|Cell]Highlighted event for the given cursor coordinate
        and cursor type."""
⋮----
cursor_type = self.cursor_type
# Apply the highlighting to the newly relevant cells
⋮----
@property
    def _row_label_column_width(self) -> int
⋮----
"""The render width of the column containing row labels"""
⋮----
def _update_column_widths(self, updated_cells: set[CellKey]) -> None
⋮----
"""Update the widths of the columns based on the newly updated cell widths."""
⋮----
column = self.columns.get(column_key)
row = self.rows.get(row_key)
⋮----
console = self.app.console
label_width = measure(console, column.label, 1)
content_width = column.content_width
⋮----
render_height = row.height
new_content_width = measure(
⋮----
cells_in_column = self.get_column(column_key)
cell_widths = [
⋮----
def _update_dimensions(self, new_rows: Iterable[RowKey]) -> None
⋮----
"""Called to recalculate the virtual (scrollable) size.

        This recomputes column widths and then checks if any of the new rows need
        to have their height computed.

        Args:
            new_rows: The new rows that will affect the `DataTable` dimensions.
        """
⋮----
auto_height_rows: list[tuple[int, Row, list[RenderableType]]] = []
⋮----
# The row could have been removed before on_idle was called, so we
# need to be quite defensive here and don't assume that the row exists.
⋮----
label_content_width = measure(console, row_label, 1) if row_label else 0
⋮----
content_width = measure(console, renderable, 1)
⋮----
# If there are rows that need to have their height computed, render them correctly
# so that we can cache this rendering for later.
⋮----
render_cell = self._render_cell  # This method renders & caches.
should_highlight = self._should_highlight
⋮----
cursor_location = self.cursor_coordinate
hover_location = self.hover_coordinate
base_style = self.rich_style
fixed_style = self.get_component_styles(
ordered_columns = self.ordered_columns
fixed_columns = self.fixed_columns
⋮----
height = 0
row_style = self._get_row_style(row_index, base_style)
⋮----
# As we go through the cells, save their rendering, height, and
# column width. After we compute the height of the row, go over the cells
# that were rendered with the wrong height and append the missing padding.
rendered_cells: list[tuple[SegmentLines, int, int]] = []
⋮----
style = fixed_style if column_index < fixed_columns else row_style
cell_location = Coordinate(row_index, column_index)
rendered_cell = render_cell(
cell_height = len(rendered_cell)
⋮----
height = max(height, cell_height)
⋮----
# Do surgery on the cache for cells that were rendered with the incorrect
# height during the first pass.
⋮----
first_line_space_style = cell_renderable[0][0].style
⋮----
data_cells_width = sum(
total_width = data_cells_width + self._row_label_column_width
header_height = self.header_height if self.show_header else 0
⋮----
def _get_cell_region(self, coordinate: Coordinate) -> Region
⋮----
"""Get the region of the cell at the given spatial coordinate."""
⋮----
row = self.rows[row_key]
⋮----
# The x-coordinate of a cell is the sum of widths of the data cells to the left
# plus the width of the render width of the longest row label.
x = (
⋮----
width = self.columns[column_key].get_render_width(self)
height = row.height
y = sum(ordered_row.height for ordered_row in self.ordered_rows[:row_index])
⋮----
cell_region = Region(x, y, width, height)
⋮----
def _get_row_region(self, row_index: int) -> Region
⋮----
"""Get the region of the row at the given index."""
⋮----
rows = self.rows
⋮----
row = rows[row_key]
row_width = (
⋮----
row_region = Region(0, y, max(self.size.width, row_width), row.height)
⋮----
def _get_column_region(self, column_index: int) -> Region
⋮----
"""Get the region of the column at the given index."""
⋮----
columns = self.columns
⋮----
width = columns[column_key].get_render_width(self)
⋮----
height = self._total_row_height + header_height
full_column_region = Region(x, 0, width, height)
⋮----
def clear(self, columns: bool = False) -> Self
⋮----
"""Clear the table.

        Args:
            columns: Also clear the columns.

        Returns:
            The `DataTable` instance.
        """
⋮----
"""Add a column to the table.

        Args:
            label: A str or Text object containing the label (shown top of column).
            width: Width of the column in cells or None to fit content.
            key: A key which uniquely identifies this column.
                If None, it will be generated for you.
            default: The  value to insert into pre-existing rows.

        Returns:
            Uniquely identifies this column. Can be used to retrieve this column
                regardless of its current location in the DataTable (it could have moved
                after being added due to sorting/insertion/deletion of other columns).
        """
column_key = ColumnKey(key)
⋮----
column_index = len(self.columns)
label = Text.from_markup(label) if isinstance(label, str) else label
content_width = measure(self.app.console, label, 1)
⋮----
column = Column(
⋮----
# Update pre-existing rows to account for the new column.
⋮----
"""Add a row at the bottom of the DataTable.

        Args:
            *cells: Positional arguments should contain cell data.
            height: The height of a row (in lines). Use `None` to auto-detect the optimal
                height.
            key: A key which uniquely identifies this row. If None, it will be generated
                for you and returned.
            label: The label for the row. Will be displayed to the left if supplied.

        Returns:
            Unique identifier for this row. Can be used to retrieve this row regardless
                of its current location in the DataTable (it could have moved after
                being added due to sorting or insertion/deletion of other rows).
        """
row_key = RowKey(key)
⋮----
# TODO: If there are no columns: do we generate them here?
#  If we don't do this, users will be required to call add_column(s)
#  Before they call add_row.
⋮----
row_index = self.row_count
# Map the key of this row to its current index
⋮----
label = Text.from_markup(label, end="") if isinstance(label, str) else label
⋮----
# Rows with auto-height get a height of 0 because 1) we need an integer height
# to do some intermediate computations and 2) because 0 doesn't impact the data
# table while we don't figure out how tall this row is.
⋮----
# If a position has opened for the cursor to appear, where it previously
# could not (e.g. when there's no data in the table), then a highlighted
# event is posted, since there's now a highlighted cell when there wasn't
# before.
cell_now_available = self.row_count == 1 and len(self.columns) > 0
visible_cursor = self.show_cursor and self.cursor_type != "none"
⋮----
"""Add multiple columns to the DataTable.

        Args:
            *columns: Column specifications. Each can be either:
                - A string or Text object (label only, auto-generated key)
                - A tuple of (label, key) for manual key control

        Returns:
            A list of the keys for the columns that were added. See
                the `add_column` method docstring for more information on how
                these keys are used.

        Examples:
            ```python
            # Add columns with auto-generated keys
            keys = table.add_columns("Name", "Age", "City")

            # Add columns with manual keys
            keys = table.add_columns(
                ("Name", "name_col"),
                ("Age", "age_col"),
                "City"  # Mixed with auto-generated key
            )
            ```
        """
column_keys = []
⋮----
column_key = self.add_column(label, width=None, key=key)
⋮----
column_key = self.add_column(column, width=None)
⋮----
def add_rows(self, rows: Iterable[Iterable[CellType]]) -> list[RowKey]
⋮----
"""Add a number of rows at the bottom of the DataTable.

        Args:
            rows: Iterable of rows. A row is an iterable of cells.

        Returns:
            A list of the keys for the rows that were added. See
                the `add_row` method docstring for more information on how
                these keys are used.
        """
row_keys = []
⋮----
row_key = self.add_row(*row)
⋮----
def remove_row(self, row_key: RowKey | str) -> None
⋮----
"""Remove a row (identified by a key) from the DataTable.

        Args:
            row_key: The key identifying the row to remove.

        Raises:
            RowDoesNotExist: If the row key does not exist.
        """
⋮----
index_to_delete = self._row_locations.get(row_key)
new_row_locations = TwoWayDict({})
⋮----
row_index = self._row_locations.get(row_location_key)
⋮----
# Prevent the removed cells from triggering dimension updates
⋮----
def remove_column(self, column_key: ColumnKey | str) -> None
⋮----
"""Remove a column (identified by a key) from the DataTable.

        Args:
            column_key: The key identifying the column to remove.

        Raises:
            ColumnDoesNotExist: If the column key does not exist.
        """
⋮----
index_to_delete = self._column_locations.get(column_key)
new_column_locations = TwoWayDict({})
⋮----
column_index = self._column_locations.get(column_location_key)
⋮----
async def _on_idle(self, _: events.Idle) -> None
⋮----
"""Runs when the message pump is empty.

        We use this for some expensive calculations like re-computing dimensions of the
        whole DataTable and re-computing column widths after some cells
        have been updated. This is more efficient in the case of high
        frequency updates, ensuring we only do expensive computations once."""
⋮----
# Cell contents have already been updated at this point.
# Now we only need to worry about measuring column widths.
updated_cells = self._updated_cells.copy()
⋮----
# Add the new rows *before* updating the column widths, since
# cells in a new row may influence the final width of a column.
# Only then can we compute optimal height of rows with "auto" height.
⋮----
new_rows = self._new_rows.copy()
⋮----
def refresh_coordinate(self, coordinate: Coordinate) -> Self
⋮----
"""Refresh the cell at a coordinate.

        Args:
            coordinate: The coordinate to refresh.

        Returns:
            The `DataTable` instance.
        """
⋮----
region = self._get_cell_region(coordinate)
⋮----
def refresh_row(self, row_index: int) -> Self
⋮----
"""Refresh the row at the given index.

        Args:
            row_index: The index of the row to refresh.

        Returns:
            The `DataTable` instance.
        """
⋮----
region = self._get_row_region(row_index)
⋮----
def refresh_column(self, column_index: int) -> Self
⋮----
"""Refresh the column at the given index.

        Args:
            column_index: The index of the column to refresh.

        Returns:
            The `DataTable` instance.
        """
⋮----
region = self._get_column_region(column_index)
⋮----
def _refresh_region(self, region: Region) -> Self
⋮----
"""Refresh a region of the DataTable, if it's visible within the window.

        This method will translate the region to account for scrolling.

        Returns:
            The `DataTable` instance.
        """
⋮----
region = region.translate(-self.scroll_offset)
⋮----
def is_valid_row_index(self, row_index: int) -> bool
⋮----
"""Return a boolean indicating whether the row_index is within table bounds.

        Args:
            row_index: The row index to check.

        Returns:
            True if the row index is within the bounds of the table.
        """
⋮----
def is_valid_column_index(self, column_index: int) -> bool
⋮----
"""Return a boolean indicating whether the column_index is within table bounds.

        Args:
            column_index: The column index to check.

        Returns:
            True if the column index is within the bounds of the table.
        """
⋮----
def is_valid_coordinate(self, coordinate: Coordinate) -> bool
⋮----
"""Return a boolean indicating whether the given coordinate is valid.

        Args:
            coordinate: The coordinate to validate.

        Returns:
            True if the coordinate is within the bounds of the table.
        """
⋮----
@property
    def ordered_columns(self) -> list[Column]
⋮----
"""The list of Columns in the DataTable, ordered as they appear on screen."""
column_indices = range(len(self.columns))
column_keys = [
ordered_columns = [self.columns[key] for key in column_keys]
⋮----
@property
    def ordered_rows(self) -> list[Row]
⋮----
"""The list of Rows in the DataTable, ordered as they appear on screen."""
num_rows = self.row_count
update_count = self._update_count
cache_key = (num_rows, update_count)
⋮----
ordered_rows = self._ordered_row_cache[cache_key]
⋮----
row_indices = range(num_rows)
ordered_rows = []
⋮----
@property
    def _should_render_row_labels(self) -> bool
⋮----
"""Whether row labels should be rendered or not."""
⋮----
def _get_row_renderables(self, row_index: int) -> RowRenderables
⋮----
"""Get renderables for the row currently at the given row index. The renderables
        returned here have already been passed through the default_cell_formatter.

        Args:
            row_index: Index of the row.

        Returns:
            A RowRenderables containing the optional label and the rendered cells.
        """
⋮----
cache_key = (update_count, row_index)
⋮----
row_renderables = self._row_renderable_cache[cache_key]
⋮----
row_renderables = self._compute_row_renderables(row_index)
⋮----
def _compute_row_renderables(self, row_index: int) -> RowRenderables
⋮----
"""Actual computation for _get_row_renderables"""
⋮----
header_row: list[RenderableType] = [
# This is the cell where header and row labels intersect
⋮----
ordered_row = self.get_row_at(row_index)
⋮----
row_metadata = self.rows.get(row_key)
⋮----
formatted_row_cells: list[RenderableType] = [
⋮----
label = None
⋮----
label = (
⋮----
"""Render the given cell.

        Args:
            row_index: Index of the row.
            column_index: Index of the column.
            base_style: Style to apply.
            width: Width of the cell.
            cursor: Is this cell affected by cursor highlighting?
            hover: Is this cell affected by hover cursor highlighting?

        Returns:
            A list of segments per line.
        """
is_header_cell = row_index == -1
is_row_label_cell = column_index == -1
⋮----
is_fixed_style_cell = (
⋮----
row_key = self._header_row_key
⋮----
cell_cache_key: CellCacheKey = (
⋮----
cell = row_label if row_label is not None else ""
⋮----
cell = row_cells[column_index]
⋮----
row_height = self.header_height
options = self.app.console_options.update_dimensions(width, row_height)
⋮----
# If an auto-height row hasn't had its height calculated, we don't fix
# the value for `height` so that we can measure the height of the cell.
⋮----
row_height = 0
options = self.app.console_options.update_width(width)
⋮----
row_height = row.height
options = self.app.console_options.update_dimensions(
⋮----
# If the row height is explicitly set to 1, then we don't wrap.
⋮----
options = options.update(no_wrap=True)
⋮----
lines = self.app.console.render_lines(
⋮----
"""Auxiliary method to compute styles used to render a given cell.

        Args:
            is_header_cell: Is this a cell from a header?
            is_row_label_cell: Is this the label of any given row?
            is_fixed_style_cell: Should this cell be styled like a fixed cell?
            hover: Does this cell have the hover pseudo class?
            cursor: Is this cell covered by the cursor?
            show_cursor: Do we want to show the cursor in the data table?
            show_hover_cursor: Do we want to show the mouse hover when using the keyboard
                to move the cursor?
            has_css_foreground_priority: `self.cursor_foreground_priority == "css"`?
            has_css_background_priority: `self.cursor_background_priority == "css"`?
        """
get_component = self.get_component_rich_style
component_style = Style()
⋮----
# Apply subtle variation in style for the header/label (blue background by
# default) rows and columns affected by the cursor, to ensure we can
# still differentiate between the labels and the data.
⋮----
cursor_style = get_component("datatable--cursor")
⋮----
post_foreground = (
post_background = (
⋮----
"""Render a single line from a row in the DataTable.

        Args:
            row_key: The identifying key for this row.
            line_no: Line number (y-coordinate) within row. 0 is the first strip of
                cells in the row, line_no=1 is the next line in the row, and so on...
            base_style: Base style of row.
            cursor_location: The location of the cursor in the DataTable.
            hover_location: The location of the hover cursor in the DataTable.

        Returns:
            Lines for fixed cells, and Lines for scrollable cells.
        """
⋮----
show_cursor = self.show_cursor
⋮----
cache_key = (
⋮----
render_cell = self._render_cell
header_style = self.get_component_styles("datatable--header").rich_style
⋮----
row_index = -1
⋮----
# If the row has a label, add it to fixed_row here with correct style.
fixed_row = []
⋮----
# The width of the row label is updated again on idle
cell_location = Coordinate(row_index, -1)
label_cell_lines = render_cell(
⋮----
fixed_style = header_style  # We use the header style either way.
⋮----
fixed_style = self.get_component_styles("datatable--fixed").rich_style
⋮----
fixed_cell_lines = render_cell(
⋮----
scrollable_row = []
⋮----
cell_lines = render_cell(
⋮----
# Extending the styling out horizontally to fill the container
widget_width = self.size.width
table_width = (
remaining_space = max(0, widget_width - table_width)
background_color = self.background_colors[1]
⋮----
extend_style = row_style + extend_style
⋮----
# TODO: This should really be in a component class
faded_color = Color.from_rich_color(row_style.bgcolor).blend(
extend_style = Style.from_color(
⋮----
extend_style = Style.from_color(row_style.color, row_style.bgcolor)
⋮----
row_pair = (fixed_row, scrollable_row)
⋮----
def _get_offsets(self, y: int) -> tuple[RowKey, int]
⋮----
"""Get row key and line offset for a given line.

        Args:
            y: Y coordinate relative to DataTable top.

        Returns:
            Row key and line (y) offset within cell.
        """
header_height = self.header_height
y_offsets = self._y_offsets
⋮----
def _render_line(self, y: int, x1: int, x2: int, base_style: Style) -> Strip
⋮----
"""Render a (possibly cropped) line into a Strip (a list of segments
            representing a horizontal line).

        Args:
            y: Y coordinate of line
            x1: X start crop.
            x2: X end crop (exclusive).
            base_style: Style to apply to line.

        Returns:
            The Strip which represents this cropped line.
        """
⋮----
width = self.size.width
⋮----
fixed_width = sum(
⋮----
fixed_line: list[Segment] = list(chain.from_iterable(fixed)) if fixed else []
scrollable_line: list[Segment] = list(chain.from_iterable(scrollable))
⋮----
segments = fixed_line + line_crop(scrollable_line, x1 + fixed_width, x2, width)
strip = Strip(segments).adjust_cell_length(width, base_style).simplify()
⋮----
def render_lines(self, crop: Region) -> list[Strip]
⋮----
def render_line(self, y: int) -> Strip
⋮----
fixed_row_keys: list[RowKey] = [
⋮----
fixed_rows_height = sum(
⋮----
"""Determine if the given cell should be highlighted because of the cursor.

        This auxiliary method takes the cursor position and type into account when
        determining whether the cell should be highlighted.

        Args:
            cursor: The current position of the cursor.
            target_cell: The cell we're checking for the need to highlight.
            type_of_cursor: The type of cursor that is currently active.

        Returns:
            Whether or not the given cell should be highlighted.
        """
⋮----
def _get_row_style(self, row_index: int, base_style: Style) -> Style
⋮----
"""Gets the Style that should be applied to the row at the given index.

        Args:
            row_index: The index of the row to style.
            base_style: The base style to use by default.

        Returns:
            The appropriate style.
        """
⋮----
row_style = self.get_component_styles("datatable--header").rich_style
⋮----
row_style = self.get_component_styles("datatable--fixed").rich_style
⋮----
component_row_style = (
row_style = self.get_component_styles(component_row_style).rich_style
⋮----
row_style = base_style
⋮----
def _on_mouse_move(self, event: events.MouseMove)
⋮----
"""If the hover cursor is visible, display it by extracting the row
        and column metadata from the segments present in the cells."""
⋮----
meta = event.style.meta
⋮----
def _on_leave(self, _: events.Leave) -> None
⋮----
def _get_fixed_offset(self) -> Spacing
⋮----
"""Calculate the "fixed offset", that is the space to the top and left
        that is occupied by fixed rows and columns respectively. Fixed rows and columns
        are rows and columns that do not participate in scrolling."""
top = self.header_height if self.show_header else 0
⋮----
left = (
⋮----
"""Sort the rows in the `DataTable` by one or more column keys or a
        key function (or other callable). If both columns and a key function
        are specified, only data from those columns will sent to the key function.

        Args:
            columns: One or more columns to sort by the values in.
            key: A function (or other callable) that returns a key to
                use for sorting purposes.
            reverse: If True, the sort order will be reversed.

        Returns:
            The `DataTable` instance.
        """
⋮----
def key_wrapper(row: tuple[RowKey, dict[ColumnKey | str, CellType]]) -> Any
⋮----
result = itemgetter(*columns)(row_data)
⋮----
result = tuple(row_data.values())
⋮----
ordered_rows = sorted(
⋮----
def _scroll_cursor_into_view(self, animate: bool = False) -> None
⋮----
"""When the cursor is at a boundary of the DataTable and moves out
        of view, this method handles scrolling to ensure it remains visible."""
fixed_offset = self._get_fixed_offset()
⋮----
region = Region(int(self.scroll_x) + left, y, width - left, height)
⋮----
region = Region(x, int(self.scroll_y) + top, width, height - top)
⋮----
region = self._get_cell_region(self.cursor_coordinate)
⋮----
def _set_hover_cursor(self, active: bool) -> None
⋮----
"""Set whether the hover cursor (the faint cursor you see when you
        hover the mouse cursor over a cell) is visible or not. Typically,
        when you interact with the keyboard, you want to switch the hover
        cursor off.

        Args:
            active: Display the hover cursor.
        """
⋮----
async def _on_click(self, event: events.Click) -> None
⋮----
row_index = meta["row"]
column_index = meta["column"]
is_header_click = self.show_header and row_index == -1
is_row_label_click = self.show_row_labels and column_index == -1
⋮----
# Header clicks work even if cursor is off, and doesn't move the cursor.
column = self.ordered_columns[column_index]
message = DataTable.HeaderSelected(
⋮----
row = self.ordered_rows[row_index]
message = DataTable.RowLabelSelected(
⋮----
# Only post selection events if there is a visible row/col/cell cursor.
new_coordinate = Coordinate(row_index, column_index)
highlight_click = new_coordinate == self.cursor_coordinate
⋮----
def action_page_down(self) -> None
⋮----
"""Move the cursor one page down."""
⋮----
height = self.scrollable_content_region.height - (
⋮----
# Determine how many rows constitutes a "page"
offset = 0
rows_to_scroll = 0
⋮----
target_row = row_index + rows_to_scroll - 1
⋮----
def action_page_up(self) -> None
⋮----
"""Move the cursor one page up."""
⋮----
target_row = row_index - rows_to_scroll + 1
⋮----
def action_page_left(self) -> None
⋮----
"""Move the cursor one page left."""
⋮----
def action_page_right(self) -> None
⋮----
"""Move the cursor one page right."""
⋮----
def action_scroll_top(self) -> None
⋮----
"""Move the cursor and scroll to the top."""
⋮----
def action_scroll_bottom(self) -> None
⋮----
"""Move the cursor and scroll to the bottom."""
⋮----
def action_scroll_home(self) -> None
⋮----
"""Move the cursor and scroll to the leftmost column."""
⋮----
def action_scroll_end(self) -> None
⋮----
"""Move the cursor and scroll to the rightmost column."""
⋮----
def action_cursor_up(self) -> None
⋮----
# If the cursor doesn't move up (e.g. column cursor can't go up),
# then ensure that we instead scroll the DataTable.
⋮----
def action_cursor_down(self) -> None
⋮----
def action_cursor_right(self) -> None
⋮----
def action_cursor_left(self) -> None
⋮----
def action_select_cursor(self) -> None
⋮----
def _post_selected_message(self)
⋮----
"""Post the appropriate message for a selection based on the `cursor_type`."""
cursor_coordinate = self.cursor_coordinate
⋮----
cell_key = self.coordinate_to_cell_key(cursor_coordinate)
</file>

</files>
