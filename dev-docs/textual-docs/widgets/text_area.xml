This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/widgets/_text_area.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    widgets/
      _text_area.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/widgets/_text_area.py">
_OPENING_BRACKETS = {"{": "}", "[": "]", "(": ")"}
_CLOSING_BRACKETS = {v: k for k, v in _OPENING_BRACKETS.items()}
_TREE_SITTER_PATH = Path(__file__).parent / "../tree-sitter/"
_HIGHLIGHTS_PATH = _TREE_SITTER_PATH / "highlights/"
⋮----
StartColumn = int
EndColumn = Optional[int]
HighlightName = str
Highlight = Tuple[StartColumn, EndColumn, HighlightName]
"""A tuple representing a syntax highlight within one line."""
⋮----
BUILTIN_LANGUAGES = [
"""Languages that are included in the `syntax` extras."""
⋮----
class ThemeDoesNotExist(Exception)
⋮----
"""Raised when the user tries to use a theme which does not exist.
    This means a theme which is not builtin, or has not been registered.
    """
⋮----
class LanguageDoesNotExist(Exception)
⋮----
"""Raised when the user tries to use a language which does not exist.
    This means a language which is not builtin, or has not been registered.
    """
⋮----
@dataclass
class TextAreaLanguage
⋮----
"""A container for a language which has been registered with the TextArea."""
⋮----
name: str
"""The name of the language"""
⋮----
language: "Language" | None
"""The tree-sitter language object if that has been overridden, or None if it is a built-in language."""
⋮----
highlight_query: str
"""The tree-sitter highlight query to use for syntax highlighting."""
⋮----
class TextArea(ScrollView)
⋮----
DEFAULT_CSS = """\
⋮----
COMPONENT_CLASSES: ClassVar[set[str]] = {
"""
    `TextArea` offers some component classes which can be used to style aspects of the widget.

    Note that any attributes provided in the chosen `TextAreaTheme` will take priority here.

    | Class | Description |
    | :- | :- |
    | `text-area--cursor` | Target the cursor. |
    | `text-area--gutter` | Target the gutter (line number column). |
    | `text-area--cursor-gutter` | Target the gutter area of the line the cursor is on. |
    | `text-area--cursor-line` | Target the line the cursor is on. |
    | `text-area--selection` | Target the current selection. |
    | `text-area--matching-bracket` | Target matching brackets. |
    | `text-area--suggestion` | Target the text set in the `suggestion` reactive. |
    | `text-area--placeholder` | Target the placeholder text. |
    """
⋮----
BINDINGS = [
⋮----
# Cursor movement
⋮----
# Making selections (generally holding the shift key and moving cursor)
⋮----
# Shortcut ways of making selections
# Binding("f5", "select_word", "select word", show=False),
⋮----
# Deletion
⋮----
"""
    | Key(s)                 | Description                                  |
    | :-                     | :-                                           |
    | up                     | Move the cursor up.                          |
    | down                   | Move the cursor down.                        |
    | left                   | Move the cursor left.                        |
    | ctrl+left              | Move the cursor to the start of the word.    |
    | ctrl+shift+left        | Move the cursor to the start of the word and select.    |
    | right                  | Move the cursor right.                       |
    | ctrl+right             | Move the cursor to the end of the word.      |
    | ctrl+shift+right       | Move the cursor to the end of the word and select.      |
    | home,ctrl+a            | Move the cursor to the start of the line.    |
    | end,ctrl+e             | Move the cursor to the end of the line.      |
    | shift+home             | Move the cursor to the start of the line and select.      |
    | shift+end              | Move the cursor to the end of the line and select.      |
    | pageup                 | Move the cursor one page up.                 |
    | pagedown               | Move the cursor one page down.               |
    | shift+up               | Select while moving the cursor up.           |
    | shift+down             | Select while moving the cursor down.         |
    | shift+left             | Select while moving the cursor left.         |
    | shift+right            | Select while moving the cursor right.        |
    | backspace              | Delete character to the left of cursor.      |
    | ctrl+w                 | Delete from cursor to start of the word.     |
    | delete,ctrl+d          | Delete character to the right of cursor.     |
    | ctrl+f                 | Delete from cursor to end of the word.       |
    | ctrl+shift+k           | Delete the current line.                     |
    | ctrl+u                 | Delete from cursor to the start of the line. |
    | ctrl+k                 | Delete from cursor to the end of the line.   |
    | f6                     | Select the current line.                     |
    | f7                     | Select all text in the document.             |
    | ctrl+z                 | Undo.                                        |
    | ctrl+y                 | Redo.                                        |
    | ctrl+x                 | Cut selection or line if no selection.       |
    | ctrl+c                 | Copy selection to clipboard.                 |
    | ctrl+v                 | Paste from clipboard.                        |
    """
⋮----
language: Reactive[str | None] = reactive(None, always_update=True, init=False)
"""The language to use.

    This must be set to a valid, non-None value for syntax highlighting to work.

    If the value is a string, a built-in language parser will be used if available.

    If you wish to use an unsupported language, you'll have to register
    it first using  [`TextArea.register_language`][textual.widgets._text_area.TextArea.register_language].
    """
⋮----
theme: Reactive[str] = reactive("css", always_update=True, init=False)
"""The name of the theme to use.

    Themes must be registered using  [`TextArea.register_theme`][textual.widgets._text_area.TextArea.register_theme] before they can be used.

    Syntax highlighting is only possible when the `language` attribute is set.
    """
⋮----
selection: Reactive[Selection] = reactive(
"""The selection start and end locations (zero-based line_index, offset).

    This represents the cursor location and the current selection.

    The `Selection.end` always refers to the cursor location.

    If no text is selected, then `Selection.end == Selection.start` is True.

    The text selected in the document is available via the `TextArea.selected_text` property.
    """
⋮----
show_line_numbers: Reactive[bool] = reactive(False, init=False)
"""True to show the line number column on the left edge, otherwise False.

    Changing this value will immediately re-render the `TextArea`."""
⋮----
line_number_start: Reactive[int] = reactive(1, init=False)
"""The line number the first line should be."""
⋮----
indent_width: Reactive[int] = reactive(4, init=False)
"""The width of tabs or the multiple of spaces to align to on pressing the `tab` key.

    If the document currently open contains tabs that are currently visible on screen,
    altering this value will immediately change the display width of the visible tabs.
    """
⋮----
match_cursor_bracket: Reactive[bool] = reactive(True, init=False)
"""If the cursor is at a bracket, highlight the matching bracket (if found)."""
⋮----
cursor_blink: Reactive[bool] = reactive(True, init=False)
"""True if the cursor should blink."""
⋮----
soft_wrap: Reactive[bool] = reactive(True, init=False)
"""True if text should soft wrap."""
⋮----
read_only: Reactive[bool] = reactive(False)
"""True if the content is read-only.

    Read-only means end users cannot insert, delete or replace content.

    The document can still be edited programmatically via the API.
    """
⋮----
show_cursor: Reactive[bool] = reactive(True)
"""Show the cursor in read only mode?

    If `True`, the cursor will be visible when `read_only==True`.
    If `False`, the cursor will be hidden when `read_only==True`, and the TextArea will
    scroll like other containers.

    """
⋮----
compact: reactive[bool] = reactive(False, toggle_class="-textual-compact")
"""Enable compact display?"""
⋮----
highlight_cursor_line: reactive[bool] = reactive(True)
"""Highlight the line under the cursor?"""
⋮----
_cursor_visible: Reactive[bool] = reactive(False, repaint=False, init=False)
"""Indicates where the cursor is in the blink cycle. If it's currently
    not visible due to blinking, this is False."""
⋮----
suggestion: Reactive[str] = reactive("")
"""A suggestion for auto-complete (pressing right will insert it)."""
⋮----
hide_suggestion_on_blur: Reactive[bool] = reactive(True)
"""Hide suggestion when the TextArea does not have focus."""
⋮----
placeholder: Reactive[str | Content] = reactive("")
"""Text to show when the text area has no content."""
⋮----
@dataclass
    class Changed(Message)
⋮----
"""Posted when the content inside the TextArea changes.

        Handle this message using the `on` decorator - `@on(TextArea.Changed)`
        or a method named `on_text_area_changed`.
        """
⋮----
text_area: TextArea
"""The `text_area` that sent this message."""
⋮----
@property
        def control(self) -> TextArea
⋮----
"""The `TextArea` that sent this message."""
⋮----
@dataclass
    class SelectionChanged(Message)
⋮----
"""Posted when the selection changes.

        This includes when the cursor moves or when text is selected."""
⋮----
selection: Selection
"""The new selection."""
⋮----
"""Construct a new `TextArea`.

        Args:
            text: The initial text to load into the TextArea.
            language: The language to use.
            theme: The theme to use.
            soft_wrap: Enable soft wrapping.
            tab_behavior: If 'focus', pressing tab will switch focus. If 'indent', pressing tab will insert a tab.
            read_only: Enable read-only mode. This prevents edits using the keyboard.
            show_cursor: Show the cursor in read only mode (no effect otherwise).
            show_line_numbers: Show line numbers on the left edge.
            line_number_start: What line number to start on.
            max_checkpoints: The maximum number of undo history checkpoints to retain.
            name: The name of the `TextArea` widget.
            id: The ID of the widget, used to refer to it from Textual CSS.
            classes: One or more Textual CSS compatible class names separated by spaces.
            disabled: True if the widget is disabled.
            tooltip: Optional tooltip.
            compact: Enable compact style (without borders).
            highlight_cursor_line: Highlight the line under the cursor.
            placeholder: Text to display when there is not content.
        """
⋮----
"""Maps language names to TextAreaLanguage. This is only used for languages
        registered by end-users using `TextArea.register_language`. If a user attempts
        to set `TextArea.language` to a language that is not registered here, we'll
        attempt to get it from the environment. If that fails, we'll fall back to
        plain text.
        """
⋮----
"""Maps theme names to TextAreaTheme."""
⋮----
"""Whether to indent using tabs or spaces."""
⋮----
"""Compiled regular expression for what we consider to be a 'word'."""
⋮----
"""A stack (the end of the list is the top of the stack) for tracking edits."""
⋮----
"""True if we're currently selecting text using the mouse, otherwise False."""
⋮----
"""The location (row, column) of the bracket which matches the bracket the
        cursor is currently at. If the cursor is at a bracket, or there's no matching
        bracket, this will be `None`."""
⋮----
"""Mapping line numbers to the set of highlights for that line."""
⋮----
"""The query that's currently being used for highlighting."""
⋮----
"""The document this widget is currently editing."""
⋮----
"""The wrapped view of the document."""
⋮----
"""Queried to determine where the cursor should move given a navigation
        action, accounting for wrapping etc."""
⋮----
"""The virtual offset of the cursor (not screen-space offset)."""
⋮----
"""The `TextAreaTheme` corresponding to the set theme name. When the `theme`
        reactive is set as a string, the watcher will update this attribute to the
        corresponding `TextAreaTheme` object."""
⋮----
"""Construct a new `TextArea` with sensible defaults for editing code.

        This instantiates a `TextArea` with line numbers enabled, soft wrapping
        disabled, "indent" tab behavior, and the "monokai" theme.

        Args:
            text: The initial text to load into the TextArea.
            language: The language to use.
            theme: The theme to use.
            soft_wrap: Enable soft wrapping.
            tab_behavior: If 'focus', pressing tab will switch focus. If 'indent', pressing tab will insert a tab.
            read_only: Enable read-only mode. This prevents edits using the keyboard.
            show_cursor: Show the cursor in read only mode (no effect otherwise).
            show_line_numbers: Show line numbers on the left edge.
            line_number_start: What line number to start on.
            name: The name of the `TextArea` widget.
            id: The ID of the widget, used to refer to it from Textual CSS.
            classes: One or more Textual CSS compatible class names separated by spaces.
            disabled: True if the widget is disabled.
            tooltip: Optional tooltip
            compact: Enable compact style (without borders).
            highlight_cursor_line: Highlight the line under the cursor.
        """
⋮----
@staticmethod
    def _get_builtin_highlight_query(language_name: str) -> str
⋮----
"""Get the highlight query for a builtin language.

        Args:
            language_name: The name of the builtin language.

        Returns:
            The highlight query.
        """
⋮----
highlight_query_path = (
highlight_query = highlight_query_path.read_text()
⋮----
highlight_query = ""
⋮----
def notify_style_update(self) -> None
⋮----
def update_suggestion(self) -> None
⋮----
"""A hook to update the [`suggestion`][textual.widgets.TextArea.suggestion] attribute."""
⋮----
def check_consume_key(self, key: str, character: str | None = None) -> bool
⋮----
"""Check if the widget may consume the given key.

        As a textarea we are expecting to capture printable keys.

        Args:
            key: A key identifier.
            character: A character associated with the key, or `None` if there isn't one.

        Returns:
            `True` if the widget may capture the key in its `Key` message, or `False` if it won't.
        """
⋮----
# In read only mode we don't consume any key events
⋮----
# If tab_behavior is indent, then we consume the tab
⋮----
# Otherwise we capture all printable keys
⋮----
def _build_highlight_map(self) -> None
⋮----
"""Query the tree for ranges to highlights, and update the internal highlights mapping."""
⋮----
highlights = self._highlights
⋮----
captures = self.document.query_syntax_tree(self._highlight_query)
⋮----
highlight = (node_start_column, node_end_column, highlight_name)
⋮----
# Add the first line of the node range
⋮----
# Add the middle lines - entire row of this node is highlighted
⋮----
# Add the last line of the node range
⋮----
def _watch_has_focus(self, focus: bool) -> None
⋮----
"""When the cursor moves, scroll it into view."""
# Find the visual offset of the cursor in the document
⋮----
cursor_location = selection.end
⋮----
character = self.document[cursor_row][cursor_column]
⋮----
character = ""
⋮----
# Record the location of a matching closing/opening bracket.
match_location = self.find_matching_bracket(character, cursor_location)
⋮----
def _watch_cursor_blink(self, blink: bool) -> None
⋮----
def _watch_read_only(self, read_only: bool) -> None
⋮----
def _recompute_cursor_offset(self)
⋮----
"""Recompute the (x, y) coordinate of the cursor in the wrapped document."""
⋮----
"""If the character is a bracket, find the matching bracket.

        Args:
            bracket: The character we're searching for the matching bracket of.
            search_from: The location to start the search.

        Returns:
            The `Location` of the matching bracket, or `None` if it's not found.
            If the character is not available for bracket matching, `None` is returned.
        """
match_location = None
bracket_stack: list[str] = []
⋮----
# Search forwards for a closing bracket
⋮----
match_location = candidate_location
⋮----
# Search backwards for an opening bracket
⋮----
def _validate_selection(self, selection: Selection) -> Selection
⋮----
"""Clamp the selection to valid locations."""
⋮----
clamp_visitable = self.clamp_visitable
⋮----
def _watch_language(self, language: str | None) -> None
⋮----
"""When the language is updated, update the type of document."""
⋮----
def _watch_show_line_numbers(self) -> None
⋮----
"""The line number gutter contributes to virtual size, so recalculate."""
⋮----
def _watch_line_number_start(self) -> None
⋮----
"""The line number gutter max size might change and contributes to virtual size, so recalculate."""
⋮----
def _watch_indent_width(self) -> None
⋮----
"""Changing width of tabs will change the document display width."""
⋮----
def _watch_show_vertical_scrollbar(self) -> None
⋮----
def _watch_theme(self, theme: str) -> None
⋮----
"""We set the styles on this widget when the theme changes, to ensure that
        if padding is applied, the colors match."""
⋮----
def _app_theme_changed(self) -> None
⋮----
def _set_theme(self, theme: str) -> None
⋮----
theme_object: TextAreaTheme | None
⋮----
# If the user supplied a string theme name, find it and apply it.
⋮----
theme_object = self._themes[theme]
⋮----
theme_object = TextAreaTheme.get_builtin_theme(theme)
⋮----
base_style = theme_object.base_style
⋮----
color = base_style.color
background = base_style.bgcolor
⋮----
# When the theme doesn't define a base style (e.g. the `css` theme),
# the TextArea background/color should fallback to its CSS colors.
#
# Since these styles may have already been changed by another theme,
# we need to reset the background/color styles to the default values.
⋮----
@property
    def available_themes(self) -> set[str]
⋮----
"""A list of the names of the themes available to the `TextArea`.

        The values in this list can be assigned `theme` reactive attribute of
        `TextArea`.

        You can retrieve the full specification for a theme by passing one of
        the strings from this list into `TextAreaTheme.get_by_name(theme_name: str)`.

        Alternatively, you can directly retrieve a list of `TextAreaTheme` objects
        (which contain the full theme specification) by calling
        `TextAreaTheme.builtin_themes()`.
        """
⋮----
def register_theme(self, theme: TextAreaTheme) -> None
⋮----
"""Register a theme for use by the `TextArea`.

        After registering a theme, you can set themes by assigning the theme
        name to the `TextArea.theme` reactive attribute. For example
        `text_area.theme = "my_custom_theme"` where `"my_custom_theme"` is the
        name of the theme you registered.

        If you supply a theme with a name that already exists that theme
        will be overwritten.
        """
⋮----
@property
    def available_languages(self) -> set[str]
⋮----
"""A set of the names of languages available to the `TextArea`.

        The values in this set can be assigned to the `language` reactive attribute
        of `TextArea`.

        The returned set contains the builtin languages installed with the syntax extras,
        plus those registered via the `register_language` method.
        """
⋮----
"""Register a language and corresponding highlight query.

        Calling this method does not change the language of the `TextArea`.
        On switching to this language (via the `language` reactive attribute),
        syntax highlighting will be performed using the given highlight query.

        If a string `name` is supplied for a builtin supported language, then
        this method will update the default highlight query for that language.

        Registering a language only registers it to this instance of `TextArea`.

        Args:
            name: The name of the language.
            language: A tree-sitter `Language` object.
            highlight_query: The highlight query to use for syntax highlighting this language.
        """
⋮----
def update_highlight_query(self, name: str, highlight_query: str) -> None
⋮----
"""Update the highlight query for an already registered language.

        Args:
            name: The name of the language.
            highlight_query: The highlight query to use for syntax highlighting this language.
        """
⋮----
# If this is the currently loaded language, reload the document because
# it could be a different highlight query for the same language.
⋮----
def _set_document(self, text: str, language: str | None) -> None
⋮----
"""Construct and return an appropriate document.

        Args:
            text: The text of the document.
            language: The name of the language to use. This must correspond to a tree-sitter
                language available in the current environment (e.g. use `python` for `tree-sitter-python`).
                If None, the document will be treated as plain text.
        """
⋮----
# User-registered languages take priority.
highlight_query = self._languages[language].highlight_query
document_language = self._languages[language].language
⋮----
document_language = get_language(language)
⋮----
# No user-registered language, so attempt to use a built-in language.
highlight_query = self._get_builtin_highlight_query(language)
⋮----
# No built-in language, and no user-registered language: use plain text and warn.
⋮----
document: DocumentBase
⋮----
document = SyntaxAwareDocument(text, document_language)
⋮----
document = Document(text)
⋮----
# User has supplied a language i.e. `TextArea(language="python")`, but they
# don't have tree-sitter available in the environment. We fallback to plain text.
⋮----
# tree-sitter is available, but the user has supplied None or "" for the language.
# Use a regular plain-text document.
⋮----
@property
    def _visible_line_indices(self) -> tuple[int, int]
⋮----
"""Return the visible line indices as a tuple (top, bottom).

        Returns:
            A tuple (top, bottom) indicating the top and bottom visible line indices.
        """
⋮----
def _watch_scroll_x(self) -> None
⋮----
def _watch_scroll_y(self) -> None
⋮----
def load_text(self, text: str) -> None
⋮----
"""Load text into the TextArea.

        This will replace the text currently in the TextArea and clear the edit history.

        Args:
            text: The text to load into the TextArea.
        """
⋮----
def _on_resize(self) -> None
⋮----
def _watch_soft_wrap(self) -> None
⋮----
@property
    def wrap_width(self) -> int
⋮----
"""The width which gets used when the document wraps.

        Accounts for gutter, scrollbars, etc.
        """
⋮----
cursor_width = 1
⋮----
def _rewrap_and_refresh_virtual_size(self) -> None
⋮----
@property
    def is_syntax_aware(self) -> bool
⋮----
"""True if the TextArea is currently syntax aware - i.e. it's parsing document content."""
⋮----
"""Yields character locations starting from the given location.

        Does not yield location of line separator characters like `\\n`.

        Args:
            start: The location to start yielding from.

        Returns:
            Yields tuples of (character, (row, column)).
        """
⋮----
document = self.document
line_count = document.line_count
⋮----
line = document[row]
⋮----
column = 0
⋮----
column = len(line) - 1
⋮----
def _refresh_size(self) -> None
⋮----
"""Update the virtual size of the TextArea."""
⋮----
# +1 width to make space for the cursor resting at the end of the line
⋮----
@property
    def _draw_cursor(self) -> bool
⋮----
"""Draw the cursor?"""
⋮----
# If we are in read only mode, we don't want the cursor to blink
⋮----
draw_cursor = (
⋮----
@property
    def _has_cursor(self) -> bool
⋮----
"""Is there a usable cursor?"""
⋮----
def get_line(self, line_index: int) -> Text
⋮----
"""Retrieve the line at the given line index.

        You can stylize the Text object returned here to apply additional
        styling to TextArea content.

        Args:
            line_index: The index of the line.

        Returns:
            A `rich.Text` object containing the requested line.
        """
line_string = self.document.get_line(line_index)
⋮----
def render_lines(self, crop: Region) -> list[Strip]
⋮----
theme = self._theme
⋮----
def render_line(self, y: int) -> Strip
⋮----
"""Render a single line of the TextArea. Called by Textual.

        Args:
            y: Y Coordinate of line relative to the widget region.

        Returns:
            A rendered line.
        """
⋮----
placeholder_lines = Content.from_text(self.placeholder).wrap(
⋮----
style = self.get_visual_style("text-area--placeholder")
content = placeholder_lines[y].stylize(style)
⋮----
cursor_style = theme.cursor_style if theme else None
⋮----
content = content.stylize(
⋮----
absolute_y = scroll_y + y
selection = self.selection
⋮----
cache_key = (
⋮----
line = self._render_line(y)
⋮----
def _render_line(self, y: int) -> Strip
⋮----
base_style = (
⋮----
wrapped_document = self.wrapped_document
⋮----
# Account for how much the TextArea is scrolled.
y_offset = y + scroll_y
⋮----
# If we're beyond the height of the document, render blank lines
out_of_bounds = y_offset >= wrapped_document.height
⋮----
# Get the line corresponding to this offset
⋮----
line_info = wrapped_document._offset_to_line_info[y_offset]
⋮----
line_info = None
⋮----
line = self.get_line(line_index)
line_character_count = len(line)
⋮----
line.set_length(line_character_count + 1)  # space at end for cursor
⋮----
highlight_cursor_line = self.highlight_cursor_line and self._has_cursor
cursor_line_style = (
has_cursor = self._has_cursor
⋮----
# Selection styling
⋮----
# If this row intersects with the selection range
selection_style = theme.selection_style if theme else None
⋮----
# A simple highlight to show empty lines are included in the selection
⋮----
# Selection within a single line
⋮----
# Selection spanning multiple lines
⋮----
line_bytes = _utf8_encode(line.plain)
byte_to_codepoint = build_byte_to_codepoint_dict(line_bytes)
get_highlight_from_theme = theme.syntax_styles.get
line_highlights = highlights[line_index]
⋮----
node_style = get_highlight_from_theme(highlight_name)
⋮----
# Highlight the cursor
matching_bracket = self._matching_bracket_location
match_cursor_bracket = self.match_cursor_bracket
draw_matched_brackets = (
⋮----
draw_cursor = self._draw_cursor
⋮----
matching_bracket_style = theme.bracket_matching_style if theme else None
⋮----
suggestion_style = self.get_component_rich_style(
line = Text.assemble(
⋮----
# Highlight the partner opening/closing bracket.
⋮----
# mypy doesn't know matching bracket is guaranteed to be non-None
⋮----
matching_bracket_style = theme.bracket_matching_style
⋮----
# Build the gutter text for this line
gutter_width = self.gutter_width
⋮----
gutter_style = theme.cursor_line_gutter_style
⋮----
gutter_style = theme.gutter_style
⋮----
gutter_width_no_margin = gutter_width - 2
gutter_content = (
gutter = [
⋮----
gutter = []
⋮----
# TODO: Lets not apply the division each time through render_line.
#  We should cache sections with the edit counts.
wrap_offsets = wrapped_document.get_offsets(line_index)
⋮----
sections = line.divide(wrap_offsets)  # TODO cache result with edit count
line = sections[section_offset]
line_tab_widths = wrapped_document.get_tab_widths(line_index)
⋮----
# Get the widths of the tabs corresponding only to the section of the
# line that is currently being rendered. We don't care about tabs in
# other sections of the same line.
⋮----
# Count the tabs before this section.
tabs_before = 0
⋮----
# Count the tabs in this section.
tabs_within = line.plain.count("\t")
section_tab_widths = line_tab_widths[
line = expand_text_tabs_from_widths(line, section_tab_widths)
⋮----
base_width = (
target_width = base_width - self.gutter_width
⋮----
# Crop the line to show only the visible part (some may be scrolled out of view)
console = self.app.console
text_strip = Strip(line.render(console), cell_length=line.cell_len)
⋮----
text_strip = text_strip.crop(scroll_x, scroll_x + virtual_width)
⋮----
# Stylize the line the cursor is currently on.
⋮----
line_style = cursor_line_style
⋮----
line_style = theme.base_style if theme else None
⋮----
text_strip = text_strip.extend_cell_length(target_width, line_style)
⋮----
strip = Strip.join([Strip(gutter, cell_length=gutter_width), text_strip])
⋮----
strip = text_strip
⋮----
@property
    def text(self) -> str
⋮----
"""The entire text content of the document."""
⋮----
@text.setter
    def text(self, value: str) -> None
⋮----
"""Replace the text currently in the TextArea. This is an alias of `load_text`.

        Setting this value will clear the edit history.

        Args:
            value: The text to load into the TextArea.
        """
⋮----
@property
    def selected_text(self) -> str
⋮----
"""The text between the start and end points of the current selection."""
⋮----
@property
    def matching_bracket_location(self) -> Location | None
⋮----
"""The location of the matching bracket, if there is one."""
⋮----
def get_text_range(self, start: Location, end: Location) -> str
⋮----
"""Get the text between a start and end location.

        Args:
            start: The start location.
            end: The end location.

        Returns:
            The text between start and end.
        """
⋮----
def edit(self, edit: Edit) -> EditResult
⋮----
"""Perform an Edit.

        Args:
            edit: The Edit to perform.

        Returns:
            Data relating to the edit that may be useful. The data returned
            may be different depending on the edit performed.
        """
⋮----
old_gutter_width = self.gutter_width
result = edit.do(self)
⋮----
new_gutter_width = self.gutter_width
⋮----
def undo(self) -> None
⋮----
"""Undo the edits since the last checkpoint (the most recent batch of edits)."""
⋮----
def action_undo(self) -> None
⋮----
def redo(self) -> None
⋮----
"""Redo the most recently undone batch of edits."""
⋮----
def action_redo(self) -> None
⋮----
def _undo_batch(self, edits: Sequence[Edit]) -> None
⋮----
"""Undo a batch of Edits.

        The sequence must be chronologically ordered by edit time.

        There must be no edits missing from the sequence, or the resulting content
        will be incorrect.

        Args:
            edits: The edits to undo, in the order they were originally performed.
        """
⋮----
minimum_top = edits[-1].top
maximum_old_bottom = (0, 0)
maximum_new_bottom = (0, 0)
⋮----
end_location = (
⋮----
minimum_top = edit.top
⋮----
maximum_old_bottom = end_location
⋮----
maximum_new_bottom = edit.bottom
⋮----
def _redo_batch(self, edits: Sequence[Edit]) -> None
⋮----
"""Redo a batch of Edits in order.

        The sequence must be chronologically ordered by edit time.

        Edits are applied from the start of the sequence to the end.

        There must be no edits missing from the sequence, or the resulting content
        will be incorrect.

        Args:
            edits: The edits to redo.
        """
⋮----
minimum_top = edits[0].top
⋮----
maximum_new_bottom = end_location
⋮----
maximum_old_bottom = edit.bottom
⋮----
async def _on_key(self, event: events.Key) -> None
⋮----
"""Handle key presses which correspond to document inserts."""
⋮----
key = event.key
insert_values = {
⋮----
insert = insert_values.get(key, event.character)
# `insert` is not None because event.character cannot be
# None because we've checked that it's printable.
⋮----
def _find_columns_to_next_tab_stop(self) -> int
⋮----
"""Get the location of the next tab stop after the cursors position on the current line.

        If the cursor is already at a tab stop, this returns the *next* tab stop location.

        Returns:
            The number of cells to the next tab stop from the current cursor column.
        """
⋮----
line_text = self.document[cursor_row]
indent_width = self.indent_width
⋮----
width_before_cursor = self.get_column_width(cursor_row, cursor_column)
spaces_to_insert = indent_width - (
⋮----
def get_target_document_location(self, event: MouseEvent) -> Location
⋮----
"""Given a MouseEvent, return the row and column offset of the event in document-space.

        Args:
            event: The MouseEvent.

        Returns:
            The location of the mouse event within the document.
        """
⋮----
target_x = event.x - self.gutter_width + scroll_x - self.gutter.left
target_y = event.y + scroll_y - self.gutter.top
location = self.wrapped_document.offset_to_location(Offset(target_x, target_y))
⋮----
@property
    def gutter_width(self) -> int
⋮----
"""The width of the gutter (the left column containing line numbers).

        Returns:
            The cell-width of the line number column. If `show_line_numbers` is `False` returns 0.
        """
# The longest number in the gutter plus two extra characters: `│ `.
gutter_margin = 2
gutter_width = (
⋮----
def _on_mount(self, event: events.Mount) -> None
⋮----
def text_selection_started(screen: Screen) -> None
⋮----
"""Signal callback to unselect when arbitrary text selection starts."""
⋮----
# When `app.theme` reactive is changed, reset the theme to clear cached styles.
⋮----
def _toggle_cursor_blink_visible(self) -> None
⋮----
"""Toggle visibility of the cursor for the purposes of 'cursor blink'."""
⋮----
def _watch__cursor_visible(self) -> None
⋮----
"""When the cursor visibility is toggled, ensure the row is refreshed."""
⋮----
def _restart_blink(self) -> None
⋮----
"""Reset the cursor blink timer."""
⋮----
def _pause_blink(self, visible: bool = True) -> None
⋮----
"""Pause the cursor blinking but ensure it stays visible."""
⋮----
async def _on_mouse_down(self, event: events.MouseDown) -> None
⋮----
"""Update the cursor position, and begin a selection using the mouse."""
target = self.get_target_document_location(event)
⋮----
# Capture the mouse so that if the cursor moves outside the
# TextArea widget while selecting, the widget still scrolls.
⋮----
async def _on_mouse_move(self, event: events.MouseMove) -> None
⋮----
"""Handles click and drag to expand and contract the selection."""
⋮----
def _end_mouse_selection(self) -> None
⋮----
"""Finalize the selection that has been made using the mouse."""
⋮----
async def _on_mouse_up(self, event: events.MouseUp) -> None
⋮----
async def _on_hide(self, event: events.Hide) -> None
⋮----
"""Finalize the selection that has been made using the mouse when the widget is hidden."""
⋮----
async def _on_paste(self, event: events.Paste) -> None
⋮----
"""When a paste occurs, insert the text from the paste event into the document."""
⋮----
def cell_width_to_column_index(self, cell_width: int, row_index: int) -> int
⋮----
"""Return the column that the cell width corresponds to on the given row.

        Args:
            cell_width: The cell width to convert.
            row_index: The index of the row to examine.

        Returns:
            The column corresponding to the cell width on that row.
        """
line = self.document[row_index]
⋮----
def clamp_visitable(self, location: Location) -> Location
⋮----
"""Clamp the given location to the nearest visitable location.

        Args:
            location: The location to clamp.

        Returns:
            The nearest location that we could conceivably navigate to using the cursor.
        """
⋮----
line_text = document[row]
⋮----
line_text = ""
⋮----
row = clamp(row, 0, document.line_count - 1)
column = clamp(column, 0, len(line_text))
⋮----
# --- Cursor/selection utilities
⋮----
"""Scroll the `TextArea` such that the cursor is visible on screen.

        Args:
            center: True if the cursor should be scrolled to the center.
            animate: True if we should animate while scrolling.

        Returns:
            The offset that was scrolled to bring the cursor into view.
        """
⋮----
scroll_offset = self.scroll_to_region(
⋮----
"""Move the cursor to a location.

        Args:
            location: The location to move the cursor to.
            select: If True, select text between the old and new location.
            center: If True, scroll such that the cursor is centered.
            record_width: If True, record the cursor column cell width after navigating
                so that we jump back to the same width the next time we move to a row
                that is wide enough.
        """
⋮----
"""Move the cursor relative to its current location in document-space.

        Args:
            rows: The number of rows to move down by (negative to move up)
            columns:  The number of columns to move right by (negative to move left)
            select: If True, select text between the old and new location.
            center: If True, scroll such that the cursor is centered.
            record_width: If True, record the cursor column cell width after navigating
                so that we jump back to the same width the next time we move to a row
                that is wide enough.
        """
⋮----
target = clamp_visitable((current_row + rows, current_column + columns))
⋮----
def select_line(self, index: int) -> None
⋮----
"""Select all the text in the specified line.

        Args:
            index: The index of the line to select (starting from 0).
        """
⋮----
line = self.document[index]
⋮----
def action_select_line(self) -> None
⋮----
"""Select all the text on the current line."""
⋮----
def select_all(self) -> None
⋮----
"""Select all of the text in the `TextArea`."""
last_line = self.document.line_count - 1
length_of_last_line = len(self.document[last_line])
selection_start = (0, 0)
selection_end = (last_line, length_of_last_line)
⋮----
def action_select_all(self) -> None
⋮----
"""Select all the text in the document."""
⋮----
@property
    def cursor_location(self) -> Location
⋮----
"""The current location of the cursor in the document.

        This is a utility for accessing the `end` of `TextArea.selection`.
        """
⋮----
@cursor_location.setter
    def cursor_location(self, location: Location) -> None
⋮----
"""Set the cursor_location to a new location.

        If a selection is in progress, the anchor point will remain.
        """
⋮----
@property
    def cursor_screen_offset(self) -> Offset
⋮----
"""The offset of the cursor relative to the screen."""
⋮----
offset_x = region_x + cursor_x - scroll_x + self.gutter_width
offset_y = region_y + cursor_y - scroll_y
⋮----
@property
    def cursor_at_first_line(self) -> bool
⋮----
"""True if and only if the cursor is on the first line."""
⋮----
@property
    def cursor_at_last_line(self) -> bool
⋮----
"""True if and only if the cursor is on the last line."""
⋮----
@property
    def cursor_at_start_of_line(self) -> bool
⋮----
"""True if and only if the cursor is at column 0."""
⋮----
@property
    def cursor_at_end_of_line(self) -> bool
⋮----
"""True if and only if the cursor is at the end of a row."""
⋮----
row_length = len(self.document[cursor_row])
cursor_at_end = cursor_column == row_length
⋮----
@property
    def cursor_at_start_of_text(self) -> bool
⋮----
"""True if and only if the cursor is at location (0, 0)"""
⋮----
@property
    def cursor_at_end_of_text(self) -> bool
⋮----
"""True if and only if the cursor is at the very end of the document."""
⋮----
# ------ Cursor movement actions
def action_cursor_left(self, select: bool = False) -> None
⋮----
"""Move the cursor one location to the left.

        If the cursor is at the left edge of the document, try to move it to
        the end of the previous line.

        If text is selected, move the cursor to the start of the selection.

        Args:
            select: If True, select the text while moving.
        """
⋮----
target = (
⋮----
def get_cursor_left_location(self) -> Location
⋮----
"""Get the location the cursor will move to if it moves left.

        Returns:
            The location of the cursor if it moves left.
        """
⋮----
def action_cursor_right(self, select: bool = False) -> None
⋮----
"""Move the cursor one location to the right.

        If the cursor is at the end of a line, attempt to go to the start of the next line.

        If text is selected, move the cursor to the end of the selection.

        Args:
            select: If True, select the text while moving.
        """
⋮----
def get_cursor_right_location(self) -> Location
⋮----
"""Get the location the cursor will move to if it moves right.

        Returns:
            the location the cursor will move to if it moves right.
        """
⋮----
def action_cursor_down(self, select: bool = False) -> None
⋮----
"""Move the cursor down one cell.

        Args:
            select: If True, select the text while moving.
        """
⋮----
target = self.get_cursor_down_location()
⋮----
def get_cursor_down_location(self) -> Location
⋮----
"""Get the location the cursor will move to if it moves down.

        Returns:
            The location the cursor will move to if it moves down.
        """
⋮----
def action_cursor_up(self, select: bool = False) -> None
⋮----
"""Move the cursor up one cell.

        Args:
            select: If True, select the text while moving.
        """
⋮----
target = self.get_cursor_up_location()
⋮----
def get_cursor_up_location(self) -> Location
⋮----
"""Get the location the cursor will move to if it moves up.

        Returns:
            The location the cursor will move to if it moves up.
        """
⋮----
def action_cursor_line_end(self, select: bool = False) -> None
⋮----
"""Move the cursor to the end of the line."""
⋮----
location = self.get_cursor_line_end_location()
⋮----
def get_cursor_line_end_location(self) -> Location
⋮----
"""Get the location of the end of the current line.

        Returns:
            The (row, column) location of the end of the cursors current line.
        """
⋮----
def action_cursor_line_start(self, select: bool = False) -> None
⋮----
"""Move the cursor to the start of the line."""
⋮----
target = self.get_cursor_line_start_location(smart_home=True)
⋮----
def get_cursor_line_start_location(self, smart_home: bool = False) -> Location
⋮----
"""Get the location of the start of the current line.

        Args:
            smart_home: If True, use "smart home key" behavior - go to the first
                non-whitespace character on the line, and if already there, go to
                offset 0. Smart home only works when wrapping is disabled.

        Returns:
            The (row, column) location of the start of the cursors current line.
        """
⋮----
def action_cursor_word_left(self, select: bool = False) -> None
⋮----
"""Move the cursor left by a single word, skipping trailing whitespace.

        Args:
            select: Whether to select while moving the cursor.
        """
⋮----
target = self.get_cursor_word_left_location()
⋮----
def get_cursor_word_left_location(self) -> Location
⋮----
"""Get the location the cursor will jump to if it goes 1 word left.

        Returns:
            The location the cursor will jump on "jump word left".
        """
⋮----
# Going to the previous row
⋮----
# Staying on the same row
line = self.document[cursor_row][:cursor_column]
search_string = line.rstrip()
matches = list(re.finditer(self._word_pattern, search_string))
cursor_column = matches[-1].start() if matches else 0
⋮----
def action_cursor_word_right(self, select: bool = False) -> None
⋮----
"""Move the cursor right by a single word, skipping leading whitespace."""
⋮----
target = self.get_cursor_word_right_location()
⋮----
def get_cursor_word_right_location(self) -> Location
⋮----
"""Get the location the cursor will jump to if it goes 1 word right.

        Returns:
            The location the cursor will jump on "jump word right".
        """
⋮----
line = self.document[cursor_row]
⋮----
# Moving to the line below
⋮----
# Staying on the same line
search_string = line[cursor_column:]
pre_strip_length = len(search_string)
search_string = search_string.lstrip()
strip_offset = pre_strip_length - len(search_string)
⋮----
cursor_column = len(line)
⋮----
def action_cursor_page_up(self) -> None
⋮----
"""Move the cursor and scroll up one page."""
⋮----
height = self.content_size.height
⋮----
target = self.navigator.get_location_at_y_offset(
⋮----
def action_cursor_page_down(self) -> None
⋮----
"""Move the cursor and scroll down one page."""
⋮----
def get_column_width(self, row: int, column: int) -> int
⋮----
"""Get the cell offset of the column from the start of the row.

        Args:
            row: The row index.
            column: The column index (codepoint offset from start of row).

        Returns:
            The cell width of the column relative to the start of the row.
        """
line = self.document[row]
⋮----
def record_cursor_width(self) -> None
⋮----
"""Record the current cell width of the cursor.

        This is used where we navigate up and down through rows.
        If we're in the middle of a row, and go down to a row with no
        content, then we go down to another row, we want our cursor to
        jump back to the same offset that we were originally at.
        """
⋮----
# --- Editor operations
⋮----
"""Insert text into the document.

        Args:
            text: The text to insert.
            location: The location to insert text, or None to use the cursor location.
            maintain_selection_offset: If True, the active Selection will be updated
                such that the same text is selected before and after the selection,
                if possible. Otherwise, the cursor will jump to the end point of the
                edit.

        Returns:
            An `EditResult` containing information about the edit.
        """
⋮----
location = self.cursor_location
⋮----
"""Delete the text between two locations in the document.

        Args:
            start: The start location.
            end: The end location.
            maintain_selection_offset: If True, the active Selection will be updated
                such that the same text is selected before and after the selection,
                if possible. Otherwise, the cursor will jump to the end point of the
                edit.

        Returns:
            An `EditResult` containing information about the edit.
        """
⋮----
"""Replace text in the document with new text.

        Args:
            insert: The text to insert.
            start: The start location
            end: The end location.
            maintain_selection_offset: If True, the active Selection will be updated
                such that the same text is selected before and after the selection,
                if possible. Otherwise, the cursor will jump to the end point of the
                edit.

        Returns:
            An `EditResult` containing information about the edit.
        """
⋮----
def clear(self) -> EditResult
⋮----
"""Delete all text from the document.

        Returns:
            An EditResult relating to the deletion of all content.
        """
⋮----
"""Handle a deletion performed using a keyboard (as opposed to the API).

        Args:
            start: The start location of the text to delete.
            end: The end location of the text to delete.

        Returns:
            An EditResult or None if no edit was performed (e.g. on read-only mode).
        """
⋮----
"""Handle a replacement performed using a keyboard (as opposed to the API).

        Args:
            insert: The text to insert into the document.
            start: The start location of the text to replace.
            end: The end location of the text to replace.

        Returns:
            An EditResult or None if no edit was performed (e.g. on read-only mode).
        """
⋮----
def action_delete_left(self) -> None
⋮----
"""Deletes the character to the left of the cursor and updates the cursor location.

        If there's a selection, then the selected range is deleted."""
⋮----
end = self.get_cursor_left_location()
⋮----
def action_delete_right(self) -> None
⋮----
"""Deletes the character to the right of the cursor and keeps the cursor at the same location.

        If there's a selection, then the selected range is deleted."""
⋮----
end = self.get_cursor_right_location()
⋮----
def action_delete_line(self) -> None
⋮----
"""Deletes the lines which intersect with the selection."""
⋮----
def _delete_cursor_line(self) -> EditResult | None
⋮----
"""Deletes the line (including the line terminator) that the cursor is on."""
⋮----
# Generally editors will only delete line the end line of the
# selection if the cursor is not at column 0 of that line.
⋮----
from_location = (start_row, 0)
to_location = (end_row + 1, 0)
⋮----
deletion = self._delete_via_keyboard(from_location, to_location)
⋮----
def action_cut(self) -> None
⋮----
"""Cut text (remove and copy to clipboard)."""
⋮----
edit_result = self._delete_cursor_line()
⋮----
edit_result = self._delete_via_keyboard(start, end)
⋮----
def action_copy(self) -> None
⋮----
"""Copy selection to clipboard."""
selected_text = self.selected_text
⋮----
def action_paste(self) -> None
⋮----
"""Paste from local clipboard."""
⋮----
clipboard = self.app.clipboard
⋮----
def action_delete_to_start_of_line(self) -> None
⋮----
"""Deletes from the cursor location to the start of the line."""
from_location = self.selection.end
to_location = self.get_cursor_line_start_location()
⋮----
def action_delete_to_end_of_line(self) -> None
⋮----
"""Deletes from the cursor location to the end of the line."""
⋮----
to_location = self.get_cursor_line_end_location()
⋮----
async def action_delete_to_end_of_line_or_delete_line(self) -> None
⋮----
"""Deletes from the cursor location to the end of the line, or deletes the line.

        The line will be deleted if the line is empty.
        """
# Assume we're just going to delete to the end of the line.
action = "delete_to_end_of_line"
⋮----
# The line is empty, so we'll simply remove the line itself.
action = "delete_line"
⋮----
# We're at the end of the line, so the kill delete operation
# should join the next line to this.
action = "delete_right"
⋮----
def action_delete_word_left(self) -> None
⋮----
"""Deletes the word to the left of the cursor and updates the cursor location."""
⋮----
# If there's a non-zero selection, then "delete word left" typically only
# deletes the characters within the selection range, ignoring word boundaries.
⋮----
to_location = self.get_cursor_word_left_location()
⋮----
def action_delete_word_right(self) -> None
⋮----
"""Deletes the word to the right of the cursor and keeps the cursor at the same location.

        Note that the location that we delete to using this action is not the same
        as the location we move to when we move the cursor one word to the right.
        This action does not skip leading whitespace, whereas cursor movement does.
        """
⋮----
# Check the current line for a word boundary
line = self.document[cursor_row][cursor_column:]
matches = list(re.finditer(self._word_pattern, line))
⋮----
current_row_length = len(self.document[cursor_row])
⋮----
to_location = (cursor_row, cursor_column + matches[0].end())
⋮----
to_location = (cursor_row + 1, 0)
⋮----
to_location = (cursor_row, current_row_length)
⋮----
@lru_cache(maxsize=128)
def build_byte_to_codepoint_dict(data: bytes) -> dict[int, int]
⋮----
"""Build a mapping of utf-8 byte offsets to codepoint offsets for the given data.

    Args:
        data: utf-8 bytes.

    Returns:
        A `dict[int, int]` mapping byte indices to codepoint indices within `data`.
    """
byte_to_codepoint: dict[int, int] = {}
current_byte_offset = 0
code_point_offset = 0
⋮----
first_byte = data[current_byte_offset]
⋮----
# Single-byte character
⋮----
# 2-byte character
⋮----
# 3-byte character
⋮----
# 4-byte character
⋮----
# Mapping for the end of the string
</file>

</files>
