This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/widgets/_selection_list.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    widgets/
      _selection_list.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/widgets/_selection_list.py">
"""Provides a selection list widget, allowing one or more items to be selected."""
⋮----
SelectionType = TypeVar("SelectionType")
"""The type for the value of a [`Selection`][textual.widgets.selection_list.Selection] in a [`SelectionList`][textual.widgets.SelectionList]"""
⋮----
MessageSelectionType = TypeVar("MessageSelectionType")
"""The type for the value of a [`Selection`][textual.widgets.selection_list.Selection] in a [`SelectionList`][textual.widgets.SelectionList] message."""
⋮----
class SelectionError(TypeError)
⋮----
"""Type of an error raised if a selection is badly-formed."""
⋮----
class Selection(Generic[SelectionType], Option)
⋮----
"""A selection for a [`SelectionList`][textual.widgets.SelectionList]."""
⋮----
"""Initialise the selection.

        Args:
            prompt: The prompt for the selection.
            value: The value for the selection.
            initial_state: The initial selected state of the selection.
            id: The optional ID for the selection.
            disabled: The initial enabled/disabled state. Enabled by default.
        """
⋮----
selection_prompt = Content.from_text(prompt)
⋮----
"""The value associated with the selection."""
⋮----
"""The initial selected state for the selection."""
⋮----
@property
    def value(self) -> SelectionType
⋮----
"""The value for this selection."""
⋮----
@property
    def initial_state(self) -> bool
⋮----
class SelectionList(Generic[SelectionType], OptionList)
⋮----
"""A vertical selection list that allows making multiple selections."""
⋮----
BINDINGS = [Binding("space", "select", "Toggle option", show=False)]
"""
    | Key(s) | Description |
    | :- | :- |
    | space | Toggle the state of the highlighted selection. |
    """
⋮----
COMPONENT_CLASSES: ClassVar[set[str]] = {
"""
    | Class | Description |
    | :- | :- |
    | `selection-list--button` | Target the default button style. |
    | `selection-list--button-selected` | Target a selected button style. |
    | `selection-list--button-highlighted` | Target a highlighted button style. |
    | `selection-list--button-selected-highlighted` | Target a highlighted selected button style. |
    """
⋮----
DEFAULT_CSS = """
⋮----
class SelectionMessage(Generic[MessageSelectionType], Message)
⋮----
"""Base class for all selection messages."""
⋮----
"""Initialise the selection message.

            Args:
                selection_list: The selection list that owns the selection.
                index: The index of the selection that the message relates to.
            """
⋮----
"""The selection list that sent the message."""
⋮----
"""The highlighted selection."""
⋮----
"""The index of the selection that the message relates to."""
⋮----
@property
        def control(self) -> OptionList
⋮----
"""The selection list that sent the message.

            This is an alias for
            [`SelectionMessage.selection_list`][textual.widgets.SelectionList.SelectionMessage.selection_list]
            and is used by the [`on`][textual.on] decorator.
            """
⋮----
def __rich_repr__(self) -> Result
⋮----
class SelectionHighlighted(SelectionMessage[MessageSelectionType])
⋮----
"""Message sent when a selection is highlighted.

        Can be handled using `on_selection_list_selection_highlighted` in a subclass of
        [`SelectionList`][textual.widgets.SelectionList] or in a parent node in the DOM.
        """
⋮----
class SelectionToggled(SelectionMessage[MessageSelectionType])
⋮----
"""Message sent when a selection is toggled.

        This is only sent when the value is *explicitly* toggled e.g.
        via `toggle` or `toggle_all`, or via user interaction.
        If you programmatically set a value to be selected, this message will
        not be sent, even if it happens to be the opposite of what was
        originally selected (i.e. setting a True to a False or vice-versa).

        Since this message indicates a toggle occurring at a per-option level,
        a message will be sent for each option that is toggled, even when a
        bulk action is performed (e.g. via `toggle_all`).

        Can be handled using `on_selection_list_selection_toggled` in a subclass of
        [`SelectionList`][textual.widgets.SelectionList] or in a parent node in the DOM.
        """
⋮----
@dataclass
    class SelectedChanged(Generic[MessageSelectionType], Message)
⋮----
"""Message sent when the collection of selected values changes.

        This is sent regardless of whether the change occurred via user interaction
        or programmatically via the `SelectionList` API.

        When a bulk change occurs, such as through `select_all` or `deselect_all`,
        only a single `SelectedChanged` message will be sent (rather than one per
        option).

        Can be handled using `on_selection_list_selected_changed` in a subclass of
        [`SelectionList`][textual.widgets.SelectionList] or in a parent node in the DOM.
        """
⋮----
selection_list: SelectionList[MessageSelectionType]
"""The `SelectionList` that sent the message."""
⋮----
@property
        def control(self) -> SelectionList[MessageSelectionType]
⋮----
"""An alias for `selection_list`."""
⋮----
"""Initialise the selection list.

        Args:
            *selections: The content for the selection list.
            name: The name of the selection list.
            id: The ID of the selection list in the DOM.
            classes: The CSS classes of the selection list.
            disabled: Whether the selection list is disabled or not.
            compact: Enable a compact style?
        """
⋮----
"""Tracking of which values are selected."""
⋮----
"""Keep track of when we're ready to start sending messages."""
options = [self._make_selection(selection) for selection in selections]
⋮----
"""Keeps track of which value relates to which option."""
⋮----
@property
    def selected(self) -> list[SelectionType]
⋮----
"""The selected values.

        This is a list of all of the
        [values][textual.widgets.selection_list.Selection.value] associated
        with selections in the list that are currently in the selected
        state.
        """
⋮----
def _on_mount(self, _event: events.Mount) -> None
⋮----
"""Configure the list once the DOM is ready."""
⋮----
def _message_changed(self) -> None
⋮----
"""Post a message that the selected collection has changed, where appropriate.

        Note:
            A message will only be sent if `_send_messages` is `True`. This
            makes this safe to call before the widget is ready for posting
            messages.
        """
⋮----
def _message_toggled(self, option_index: int) -> None
⋮----
"""Post a message that an option was toggled, where appropriate.

        Note:
            A message will only be sent if `_send_messages` is `True`. This
            makes this safe to call before the widget is ready for posting
            messages.
        """
⋮----
def _apply_to_all(self, state_change: Callable[[SelectionType], bool]) -> Self
⋮----
"""Apply a selection state change to all selection options in the list.

        Args:
            state_change: The state change function to apply.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.

        Note:
            This method will post a single
            [`SelectedChanged`][textual.widgets.OptionList.SelectedChanged]
            message if a change is made in a call to this method.
        """
⋮----
# Keep track of if anything changed.
changed = False
⋮----
# Apply the state change function to all options.
# We don't send a SelectedChanged for each option, and instead
# send a single SelectedChanged afterwards if any values change.
⋮----
changed = (
⋮----
# If the above did make a change, *then* send a message.
⋮----
def _select(self, value: SelectionType) -> bool
⋮----
"""Mark the given value as selected.

        Args:
            value: The value to mark as selected.

        Returns:
            `True` if the value was selected, `False` if not.
        """
⋮----
def select(self, selection: Selection[SelectionType] | SelectionType) -> Self
⋮----
"""Mark the given selection as selected.

        Args:
            selection: The selection to mark as selected.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.
        """
⋮----
def select_all(self) -> Self
⋮----
"""Select all items.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.
        """
⋮----
def _deselect(self, value: SelectionType) -> bool
⋮----
"""Mark the given selection as not selected.

        Args:
            value: The value to mark as not selected.

        Returns:
            `True` if the value was deselected, `False` if not.
        """
⋮----
def deselect(self, selection: Selection[SelectionType] | SelectionType) -> Self
⋮----
"""Mark the given selection as not selected.

        Args:
            selection: The selection to mark as not selected.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.
        """
⋮----
def deselect_all(self) -> Self
⋮----
"""Deselect all items.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.
        """
⋮----
def _toggle(self, value: SelectionType) -> bool
⋮----
"""Toggle the selection state of the given value.

        Args:
            value: The value to toggle.

        Returns:
            `True`.
        """
⋮----
def toggle(self, selection: Selection[SelectionType] | SelectionType) -> Self
⋮----
"""Toggle the selected state of the given selection.

        Args:
            selection: The selection to toggle.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.
        """
⋮----
def toggle_all(self) -> Self
⋮----
"""Toggle all items.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.
        """
⋮----
"""Turn incoming selection data into a `Selection` instance.

        Args:
            selection: The selection data.

        Returns:
            An instance of a `Selection`.

        Raises:
            SelectionError: If the selection was badly-formed.
        """
⋮----
# If we've been given a tuple of some sort, turn that into a proper
# Selection.
⋮----
selection = cast(
⋮----
selection = Selection[SelectionType](*selection)
⋮----
# At this point we should have a proper selection.
⋮----
# If the initial state for this is that it's selected, add it to the
# selected collection.
⋮----
def _toggle_highlighted_selection(self) -> None
⋮----
"""Toggle the state of the highlighted selection.

        If nothing is selected in the list this is a non-operation.
        """
⋮----
def _get_left_gutter_width(self) -> int
⋮----
"""Returns the size of any left gutter that should be taken into account.

        Returns:
            The width of the left gutter.
        """
⋮----
def render_line(self, y: int) -> Strip
⋮----
"""Render a line in the display.

        Args:
            y: The line to render.

        Returns:
            A [`Strip`][textual.strip.Strip] that is the line to render.
        """
⋮----
# TODO: This is rather crufty and hard to fathom. Candidate for a rewrite.
⋮----
# First off, get the underlying prompt from OptionList.
line = super().render_line(y)
⋮----
# We know the prompt we're going to display, what we're going to do
# is place a CheckBox-a-like button next to it. So to start with
# let's pull out the actual Selection we're looking at right now.
⋮----
selection_index = scroll_y + y
⋮----
selection = self.get_option_at_index(selection_index)
⋮----
# Figure out which component style is relevant for a checkbox on
# this particular line.
component_style = "selection-list--button"
⋮----
# # # Get the underlying style used for the prompt.
# TODO: This is not a reliable way of getting the base style
underlying_style = next(iter(line)).style or self.rich_style
⋮----
# Get the style for the button.
button_style = self.get_component_rich_style(component_style)
⋮----
# Build the style for the side characters. Note that this is
# sensitive to the type of character used, so pay attention to
# BUTTON_LEFT and BUTTON_RIGHT.
side_style = Style.from_color(button_style.bgcolor, underlying_style.bgcolor)
⋮----
# Add the option index to the style. This is used to determine which
# option to select when the button is clicked or hovered.
⋮----
# At this point we should have everything we need to place a
# "button" before the option.
⋮----
"""Capture the `OptionList` highlight event and turn it into a [`SelectionList`][textual.widgets.SelectionList] event.

        Args:
            event: The event to capture and recreate.
        """
⋮----
def _on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None
⋮----
"""Capture the `OptionList` selected event and turn it into a [`SelectionList`][textual.widgets.SelectionList] event.

        Args:
            event: The event to capture and recreate.
        """
⋮----
def get_option_at_index(self, index: int) -> Selection[SelectionType]
⋮----
"""Get the selection option at the given index.

        Args:
            index: The index of the selection option to get.

        Returns:
            The selection option at that index.

        Raises:
            OptionDoesNotExist: If there is no selection option with the index.
        """
⋮----
def get_option(self, option_id: str) -> Selection[SelectionType]
⋮----
"""Get the selection option with the given ID.

        Args:
            option_id: The ID of the selection option to get.

        Returns:
            The selection option with the ID.

        Raises:
            OptionDoesNotExist: If no selection option has the given ID.
        """
⋮----
def _pre_remove_option(self, option: Option, index: int) -> None
⋮----
"""Hook called prior to removing an option."""
⋮----
# Decrement index of options after the one we just removed.
⋮----
"""Add new selection options to the end of the list.

        Args:
            items: The new items to add.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.

        Raises:
            DuplicateID: If there is an attempt to use a duplicate ID.
            SelectionError: If one of the selection options is of the wrong form.
        """
# This... is sort of sub-optimal, but a natural consequence of
# inheriting from and narrowing down OptionList. Here we don't want
# things like a separator, or a base Option, being passed in. So we
# extend the types of accepted items to keep mypy and friends happy,
# but then we runtime check that we've been given sensible types (in
# this case the supported tuple values).
cleaned_options: list[Selection[SelectionType]] = []
⋮----
# Add the new items to the value mappings.
⋮----
"""Add a new selection option to the end of the list.

        Args:
            item: The new item to add.

        Returns:
            The [`SelectionList`][textual.widgets.SelectionList] instance.

        Raises:
            DuplicateID: If there is an attempt to use a duplicate ID.
            SelectionError: If the selection option is of the wrong form.
        """
⋮----
def clear_options(self) -> Self
⋮----
"""Clear the content of the selection list.

        Returns:
            The `SelectionList` instance.
        """
</file>

</files>
