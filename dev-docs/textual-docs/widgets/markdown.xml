This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/textual/widgets/_markdown.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  textual/
    widgets/
      _markdown.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/textual/widgets/_markdown.py">
TableOfContentsType: TypeAlias = "list[tuple[int, str, str | None]]"
"""Information about the table of contents of a markdown document.

The triples encode the level, the label, and the optional block id of each heading.
"""
⋮----
class MarkdownStream
⋮----
"""An object to manage streaming markdown.

    This will accumulate markdown fragments if they can't be rendered fast enough.

    This object is typically created by the [Markdown.get_stream][textual.widgets.Markdown.get_stream] method.

    """
⋮----
def __init__(self, markdown_widget: Markdown) -> None
⋮----
"""
        Args:
            markdown_widget: Markdown widget to update.
        """
⋮----
def start(self) -> None
⋮----
"""Start the updater running in the background.

        No need to call this, if the object was created by [Markdown.get_stream][textual.widgets.Markdown.get_stream].

        """
⋮----
async def stop(self) -> None
⋮----
"""Stop the stream and await its finish."""
⋮----
async def write(self, markdown_fragment: str) -> None
⋮----
"""Append or enqueue a markdown fragment.

        Args:
            markdown_fragment: A string to append at the end of the document.
        """
⋮----
# Nothing to do for empty strings.
⋮----
# Append the new fragment, and set an event to tell the _run loop to wake up
⋮----
# Allow the task to wake up and actually display the new markdown
⋮----
async def _run(self) -> None
⋮----
"""Run a task to append markdown fragments when available."""
⋮----
new_markdown = "".join(self._pending)
⋮----
# Task has been cancelled, add any outstanding markdown
⋮----
class Navigator
⋮----
"""Manages a stack of paths like a browser."""
⋮----
def __init__(self) -> None
⋮----
@property
    def location(self) -> Path
⋮----
"""The current location.

        Returns:
            A path for the current document.
        """
⋮----
@property
    def start(self) -> bool
⋮----
"""Is the current location at the start of the stack?"""
⋮----
@property
    def end(self) -> bool
⋮----
"""Is the current location at the end of the stack?"""
⋮----
def go(self, path: str | PurePath) -> Path
⋮----
"""Go to a new document.

        Args:
            path: Path to new document.

        Returns:
            New location.
        """
⋮----
path = f"{current_file}#{anchor}"
new_path = self.location.parent / Path(path)
⋮----
new_path = new_path.absolute()
⋮----
def back(self) -> bool
⋮----
"""Go back in the stack.

        Returns:
            True if the location changed, otherwise False.
        """
⋮----
def forward(self) -> bool
⋮----
"""Go forward in the stack.

        Returns:
            True if the location changed, otherwise False.
        """
⋮----
class MarkdownBlock(Static)
⋮----
"""The base class for a Markdown Element."""
⋮----
COMPONENT_CLASSES = {"em", "strong", "s", "code_inline"}
"""
    These component classes target standard inline markdown styles.
    Changing these will potentially break the standard markdown formatting.

    | Class | Description |
    | :- | :- |
    | `code_inline` | Target text that is styled as inline code. |
    | `em` | Target text that is emphasized inline. |
    | `s` | Target text that is styled inline with strikethrough. |
    | `strong` | Target text that is styled inline with strong. |
    """
⋮----
DEFAULT_CSS = """
⋮----
"""A reference to the Markdown document that contains this block."""
⋮----
@property
    def select_container(self) -> Widget
⋮----
@property
    def source(self) -> str | None
⋮----
"""The source of this block if known, otherwise `None`."""
⋮----
def _copy_context(self, block: MarkdownBlock) -> None
⋮----
"""Copy the context from another block."""
⋮----
def compose(self) -> ComposeResult
⋮----
def set_content(self, content: Content) -> None
⋮----
async def _update_from_block(self, block: MarkdownBlock) -> None
⋮----
async def action_link(self, href: str) -> None
⋮----
"""Called on link click."""
⋮----
def build_from_token(self, token: Token) -> None
⋮----
"""Build inline block content from its source token.

        Args:
            token: The token from which this block is built.
        """
⋮----
content = self._token_to_content(token)
⋮----
def _token_to_content(self, token: Token) -> Content
⋮----
"""Convert an inline token to Textual Content.

        Args:
            token: A markdown token.

        Returns:
            Content instance.
        """
⋮----
tokens: list[str] = []
spans: list[Span] = []
style_stack: list[tuple[Style | str, int]] = []
position: int = 0
⋮----
def add_content(text: str) -> None
⋮----
"""Add text to the tokens list, and advance the position.

            Args:
                text: Text to add.

            """
⋮----
def add_style(style: Style | str) -> None
⋮----
"""Add a style to the stack.

            Args:
                style: A style as Style instance or string.
            """
⋮----
position = 0
⋮----
def close_tag() -> None
⋮----
child_type = child.type
⋮----
href = child.attrs.get("href", "")
action = f"link({href!r})"
⋮----
href = child.attrs.get("src", "")
alt = child.attrs.get("alt", "")
⋮----
content = Content("".join(tokens), spans=spans)
⋮----
class MarkdownHeader(MarkdownBlock)
⋮----
"""Base class for a Markdown header."""
⋮----
LEVEL = 0
⋮----
class MarkdownH1(MarkdownHeader)
⋮----
"""An H1 Markdown header."""
⋮----
LEVEL = 1
⋮----
class MarkdownH2(MarkdownHeader)
⋮----
"""An H2 Markdown header."""
⋮----
LEVEL = 2
⋮----
class MarkdownH3(MarkdownHeader)
⋮----
"""An H3 Markdown header."""
⋮----
LEVEL = 3
⋮----
class MarkdownH4(MarkdownHeader)
⋮----
"""An H4 Markdown header."""
⋮----
LEVEL = 4
⋮----
class MarkdownH5(MarkdownHeader)
⋮----
"""An H5 Markdown header."""
⋮----
LEVEL = 5
⋮----
class MarkdownH6(MarkdownHeader)
⋮----
"""An H6 Markdown header."""
⋮----
LEVEL = 6
⋮----
class MarkdownHorizontalRule(MarkdownBlock)
⋮----
"""A horizontal rule."""
⋮----
class MarkdownParagraph(MarkdownBlock)
⋮----
"""A paragraph Markdown block."""
⋮----
SCOPED_CSS = False
⋮----
async def _update_from_block(self, block: MarkdownBlock)
⋮----
class MarkdownBlockQuote(MarkdownBlock)
⋮----
"""A block quote Markdown block."""
⋮----
class MarkdownList(MarkdownBlock)
⋮----
class MarkdownBulletList(MarkdownList)
⋮----
"""A Bullet list Markdown block."""
⋮----
bullet = MarkdownBullet()
⋮----
class MarkdownOrderedList(MarkdownList)
⋮----
"""An ordered list Markdown block."""
⋮----
suffix = ". "
start = 1
⋮----
start = int(self._blocks[0].bullet)
⋮----
symbol_size = max(
⋮----
class MarkdownTableCellContents(Static)
⋮----
"""Widget for table cells.

    A shim over a Static which responds to links.
    """
⋮----
"""Pass a link action on to the MarkdownTable parent."""
⋮----
class MarkdownTableContent(Widget)
⋮----
"""Renders a Markdown table."""
⋮----
COMPONENT_CLASSES = {"markdown-table--header", "markdown-table--lines"}
⋮----
def __init__(self, headers: list[Content], rows: list[list[Content]])
⋮----
"""List of header text."""
⋮----
"""The row contents."""
⋮----
def pre_layout(self, layout: Layout) -> None
⋮----
def _update_content(self, headers: list[Content], rows: list[list[Content]])
⋮----
"""Update cell contents."""
⋮----
cells: list[Content] = [
⋮----
async def _update_rows(self, updated_rows: list[list[Content]]) -> None
⋮----
new_cells: list[Static] = []
⋮----
def on_mount(self) -> None
⋮----
class MarkdownTable(MarkdownBlock)
⋮----
"""A Table markdown Block."""
⋮----
def __init__(self, markdown: Markdown, token: Token, *args, **kwargs) -> None
⋮----
def _get_headers_and_rows(self) -> tuple[list[Content], list[list[Content]]]
⋮----
"""Get list of headers, and list of rows.

        Returns:
            A tuple containing a list of headers, and a list of rows.
        """
⋮----
def flatten(block: MarkdownBlock) -> Iterable[MarkdownBlock]
⋮----
headers: list[Content] = []
rows: list[list[Content]] = []
⋮----
"""Special case to update a Markdown table.

        Args:
            block: Existing markdown block.
        """
⋮----
table_content = self.query_one(MarkdownTableContent)
⋮----
current_rows = self._rows
⋮----
updated_rows = new_rows[len(current_rows) - 1 :]
⋮----
class MarkdownTBody(MarkdownBlock)
⋮----
"""A table body Markdown block."""
⋮----
class MarkdownTHead(MarkdownBlock)
⋮----
"""A table head Markdown block."""
⋮----
class MarkdownTR(MarkdownBlock)
⋮----
"""A table row Markdown block."""
⋮----
class MarkdownTH(MarkdownBlock)
⋮----
"""A table header Markdown block."""
⋮----
class MarkdownTD(MarkdownBlock)
⋮----
"""A table data Markdown block."""
⋮----
class MarkdownBullet(Widget)
⋮----
"""A bullet widget."""
⋮----
symbol = reactive("\u25cf")
"""The symbol for the bullet."""
⋮----
def get_selection(self, _selection) -> tuple[str, str] | None
⋮----
def render(self) -> Content
⋮----
class MarkdownListItem(MarkdownBlock)
⋮----
"""A list item Markdown block."""
⋮----
def __init__(self, markdown: Markdown, token: Token, bullet: str) -> None
⋮----
class MarkdownOrderedListItem(MarkdownListItem)
⋮----
class MarkdownUnorderedListItem(MarkdownListItem)
⋮----
class MarkdownFence(MarkdownBlock)
⋮----
"""A fence Markdown block."""
⋮----
def __init__(self, markdown: Markdown, token: Token, code: str) -> None
⋮----
@property
    def allow_horizontal_scroll(self) -> bool
⋮----
@classmethod
    def highlight(cls, code: str, language: str) -> Content
⋮----
NUMERALS = " ⅠⅡⅢⅣⅤⅥ"
⋮----
class Markdown(Widget)
⋮----
BULLETS = ["• ", "▪ ", "‣ ", "⭑ ", "◦ "]
"""Unicode bullets used for unordered lists."""
⋮----
BLOCKS: dict[str, type[MarkdownBlock]] = {
"""Mapping of block names on to a widget class."""
⋮----
"""A Markdown widget.

        Args:
            markdown: String containing Markdown or None to leave blank for now.
            name: The name of the widget.
            id: The ID of the widget in the DOM.
            classes: The CSS classes of the widget.
            parser_factory: A factory function to return a configured MarkdownIt instance. If `None`, a "gfm-like" parser is used.
            open_links: Open links automatically. If you set this to `False`, you can handle the [`LinkClicked`][textual.widgets.markdown.Markdown.LinkClicked] events.
        """
⋮----
@property
    def table_of_contents(self) -> TableOfContentsType
⋮----
"""The document's table of contents."""
⋮----
class TableOfContentsUpdated(Message)
⋮----
"""The table of contents was updated."""
⋮----
"""The `Markdown` widget associated with the table of contents."""
⋮----
"""Table of contents."""
⋮----
@property
        def control(self) -> Markdown
⋮----
"""The `Markdown` widget associated with the table of contents.

            This is an alias for [`TableOfContentsUpdated.markdown`][textual.widgets.Markdown.TableOfContentsSelected.markdown]
            and is used by the [`on`][textual.on] decorator.
            """
⋮----
class TableOfContentsSelected(Message)
⋮----
"""An item in the TOC was selected."""
⋮----
def __init__(self, markdown: Markdown, block_id: str) -> None
⋮----
"""The `Markdown` widget where the selected item is."""
⋮----
"""ID of the block that was selected."""
⋮----
"""The `Markdown` widget where the selected item is.

            This is an alias for [`TableOfContentsSelected.markdown`][textual.widgets.Markdown.TableOfContentsSelected.markdown]
            and is used by the [`on`][textual.on] decorator.
            """
⋮----
class LinkClicked(Message)
⋮----
"""A link in the document was clicked."""
⋮----
def __init__(self, markdown: Markdown, href: str) -> None
⋮----
"""The `Markdown` widget containing the link clicked."""
⋮----
"""The link that was selected."""
⋮----
"""The `Markdown` widget containing the link clicked.

            This is an alias for [`LinkClicked.markdown`][textual.widgets.Markdown.LinkClicked.markdown]
            and is used by the [`on`][textual.on] decorator.
            """
⋮----
@property
    def source(self) -> str
⋮----
"""The markdown source."""
⋮----
def get_block_class(self, block_name: str) -> type[MarkdownBlock]
⋮----
"""Get the block widget class.

        Args:
            block_name: Name of the block.

        Returns:
            A MarkdownBlock class
        """
⋮----
async def _on_mount(self, _: Mount) -> None
⋮----
initial_markdown = self._initial_markdown
⋮----
@classmethod
    def get_stream(cls, markdown: Markdown) -> MarkdownStream
⋮----
"""Get a [MarkdownStream][textual.widgets.markdown.MarkdownStream] instance to stream Markdown in the background.

        If you append to the Markdown document many times a second, it is possible the widget won't
        be able to update as fast as you write (occurs around 20 appends per second). It will still
        work, but the user will have to wait for the UI to catch up after the document has be retrieved.

        Using a [MarkdownStream][textual.widgets.markdown.MarkdownStream] will combine several updates in to one
        as necessary to keep up with the incoming data.

        example:
        ```python
        # self.get_chunk is a hypothetical method that retrieves a
        # markdown fragment from the network
        @work
        async def stream_markdown(self) -> None:
            markdown_widget = self.query_one(Markdown)
            container = self.query_one(VerticalScroll)
            container.anchor()

            stream = Markdown.get_stream(markdown_widget)
            try:
                while (chunk:= await self.get_chunk()) is not None:
                    await stream.write(chunk)
            finally:
                await stream.stop()
        ```


        Args:
            markdown: A [Markdown][textual.widgets.Markdown] widget instance.

        Returns:
            The Markdown stream object.
        """
updater = MarkdownStream(markdown)
⋮----
def on_markdown_link_clicked(self, event: LinkClicked) -> None
⋮----
@staticmethod
    def sanitize_location(location: str) -> tuple[Path, str]
⋮----
"""Given a location, break out the path and any anchor.

        Args:
            location: The location to sanitize.

        Returns:
            A tuple of the path to the location cleaned of any anchor, plus
            the anchor (or an empty string if none was found).
        """
⋮----
def goto_anchor(self, anchor: str) -> bool
⋮----
"""Try and find the given anchor in the current document.

        Args:
            anchor: The anchor to try and find.

        Note:
            The anchor is found by looking at all of the headings in the
            document and finding the first one whose slug matches the
            anchor.

            Note that the slugging method used is similar to that found on
            GitHub.

        Returns:
            True when the anchor was found in the current document, False otherwise.
        """
⋮----
unique = TrackedSlugs()
⋮----
async def load(self, path: Path) -> None
⋮----
"""Load a new Markdown document.

        Args:
            path: Path to the document.

        Raises:
            OSError: If there was some form of error loading the document.

        Note:
            The exceptions that can be raised by this method are all of
            those that can be raised by calling [`Path.read_text`][pathlib.Path.read_text].
        """
⋮----
data = await asyncio.get_running_loop().run_in_executor(
⋮----
def unhandled_token(self, token: Token) -> MarkdownBlock | None
⋮----
"""Process an unhandled token.

        Args:
            token: The MarkdownIt token to handle.

        Returns:
            Either a widget to be added to the output, or `None`.
        """
⋮----
def _parse_markdown(self, tokens: Iterable[Token]) -> Iterable[MarkdownBlock]
⋮----
"""Create a stream of MarkdownBlock widgets from markdown.

        Args:
            tokens: List of tokens.

        Yields:
            Widgets for mounting.
        """
⋮----
stack: list[MarkdownBlock] = []
stack_append = stack.append
⋮----
get_block_class = self.get_block_class
⋮----
token_type = token.type
⋮----
item_count = sum(
⋮----
block = stack.pop()
⋮----
fence_class = get_block_class(token_type)
⋮----
fence = fence_class(self, token, token.content.rstrip())
⋮----
external = self.unhandled_token(token)
⋮----
def _build_from_source(self, markdown: str) -> list[MarkdownBlock]
⋮----
"""Build blocks from markdown source.

        Args:
            markdown: A Markdown document, or partial document.

        Returns:
            A list of MarkdownBlock instances.
        """
parser = (
tokens = parser.parse(markdown)
⋮----
def update(self, markdown: str) -> AwaitComplete
⋮----
"""Update the document with new Markdown.

        Args:
            markdown: A string containing Markdown.

        Returns:
            An optionally awaitable object. Await this to ensure that all children have been mounted.
        """
⋮----
markdown_block = self.query("MarkdownBlock")
⋮----
async def await_update() -> None
⋮----
"""Update in batches."""
BATCH_SIZE = 200
batch: list[MarkdownBlock] = []
⋮----
# Lock so that you can't update with more than one document simultaneously
⋮----
tokens = await asyncio.get_running_loop().run_in_executor(
⋮----
# Remove existing blocks for the first batch only
removed: bool = False
⋮----
async def mount_batch(batch: list[MarkdownBlock]) -> None
⋮----
"""Mount a single match of blocks.

                    Args:
                        batch: A list of blocks to mount.
                    """
⋮----
removed = True
⋮----
lines = markdown.splitlines()
⋮----
def append(self, markdown: str) -> AwaitComplete
⋮----
"""Append to markdown.

        Args:
            markdown: A fragment of markdown to be appended.

        Returns:
            An optionally awaitable object. Await this to ensure that the markdown has been append by the next line.
        """
⋮----
updated_source = "".join(
⋮----
async def await_append() -> None
⋮----
"""Append new markdown widgets."""
⋮----
tokens = parser.parse(updated_source)
existing_blocks = [
start_line = self._last_parsed_line
⋮----
new_blocks = list(self._parse_markdown(tokens))
any_headers = any(
⋮----
last_block = existing_blocks[-1]
⋮----
new_blocks = new_blocks[1:]
⋮----
class MarkdownTableOfContents(Widget, can_focus_children=True)
⋮----
"""Displays a table of contents for a markdown document."""
⋮----
table_of_contents = reactive[Optional[TableOfContentsType]](None, init=False)
"""Underlying data to populate the table of contents widget."""
⋮----
"""Initialize a table of contents.

        Args:
            markdown: The Markdown document associated with this table of contents.
            name: The name of the widget.
            id: The ID of the widget in the DOM.
            classes: The CSS classes for the widget.
            disabled: Whether the widget is disabled or not.
        """
⋮----
"""The Markdown document associated with this table of contents."""
⋮----
tree: Tree = Tree("TOC")
⋮----
def watch_table_of_contents(self, table_of_contents: TableOfContentsType) -> None
⋮----
"""Triggered when the table of contents changes."""
⋮----
def rebuild_table_of_contents(self, table_of_contents: TableOfContentsType) -> None
⋮----
"""Rebuilds the tree representation of the table of contents data.

        Args:
            table_of_contents: Table of contents.
        """
tree = self.query_one(Tree)
⋮----
root = tree.root
⋮----
node = root
⋮----
node = node._children[-1]
⋮----
node = node.add(NUMERALS[level], expand=True)
node_label = Text.assemble((f"{NUMERALS[level]} ", "dim"), name)
⋮----
async def _on_tree_node_selected(self, message: Tree.NodeSelected) -> None
⋮----
node_data = message.node.data
⋮----
class MarkdownViewer(VerticalScroll, can_focus=False, can_focus_children=True)
⋮----
"""A Markdown viewer widget."""
⋮----
show_table_of_contents = reactive(True)
"""Show the table of contents?"""
top_block = reactive("")
⋮----
navigator: var[Navigator] = var(Navigator)
⋮----
class NavigatorUpdated(Message)
⋮----
"""Navigator has been changed (clicked link etc)."""
⋮----
"""Create a Markdown Viewer object.

        Args:
            markdown: String containing Markdown, or None to leave blank.
            show_table_of_contents: Show a table of contents in a sidebar.
            name: The name of the widget.
            id: The ID of the widget in the DOM.
            classes: The CSS classes of the widget.
            parser_factory: A factory function to return a configured MarkdownIt instance. If `None`, a "gfm-like" parser is used.
            open_links: Open links automatically. If you set this to `False`, you can handle the [`LinkClicked`][textual.widgets.markdown.Markdown.LinkClicked] events.
        """
⋮----
@property
    def document(self) -> Markdown
⋮----
"""The [`Markdown`][textual.widgets.Markdown] document widget."""
⋮----
@property
    def table_of_contents(self) -> MarkdownTableOfContents
⋮----
"""The [table of contents][textual.widgets.markdown.MarkdownTableOfContents] widget."""
⋮----
async def go(self, location: str | PurePath) -> None
⋮----
"""Navigate to a new document path."""
⋮----
# We've been asked to go to an anchor but with no file specified.
⋮----
# We've been asked to go to a file, optionally with an anchor.
⋮----
async def back(self) -> None
⋮----
"""Go back one level in the history."""
⋮----
async def forward(self) -> None
⋮----
"""Go forward one level in the history."""
⋮----
async def _on_markdown_link_clicked(self, message: Markdown.LinkClicked) -> None
⋮----
def watch_show_table_of_contents(self, show_table_of_contents: bool) -> None
⋮----
markdown = Markdown(
⋮----
block_selector = f"#{message.block_id}"
block = self.query_one(block_selector, MarkdownBlock)
</file>

</files>
