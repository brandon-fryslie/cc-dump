# Evaluation: Phase 1 Filter Performance Optimizations
Timestamp: 2026-02-03-033729
Git Commit: a11672a

## Executive Summary
Overall: 0% complete (not started) | Critical issues: 0 | Tests reliable: yes

All three tickets are **NOT_STARTED**. The current code is clean and well-structured, making implementation straightforward. The main risk is getting the incremental widest-line calculation correct when cached per-turn values decrease. Dependencies between tickets are correctly modeled in the issue tracker.

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| test_widget_arch.py | PASS | 23/23 (0.28s) |
| Full test suite | PASS | 305 tests collected, all passing |

## Missing Checks
The following tests should be created alongside the implementation:

1. **Test `_widest_strip` caching**: Verify `TurnData._widest_strip` is set after `re_render()` and matches actual max `strip.cell_length`.
2. **Test incremental offset correctness**: Create N turns, change turn K, verify offsets for turns K..N are correct and turns 0..K-1 unchanged.
3. **Test widest-line-shrink edge case**: When the turn holding the global widest line gets re-rendered with fewer/narrower strips, verify `_widest_line` is recalculated correctly (requires full scan of cached per-turn values).
4. **Test `first_changed` tracking**: Verify `rerender()` correctly identifies the first changed turn index across various filter toggle scenarios.

## Findings

### cc-dump-e38: Cache per-turn widest line width
**Status**: NOT_STARTED
**Evidence**: `TurnData` dataclass at `/Users/bmf/code/cc-dump/src/cc_dump/tui/widget_factory.py:28-46` has no `_widest_strip` field. `_recalculate_offsets()` at line 209 scans all strips every call.
**Implementation Plan**:
- Add `_widest_strip: int = 0` field to `TurnData` (line 40 area)
- Update `TurnData.re_render()` (line 60) to compute and cache widest strip after rendering
- Update `add_turn()` (line 225) to also set `_widest_strip` on the new `TurnData`
- Update `_recalculate_offsets()` to use `turn._widest_strip` instead of inner strip loop
- Update `_update_streaming_size()` (line 341) similarly -- this is a **code duplication** that should be addressed (see Ambiguities)
- Update `on_resize()` (line 621) which bypasses `re_render()` and directly assigns `td.strips` -- must also update `_widest_strip` there
- Update `finalize_streaming_turn()` (line 422) which also directly assigns `td.strips`

**Risk**: 7 call sites modify strips. Missing any one will leave stale `_widest_strip` values. The `on_resize()` path (line 632-635) directly assigns `td.strips` without going through `re_render()`, so `_widest_strip` must be explicitly recomputed there.

### cc-dump-ax6: Track changed turn range during rerender
**Status**: NOT_STARTED
**Evidence**: `rerender()` at line 581-590 uses a boolean `changed = False` with `changed = True` on any change.
**Implementation Plan**:
- Replace `changed = False` with `first_changed = None`
- In the loop body, when `td.re_render()` returns True and `first_changed is None`, set `first_changed = td.turn_index` (or the loop index)
- Pass `first_changed` to offset recalculation instead of boolean

**Risk**: Low. The change is mechanical. One subtlety: turns are iterated in order (`self._turns`), so the first True return is guaranteed to be the earliest changed turn. No edge case with non-sequential turn indices since the loop iterates the list linearly.

### cc-dump-0oo: Incremental offset recalculation
**Status**: NOT_STARTED
**Evidence**: `_recalculate_offsets()` at line 209 always starts from offset=0 and iterates all turns.
**Implementation Plan**:
- Add `_recalculate_offsets_from(start_index: int)` method
- For offset: read `self._turns[start_index - 1].line_offset + self._turns[start_index - 1].line_count` as starting offset (or 0 if start_index == 0)
- For widest: if cc-dump-e38 is done, take `max(turn._widest_strip for turn in self._turns)` -- but this is still O(n) unless we maintain a running max. However, with cached per-turn values it is O(n) comparisons instead of O(n*m) property accesses.
- Keep `_recalculate_offsets()` as a thin wrapper: `self._recalculate_offsets_from(0)`
- Update `rerender()` to call `_recalculate_offsets_from(first_changed)` when `first_changed is not None`

**Risk**: The widest-line calculation cannot be truly incremental without additional bookkeeping. When a turn's strips shrink (filter hides content), the global `_widest_line` might need to decrease. With per-turn cache (cc-dump-e38), recomputing the global max is O(n) integer comparisons -- still a significant improvement over O(n*m) strip property access, but not O(k). This is acceptable for Phase 1.

## Ambiguities Found

| Area | Question | How LLM Might Guess | Impact |
|------|----------|---------------------|--------|
| `_update_streaming_size` duplication | Should this method be unified with `_recalculate_offsets`? | Implementer might optimize only `_recalculate_offsets` and miss the duplicate at line 341 | Medium -- streaming turns would still have O(n*m) on every delta append |
| Widest-line shrink | When the globally-widest turn gets narrower, should we do a full scan or accept stale values? | Might skip the full scan, leaving virtual_size too wide | Low -- too-wide is cosmetic (extra scroll space), too-narrow would clip content |
| `on_resize` bypass | `on_resize()` (line 632) assigns `td.strips` directly without `re_render()`. Should `_widest_strip` caching go in `re_render()` only or also here? | Might only put it in `re_render()` and miss `on_resize` | Medium -- stale cache after resize |
| `_toggle_block_expand` single-turn | `_toggle_block_expand()` (line 770) calls `_recalculate_offsets()` for a single turn change. Should it use incremental? | Might overlook this call site | Low -- single block expand is infrequent |
| Cache invalidation scope | `_recalculate_offsets` clears entire `_line_cache`. Should incremental version clear less? | Might still clear all | Low -- Phase 2 ticket cc-dump-0fe covers this |

## Recommendations

1. **Implement in dependency order**: cc-dump-ax6 first (no deps), then cc-dump-e38 (independent but enhances 0oo), then cc-dump-0oo (depends on ax6, benefits from e38).

2. **Address `_update_streaming_size` duplication**: Either (a) make it call `_recalculate_offsets()` (simplest -- streaming is already per-delta, extra overhead is small), or (b) also give it incremental support. Option (a) is recommended to reduce code duplication first.

3. **Enumerate all strip-assignment sites**: Before implementing cc-dump-e38, catalog every location that assigns `td.strips`:
   - `TurnData.re_render()` -- line 78
   - `ConversationView.add_turn()` via constructor -- line 235
   - `on_resize()` -- line 632
   - `_refresh_streaming_delta()` -- line 299/313
   - `_flush_streaming_delta()` -- line 333
   - `append_streaming_block()` -- line 404
   - `finalize_streaming_turn()` -- line 469

   Each must update `_widest_strip`. The safest approach: compute `_widest_strip` inside `_recalculate_offsets()` from the strip list (not cache it separately), then later optimize by caching once the pattern is proven.

4. **Write tests before implementing**: The existing tests are solid and behavioral. Add tests for:
   - Offset correctness after incremental recalculation
   - `_widest_strip` accuracy after re_render
   - `first_changed` correctly identified

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix

The code is clean, well-tested, and the three tickets are well-scoped. The dependency chain is correct (ax6 -> 0oo, e38 independent). The main trap is the 7+ sites that modify `td.strips` -- the implementer must update `_widest_strip` at each one or centralize it. Recommendation 3 above provides the full list.
