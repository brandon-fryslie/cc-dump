# Evaluation: 3C - Extract Tool Use Summarization from render_blocks()
Timestamp: 2026-02-06-050000
Git Commit: 44b4c64

## Executive Summary
Overall: NOT_STARTED (this is a feasibility evaluation for a proposed refactor) | Critical issues: 1 (bug cc-dump-1vp may be misdiagnosed) | Tests reliable: mostly (no integration-level test for the summary-through-cache path)

## Runtime Check Results
| Check | Status | Output |
|-------|--------|--------|
| Full test suite | PASS | 421 passed, 2 skipped |
| test_tool_rendering.py | PASS | 20/20 pass |
| render_blocks() summary logic | WORKS | Unit tests confirm ToolUseBlock aggregation in render_blocks() |

## Missing Checks
- No test exercises tool summary rendering through `render_turn_to_strips()` (the actual display path). Existing tests call `render_blocks()` directly, which works, but do not validate that the cache in `render_turn_to_strips()` handles summaries correctly.
- No test for toggling tools filter on/off and verifying the summary appears/disappears in the strip output.
- No test for ToolResultBlock disappearing when tools=False (it just vanishes with no summary line).

## Findings

### Bug cc-dump-1vp is Likely Misdiagnosed
**Status**: NEEDS INVESTIGATION
**Evidence**: The bug description claims "both real render paths (widget_factory.py:380 streaming path and render_turn_to_strips rerender path) call render_block() per-block individually, bypassing render_blocks() entirely." This is **factually incorrect** for `render_turn_to_strips()`. At `/Users/bmf/code/cc-dump/src/cc_dump/tui/rendering.py:479`, `render_turn_to_strips()` explicitly iterates over `render_blocks()` output:
```python
for block_idx, text in render_blocks(blocks, filters, expanded_overrides):
```
So the summary IS generated for completed turns. The actual bug (if it exists) is either:
1. A cache invalidation issue where the summary cache key collides or fails to invalidate when toggling the tools filter
2. Something specific to the streaming path (but streaming uses StreamToolUseBlock, not ToolUseBlock)
3. A stale bug that was fixed by subsequent changes

**Impact**: The proposed refactoring for 3C is motivated partly by this bug. If the bug is misdiagnosed, the urgency changes. The refactor has standalone value (cleaner architecture), but is not a bug fix.

### render_blocks() Dual Responsibility
**Status**: CONFIRMED - real complexity issue
**Evidence**: `/Users/bmf/code/cc-dump/src/cc_dump/tui/rendering.py:380-424`. The function does two things: (1) iterate blocks and dispatch to `render_block()`, and (2) accumulate consecutive ToolUseBlocks into a summary when tools filter is off. The `pending_tool_uses` list and inner `flush_tool_uses()` function are the aggregation mechanism.
**Issues**: The flush must be called both mid-loop (line 416) and post-loop (line 423). Any new aggregation pattern would need to add another state variable and flush call, compounding complexity multiplicatively.

### Cache Interaction with Summary
**Status**: SUBTLE BUT FUNCTIONAL
**Evidence**: In `/Users/bmf/code/cc-dump/src/cc_dump/tui/rendering.py:484-492`, the cache key for a summary line is:
```python
cache_key = (id(blocks[block_idx]), width, filters.get("tools", False), None)
```
Where `block_idx` is the first ToolUseBlock's index. When tools=False (summary mode), the filter value in the cache key is `False`. When tools=True (individual mode), `render_blocks()` returns individual blocks, so the cache key for the same block becomes `(id(same_block), width, True, None)`. These are different cache keys, so toggling works correctly in theory.

**However**: The cache is an LRU cache (`LRUCache(4096)` in widget_factory.py:136). When switching from tools=True to tools=False, the cached individual-block entries would be different keys from the new summary entry. The old entries are stale but harmless (different key). The real question is whether `re_render()` properly detects the filter change. Looking at `TurnData.re_render()` in widget_factory.py:75-102: it builds a snapshot of `{k: filters.get(k, False) for k in self.relevant_filter_keys}`. If "tools" is in `relevant_filter_keys`, the snapshot changes when tools is toggled, triggering a full re-render. `compute_relevant_keys()` at line 62-73 iterates blocks and looks up `BLOCK_FILTER_KEY` -- ToolUseBlock maps to "tools", so "tools" IS in the relevant keys set. This means re-render IS triggered correctly.

### Pre-Pass vs Post-Pass Design Question
**Status**: ANALYSIS COMPLETE

**Pre-pass approach** (transform block list before rendering):
- Create a `ToolUseSummaryBlock(FormattedBlock)` that replaces consecutive ToolUseBlock runs
- Pre-pass transforms `[ToolUseBlock, ToolUseBlock, ToolUseBlock]` into `[ToolUseSummaryBlock]`
- `render_block()` renders `ToolUseSummaryBlock` directly
- `render_blocks()` becomes a clean dispatcher with no aggregation state
- **Cache interaction**: The new block would need to be a stable object (not freshly created each call) for `id(block)` cache keys to work. If the pre-pass runs inside `render_blocks()`, the summary block would be recreated each time, breaking cache by `id()`. If the pre-pass runs once when building TurnData and mutates the block list, the block identity is stable, but the original blocks are lost.
- **Problem**: The pre-pass must be filter-dependent (only runs when tools=False). If it mutates the block list, toggling tools on would need to restore the original blocks. This means either (a) storing two block lists per turn, or (b) running the pre-pass on every render as a pure function that returns a new list.

**Post-pass approach** (aggregate after individual rendering):
- `render_blocks()` renders all blocks individually first
- A post-pass scans the output for consecutive None entries from ToolUseBlocks and replaces them with a summary
- **Problem**: When tools=False, `render_block()` returns None for ToolUseBlocks (line 200-201). The output only contains entries where `r is not None` (line 420-421), so ToolUseBlocks are simply absent from the output. A post-pass would need access to the original block list to know where ToolUseBlocks were, defeating the purpose.

**Recommended approach**: Pure-function pre-pass that returns a *new* block list:
1. Create `ToolUseSummaryBlock` dataclass in formatting.py
2. Add `prepare_blocks(blocks, filters)` function that returns either the original blocks (tools=True) or a transformed list with ToolUseSummaryBlock replacing runs (tools=False)
3. `render_blocks()` becomes: `for i, block in enumerate(prepare_blocks(blocks, filters)): ...` with no aggregation state
4. Add `ToolUseSummaryBlock` to BLOCK_RENDERERS and BLOCK_FILTER_KEY
5. **Cache key issue**: Since `prepare_blocks` returns new ToolUseSummaryBlock objects each call, `id(block)` will differ. Two options:
   - (a) Use content-based cache key for summary blocks (hash of tool names + counts)
   - (b) Cache the prepared block list per TurnData, keyed by tools filter state
   - Option (b) is simpler and aligns with how TurnData already caches per filter snapshot

### Interaction with BLOCK_FILTER_KEY Registry
**Status**: CLEAN
**Evidence**: `ToolUseSummaryBlock` would map to `"tools"` in the registry, just like `ToolUseBlock`. Since the summary only appears when tools=False, the filter_key lookup returns "tools", and the cache key includes `filters.get("tools", False)` = `False`. When tools=True, the summary block doesn't exist in the prepared list. This is clean and consistent.

### Streaming Turn Interaction
**Status**: NO IMPACT (for requests)
**Evidence**: Streaming turns render response blocks (StreamToolUseBlock, TextDeltaBlock, etc.), NOT request-side ToolUseBlocks. The tool use summary only applies to request formatting output (format_request produces ToolUseBlock). Streaming responses never produce ToolUseBlock. After finalization, the streaming turn's blocks are consolidated and re-rendered via `render_turn_to_strips()`, which calls `render_blocks()`, which would use the pre-pass. But since finalized streaming turns contain StreamToolUseBlock (not ToolUseBlock), the pre-pass would be a no-op for them.

**However**: Request turns added via `add_turn()` (not streaming) go through `render_turn_to_strips()` immediately. These DO contain ToolUseBlock and would benefit from the summary. This is the correct path.

### ToolResultBlock Gap
**Status**: DESIGN DECISION NEEDED
**Evidence**: Currently, `render_blocks()` only aggregates `ToolUseBlock`, not `ToolResultBlock`. When tools=False, ToolResultBlocks simply return None (filtered out at `/Users/bmf/code/cc-dump/src/cc_dump/tui/rendering.py:211-212`). They produce no summary line. The pre-pass refactor is an opportunity to also summarize ToolResultBlocks (e.g., "[3 tool results: Read, Bash, Read]"). This is a scope expansion question, not a blocker.

## Ambiguities Found
| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Cache key for ToolUseSummaryBlock | Should `id(block)` be used for summary blocks, or content-hash? | N/A - not yet implemented | High if wrong: cache misses on every render or stale cache hits |
| Bug cc-dump-1vp root cause | Is the bug real or misdiagnosed? | Bug filer assumed render_turn_to_strips bypasses render_blocks | Medium: motivates urgency of this refactor |
| ToolResultBlock summarization | Should the pre-pass also summarize tool results? | N/A - not yet decided | Low: can be added later without architectural change |
| Pre-pass caching strategy | Should prepared block lists be cached per TurnData or regenerated each render? | N/A | Medium: affects render performance on filter toggle |

## Recommendations

1. **First: Verify or close cc-dump-1vp.** Run the TUI with tools=False and confirm whether tool summaries actually appear for completed (non-streaming) turns. The bug description is factually wrong about the code path, so the bug may not exist. If it does exist, the root cause is different from what was described.

2. **Implement pre-pass approach with TurnData-level caching.** Create `ToolUseSummaryBlock` in formatting.py. Add `prepare_blocks_for_render(blocks, filters)` as a pure function in rendering.py. Cache the prepared list in TurnData keyed by tools filter value. This avoids the `id(block)` issue entirely because the prepared list is cached and reused.

3. **Keep ToolResultBlock out of scope initially.** The pre-pass architecture supports adding it later. Mixing both in the first pass increases implementation risk.

4. **Add integration test for summary-through-strips path.** The existing tests only exercise `render_blocks()` directly. Need a test that calls `render_turn_to_strips()` with ToolUseBlocks and tools=False, verifying strip output contains the summary text.

5. **Update render_blocks() to be a clean dispatcher.** After extracting the pre-pass, render_blocks() should be:
   ```python
   def render_blocks(blocks, filters, expanded_overrides=None):
       prepared = prepare_blocks_for_render(blocks, filters)
       rendered = []
       for i, block in enumerate(prepared):
           ...dispatch to render_block()...
       return rendered
   ```

## Verdict
- [x] CONTINUE - Issues clear, implementer can fix

The refactoring is well-scoped and architecturally sound. The pre-pass approach with TurnData-level caching is the cleanest option given the existing cache architecture. The one action item before starting implementation: verify whether cc-dump-1vp is a real bug or stale, since it materially affects how the refactor should be tested.

Estimated effort: Small-Medium. ~50 lines of new code (ToolUseSummaryBlock + prepare_blocks + renderer), ~20 lines removed from render_blocks(), ~30 lines of new tests.
